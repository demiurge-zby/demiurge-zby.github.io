[{"content":" 说在前面 本篇文章的内容并不能达到可以让你跟着做完整个编译器项目的程度，它只是我最终总结时的一些回忆，而非施工现场。\n倘若能在某个时候激发起你的共鸣，给予你信心或是方向，那便已是极好的了。\n整体架构 bzh学长的架构 顶层文件夹是Compiler与config，还有frontend,midend,backend,utils,optimise,error六个包。\nerror进行错误处理，前端处理词法与语法分析，中端进行语义分析，LLVM体系定义与中间代码生成，后端进行MIPS语言体系的定义，optimise进行中端优化，utils是一些功能启动、文件输入输出、性能结果展示等附加功能的定义。\ncompiler首先调用工具进行testfile的读入，然后调用前端得到tokenlist与语法树，语法树树根传给中端，中端遍历语法树得到符号表与中间代码结构，将中间代码模块传递给optimiser进行优化后，再传递给后端，后端递归执行toMips，得到最终的MIPS模块结构。\n所有产物都可以借助IOHandler输出为文件。\n再详细的架构再讲就讲不完了。\n我的简单改装 在细节上的架构，我和学长代码保持了较为高度的一致，最多只是将某些类进行合并或者拆分。\n但在宏观上我根据自己的主观理解，进行了较大的调整。不过意义也不是很大。\n我顶层的包分为前端，中端，后端，错误与工具。\nfrontend处理词法分析，语法分析之外，我没有传递语法树，而是继续在前端进行语义分析与中间代码生成。因为这一段本就是与源代码高度相关，语法树更是直接来源于源代码的文法。\n我在思考，如果真的做到修改源代码不必修改midend的话，midend里该有的内容，可能只有llvm那个文件夹。而visit与symbol都是属于与源代码有关的内容，如果更改了文法，肯定是要有改动的。\n因此我前端内部的文件夹有lexer,parse,ast,还有llvm_ir这个包，这个包包含symbol与visit，主要负责的就是产出中端所需的架构。\nmidend在严格意义上，包含的动作只有中间代码优化。此外他还包括llvm的架构定义。因此里面包括llvm和optimiser两个包。\nbackend则涵盖中间代码生成目标代码所需要的架构信息与Builder。有一个现象值得注意：后端的实质翻译工作 toMips() 实际上定义在midend文件夹，也即llvm文件夹，因为从前往后推进的过程中，后端貌似就是要依赖于中端的架构才可以工作。\n那如果后端发生改变，需要更改的为什么是midend文件夹而不是backend文件夹呢？我想，可能只有优化严格属于中端，中端到后端的toMips函数可能只是身在中端，其实不属于中端吧。\n无论怎样，关于我的代码架构，我可以说，如果期末考试源代码文法发生改变，我确实只应当修改frontend文件夹。\n词法分析 刚开始接触编译器的搭建时，面对复杂多样的文法，茫然的情绪是毋庸置疑的。 但我一直对词法分析抱有美好愿想，因为它看起来只不过是把token提取出来， 这和整体的结构关系不大。\n但尽管是相对独立的结构，也需要融入整个大型框架。因此我借鉴了往届的优秀代码， 对编译器整体的前中后端与错误处理框架形成了基础认知，才开始了编写工作。\n不过官方已经给出了确定的token类别，其实词法分析的问题并不是很多。 需要注意的点是注释的处理， 可以检查一下/*/与/***/能否正确处理。\nOct.4更新： 注释相关的处理出现了问题！\n跨行的注释请注意不能无脑read，要记录行数的增加！ 对于//，读取到\\n之后要再read一次去掉换行符，否则会影响行数记录 Oct.22更新： 注释相关的处理再次出现了问题！ 参见讨论区。 Jan.1更新：\njym同学的测试点中包含转义字符相关内容。所以顺便也实现了一下。\n从架构而言，首先要形成frontend/midend/backend/utils这样的系统结构观念；其次在frontend中需要有一个frontend类，还要有parser/ast/lexer等等。我们在lexer中主要实现的就是针对读取到的char分析出是什么单词，并加入单词列表，因此还需要实现Token类和token类型。\n另外，作为最起始的框架，IO操作也是一个关键点，不过参考学长代码之后不难解决其处理模式，放在utils包中很有结构感。\n语法分析 语法分析的难度个人认为远超词法分析。 因为他看似只是进行结构的划分，但是结构的性质，也就是语义分析部分极为重要， 要尽可能形成相对科学合理的结构。 而这个结构，虽然文法已经给出了一些提示， 但还是有许多需要自己决定的结构。\nFIRST集 对于多分支的处理，我们常常使用FIRST集来尽可能区分不同的分支。\n简单的比如Decl → ConstDecl | VarDecl，可以用const来区分。\n稍微复杂一点的比如BlockItem → Decl | Stmt， 经过多层分析发现，First(Decl) 包括 CONSTTK | STATICTK | INTTK， 并且这些都不出现在stmt中，从而可以区分。\n最复杂的就是Stmt了，他的情况极其多，虽然大多数还是很好区分的， 比如if,for,continue,break,return,printf,block。 但是不好区分的就是LVal=Exp;和Exp;。原则上我们总可以发现在某个时候可能出现 可观测的差距，但是我们不妨可以使用这样的一种方法：\n回溯 仔细观察LVal=Exp;和Exp;，可以知道LVal也属于Exp，因此一定可以被Exp识别。 那么只需要看读取Exp之后的符号即可，如果是=，则说明是前者。\n但是原则上，LVal和Exp是不同的，形成的语法树结构也不同。因此前面的分析 只能用来判断，而不能用来构造语法树。\n这时候的识别就需要被回溯了。我们需要注意三点：\n尝试的时候不能更改树的结构，可以new，可以parse，但是不能add到树上。 尝试过程中如果遇到语法错误，不可以记录。 在尝试前标记当前位置用于回溯。 期中考试 Update：\n考了回溯，不过不能像原来那样直接预读Exp了，或者说公共部分不是已有的非终结符。\n不过没关系，你只需要自己创建这样一个非终结符就好了，这个非终结符的parse也只需要复制公共部分的相关内容就好。\n我们只需\n记录位置，关闭报错 parse完这个公共部分 通过peek找差异，判定好类型 回到原位，开启报错 按照你识别的类型addNode即可。 递归 对于Exp的那一堆，经过一系列拆解，会发现真正的递归其实只出现在UnaryExp中。 不过这里是右递归，所以我们可以大胆递归。\n右递归本来就是安全的，不安全的是在重重循环中从未consume的左递归。\n左递归结构还原 针对Exp出现的大量左递归，我们一般的处理方法就是直接消除左递归， 把LOrExp → LAndExp | LOrExp '||' LAndExp 改成LOrExp → LAndExp {'||' LAndExp}\n这用来解析当然是没问题的，但是这其实已经修改了文法， 导致语法树的结构发生了变化，输出的结果就会不一样。\n因此，我们需要对语法树进行还原，使其恢复原来的结构。 我们知道除了最后一个LAndExp是真的LAndExp，其余的其实都是LOrExp-\u0026gt;LAndExp。 所以我们要new一个新的LOrExp，把LAndExp放进去，然后再装进components里面。\n语义分析 说到语义分析，主要内容就是符号表管理与错误处理两大部分。 其中关于符号表的内容，仅从通过测试来考虑的话，只需要考虑decl语句即可。 错误处理部分相对就更加复杂，同时也需要利用符号表的相关信息。\n符号表管理 这个部分最难的地方应该在于结构的组织，我参考了往届优秀代码， 构建了Symbol相关的多个类，类型上大体分为变量与函数， 功能上还有全局管理的SymbolRecorder 以及每个Scope的SymbolTable。\nSymbol本身的属性在这个阶段相对简单， 我们主要关注名称，类型和初始值。\nSymbolRecorder需要着重管理的就是符号表的组织与切换， 并实现addSymbol方法。当然addSymbol还是要落实到 SymbolTable的addSymbol方法上。\nSymbolTable的作用就是管理符号的声明与查找， 主要的方法是addSymbol和getSymbol，其中 关于addSymbol的调用，就在VarDef与FuncDef中； 关于getSymbol的书写，需要注意scope规则。\n错误处理 break与continue 这一点我借鉴了学长的代码，在parse的过程中 完成了break与continue的处理。它相比于重新 visit一遍更加简单，因为parse过程中结构已知。\nredefine与undefined 这两个的区别在于，一个只能看当前scope，一个必须看完 所有嵌套scope。当前scope就直接看当前的符号表就可以， 嵌套的scope其实就是getSymbol的过程。\n函数调用 函数调用的错误处理主要是参数的数量与类型。 数量还比较好解决，类型的判断，尤其是实参就复杂的多。\n实参是Exp，要判断Exp是不是数组，就要求他必须是 单一的AddExp,单一的MulExp,单一的UnaryExp, 单一的PrimaryExp,单一的LVal，并且这个LVal 的symbol类型必须是数组。\n当然这么简单的判断条件是基于课程组的文法简化\nreturn 这里涉及到两种错误，int函数最后一句不是return，以及 void函数存在return Exp\nint函数要想完备地判断是否能return还是比较复杂的， 所以题目加以限制，必须是最后一句，其实也就是 Block的BlockItem的最后一项。\n关于void函数的return，要详细地寻找到每一个return， 就不仅要寻找当前的Block的BlockItem中的ReturnStmt, 还要考虑其他Stmt。\n容易想到的是BlockStmt，容易被忽略的则是IfStmt与ForStmt。 他们两个也会嵌套Stmt，也需要进行寻找。\n中间代码生成 过了很久，我终于决定认真复盘这个最为复杂的单元。\n中间代码生成仍然属于前端的内容，他和语义分析一样， 都是与源语言文法、语义紧密相关的内容。\n二次扫描语法树——简介 我们中间代码生成的过程，就是要根据语法树的信息进一步提炼出抽象的中间代码逻辑。\n大家在做语义分析的时候也会注意到，符号表蕴含的信息只是一次小范围的总结， 并没有对控制流逻辑有所分析，所以我们AST的信息并没有提取足够，需要二次扫描， 在扫描的过程中顺势输出有结构的中间代码。\n不过要想知道怎么输出中间代码，我们必须先要深入了解LLVM IR。\n我们生成的LLVM IR必须是有一定结构的，我们将利用这个结构去递归完成toMips()的内容。\nLLVM-IR体系构建 这个结构的顶端就是 IrModule 。\nIrModule 包括以下四个部分：\nfunctions：每个 FuncDef（包括Main）映射成 IrFunction，内部是 IrBasicBlock。 globalValues：遇到全局/静态变量时要映射成 IrGlobalValue。 stringConstantMap：printf 拆出来的字符串常量以 IrConstantString 形式缓存。 declares：IO 内建函数声明（getint/putint/\u0026hellip;）也要预置在LLVM IR中。 输出 IR 时，IrModule.toString() 先打印声明、常量、全局变量，再打印所有函数体。\nvalue IrValue 是LLVM IR中最基础的概念，包括常量、变量、函数、乃至指令、基本块，都属于IrValue。 指令就是可以利用其他IrValue值的IrValue，他自己的值也可以被其他指令使用。 也就是说 IrValue 是一个统一接口，提供 getIrName()、getIrType()、toString()、toMips() 等通用行为。\nuse 在未来的优化部分，我们希望自己可以知道 IrValue 之间的关系，而不是只有代码的简单翻译， 因此我们要引入 IrUse 与 IrUser，强调 IrValue 之间的依赖关系。\n具体怎么构建use关系，还需阅读下文的Instr部分。\n每个 IrValue 都能用Value + Type + Use这套语言描述。\ntype IrType 是所有type的抽象基类，每个 IrValue 都要携带一个 IrType。\n核心的静态方法 convertType(originValue, targetType)：\n转 i32，若源已是 i32 就直接返回，否则生成一条 ExtendInstr。 转 i8：i32 -\u0026gt; TruncInstr，i8 保持不变，i1 -\u0026gt; ExtendInstr。 转 i1：本质上是转布尔数，此处不是截断，而是icmp，与0比较。 如果目标是数组，则递归转换其元素类型，保证数组初始化时的元素类型一致。 IrBaseType：内置的标量类型常量（VOID, INT1, INT8, INT32），toString() 对应 LLVM 文本 void/i1/i8/i32。\nIrPointerType：包装任意目标类型，toString() 追加 *。\n对数组/全局变量来说，我们用 IrPointerType 描述地址，这也是 GepInstr、LoadInstr 根据 getTargetType() 决定步长的依据。\nIrArrayType：记录数组长度和元素类型。 [N x i\u0026hellip;]。\nIrFunctionType：只强调返回类型（参数类型由 IrFunction 的 IrParameter 决定）。\nIrBasicBlockType：它没有信息量，就仅仅是BasicBlock，没有人需要getType来确认，toString() 为空字符串。\n但我们需要有一个 IrType，使得 IrBasicBlock 能继承 IrValue。\n具体的value IrFunction IrFunction 类型是 IrFunctionType，属于IrUser。\n包含 parameterList 保存 IrParameter，还包含 basicBlockList 是顺序化的 IrBasicBlock。\ntoString() ： define dso_local type @name(param...) { basicBlock IR }。每个 IrBasicBlock 的 toString() 被拼接成函数体。\nisMainFunction() 检查名字是否为 @main，决定这个IrFunction是整个程序的入口。\nIrParameter 类型取决于源代码。\n独立出来的作用就是因为其toString是函数参数调用这一特殊形式。\ntoString() ： irType + \u0026quot; \u0026quot; + irName\n它也只是一个普通的变量，在自已的作用域里被use。\nIrBasicBlock IrBasicBlock 类型是 IrBasicBlockType.BASIC_BLOCK。\n核心数据：instrList，块就是指令的合集。\ntoString() 打印 b_x: + 指令的LLVM。\n基本块在代码优化意义重大，不过仅从代码生成角度考虑，他也只是一层无意义的包装。\nIrLoop 他其实并不是IrValue。准确来说，他只是一个栈的结构体单元。\n它用来记录四个基本块：条件 condBlock、循环体 bodyBlock、步进 stepBlock、退出 followBlock。\n在面临多重循环时，栈式的结构可以帮助你更好地确定当前循环的各项信息。\nIrConstant IrConstant 是编译时常量，包括以下三种：\nIrConstantInt：最常见的标量常量，类型固定 i32。irName 就是数字文本。toString() 输出 i32 数字文本。\nIrConstantArray：用于全局/常量数组初值。内部保存元素的类型，元素常量列表 valueList 与 arraySize。toString() 生成 [N x type] [elem0, elem1, \u0026hellip;] 或 zeroinitializer；若初始化列表不足，会自动补0。\nIrConstantString：封装字符串字面量。类型是 i8* 指向 [len x i8] 数组（len 包含 \\0），存储时会把 \\n 转义为 \\0A。toString() 生成 @s = constant [len x i8] c\u0026quot;\u0026hellip;\\00\u0026quot;。\nInstr 最后一类 IrValue 就是我们最关键的 IrUser: Instr！\n每条指令既是可被引用的IrValue，又可引用其他值。\n分类：\n算术/逻辑：AluInstr（加减乘除/模）、CompareInstr、ExtendInstr/TruncInstr（类型转换）。它们通常产生新 SSA 值，toString() 形如 %v1 = add i32 %v0, 1。 内存与地址：AllocateInstr（栈分配）、LoadInstr、StoreInstr、GepInstr（数组/指针偏移），MoveInstr 用于优化阶段的平行拷贝。 控制流：JumpInstr（无条件跳转）、BranchInstr（条件跳转）、ReturnInstr。它们通常不定义新值，但会更新基本块的前驱/后继关系。 调用：CallInstr 负责函数调用，收集参数列表并决定返回值类型。 IO：instr/io 目录下的 PrintIntInstr、PrintCharInstr、PrintStrInstr、GetIntInstr，属于自动生成的declare。 指令 LLVM IR AllocateInstr %vx = alloca \u0026lt;element_type\u0026gt;（数组为 [N x i32]） AluInstr %vx = add/sub/mul/\u0026hellip; i32 lhs, rhs，操作符小写，始终声明 i32 操作数 BranchInstr br i1 cond, label %true, label %false，cond 必须是 i1，块标签用 % CallInstr call type @f(args…)，每个参数写成 type name，若函数有返回值则前缀 %vx = CompareInstr %vx = icmp eq/ne/sgt/\u0026hellip; i32 lhs, rhs ExtendInstr %vx = zext type name to type GepInstr 区分数组和普通指针：数组时打印 getelementptr inbounds [N x target_type], ptr_type ptr, i32 0, offset_type offset，否则为 getelementptr inbounds target_type, ptr_type ptr, offset_type offset. 原因在于gep是计算基地址+索引*类型大小，支持多级索引，而数组第一级索引是0，第二级索引才是数组内偏移 JumpInstr br label %target LoadInstr %vx = load target_type, ptr_type addr ReturnInstr ret void 或 ret type value StoreInstr store type value, ptr_type addr TruncInstr %vx = trunc type name to type，用于 i32→i1/i8 等截断。 GetIntInstr等IO类 %vx = call i32 @getint() 特别注意：\n为了避免大量的重复内容，我们将addInstr与addUse这两个操作直接放置于构造函数内。\n指令本身不复杂，复杂的是下一部分，也就是怎么生成LLVM IR。\n二次遍历语法树——实操 架构构建者：IrBuilder IrBuilder 是生成中间代码的核心部件之一，它持有全局单例 IrModule，并通过静态字段跟踪当前 IrFunction、IrBasicBlock，以及循环栈 loopStack，让 Visitor 在任何时刻都能把新指令、新块挂到正确的位置。\n模块管理： IrBuilder需要负责组织各模块之间的关系，包括创建Function,Block,Instr,Global_Var以及addBlock,addInstr等操作。\n命名服务：newFuncName, newBasicBlockName, newGlobalVarName, newLocalVarName 统一生成 @f_name, b_#, @g_#, %v# 等符号。对局部命名，Builder 以函数为粒度维护计数器，保证每个函数的 %v0, %v1, \u0026hellip; 独立递增。\n架构填充者：Visitor 我们终于谈到了中间代码生成的核心，也就是真正二次遍历语法树的过程。\nVisitor.generateIr 是中端的入口，持有完整 CompUnit，依次对全局 Decl、普通 FuncDef、MainFuncDef 调用专门的 Visitor。\nDecl VisitorDecl：处理所有的decl语句，区分好全局、局部static与局部，以及数组与标量。\n我们只依赖 VarSymbol 中的语义信息（作用域、类型、是否数组、初值列表等）就足以完成翻译。\ngenerateDeclIr(Decl) 先区分常量/变量，逐个 ConstDef/VarDef 处理。\n全局/局部静态变量： 无论是否const，VarSymbol.isGlobal() 或 isStatic() 时使用 IrBuilder.getNewIrGlobalValue(new IrPointerType(type), initConstant)。初始化的值通过symbol构造 IrConstantInt 或 IrConstantArray，数组要自动补零。生成的 IrGlobalValue 存回 symbol.setIrValue，后续访值都指向这个全局指针。\n局部变量： 统一先 new AllocateInstr(type) 在栈上开空间，再视情况写初值。\n非数组：若提供初值（ConstDef 一定有，VarDef 可能有），就 new StoreInstr(value, alloc)；常量的初值来自符号表中提前计算好的 initValueList。 数组：遍历初值表达式列表，对每个元素 VisitorExp.generateExpIr → convertType → GepInstr → StoreInstr，未提供的尾部元素由 ConstDef 分支提前填 0。 常量的局部分支和变量一样，区别在于 VarSymbol 里 initValueList 已经静态求值完毕，而变量不能保证第一遍扫描的时候就已求值，而是用 VisitorExp.generateExpIr 来生成现场计算的表达式。\nFuncDef Def 在遇到函数节点时利用 IrBuilder 创建 IrFunction，把形参列表映射成 IrParameter，再借助局部 Alloc+Store 把参数写入栈。随后 VisitorBlock。\n需要注意作用域的改变时机：在解析形参时进入子作用域，Block生成完毕后退出子作用域。\nBlock VisitorBlock 遍历 BlockItem。遇到 Decl 转交 VisitorDecl，遇到 Stmt 转交 VisitorStmt。\nStmt VisitorStmt 以语句类型为分发点：IF/FOR 创建新的基本块并通过 IrBuilder 管理跳转；ASSIGN 找到左值地址（调用 VisitorLVal）并生成 StoreInstr；PRINTF 先把字符串拆成常量块和占位符，再插入对应的 IO 指令；RETURN 根据函数返回类型自动补 0。循环语句通过 IrLoop 堆栈记录 break/continue 的目标块。\nVisitorStmt 根据 StmtType 分别处理不同类型的语句。\nLVal：\n后面会用到，这里先讲清楚： VisitorLVal.generateLValIr(lval, false) 给左值对象的值，\nVisitorLVal.generateLValIr(lval, true) 给左值对象的地址。\n具体而言：\n返回地址时：\n非数组变量直接返回符号表记录的 IrValue（通常是 AllocateInstr / IrGlobalValue），即地址。 针对数组或指针：先取符号的 IrValue。如果这是一个指向数组的指针(作为 IrPointerType，其 target 还是指针)，说明它需要先 LoadInstr 读出真实首地址；然后根据下标生成 GepInstr(pointer, index)，当然要先生成算出index的IR。 直接取值时：\n若符号是标量，直接 new LoadInstr(symbol.getIrValue()) 取内存中的内容。 数组情况更复杂： 首先特别注意：若 pointerType.getTargetType() 仍是 IrPointerType，说明 symbol.getIrValue() 存的是指向指针的地址，必须先 LoadInstr 取到真正数组指针。 拿到数组指针之后就继续找值：\n如果没有下标（size == null），意味着把整个数组当作指针使用，返回 new GepInstr(pointer, new IrConstantInt(0))，相当于数组首地址。 如果有下标，就先算index，然后 GepInstr(pointer, index) 计算元素地址，再 LoadInstr 读取元素值。 block：\n进入子作用域，VisitBlock，离开子作用域。\nexp与assign：\ngenerateExpStmtIr 纯调用 VisitorExp.generateExpIr，如果没有表达式就直接返回； generateAssignStmtIr 先用 VisitorLVal.generateLValIr(lval, true) 拿到地址，再把翻译右侧表达式，并转成目标类型，最终 new StoreInstr(value, address)。\nprintf：\n手动解析格式串：遇到 %d/%c 时调用 VisitorExp 获取实参，转换类型后 PrintIntInstr/PrintCharInstr; 普通字符串则直接用 IrBuilder.getNewIrConstantString + PrintStrInstr。\nif:\n先建 ifBlock（真分支），若有 else 再建 elseBlock.\nVisitorExp.generateCondIr(cond, ifBlock, elseBlock/followBlock) 生成条件跳转。\n特别注意！ cond和exp的不同点在于cond的解析为了处理短路求值，是自带跳转功能的！\n因此我们看似只是生成条件的IR，其实已经把根据条件进行跳转的指令也涵盖了。\n接下来就分别生成if与else本身 stmt 的代码，注意结尾都要跳转到 follow 块！\nfor:\n建四个块：cond, body, step, follow，并把它们打包成 IrLoop 压入 IrBuilder.loopStack。 多重循环一定要成套记录。\n入栈 IrLoop: IrBuilder.LoopStackPush(new IrLoop(condBlock, bodyBlock, stepBlock, followBlock));\n首先是起点：处理 init 这个 ForStmt，并跳到 condBlock。\n进入条件块：直接生成cond的IR（自带跳转）\n需要注意 cond块的跳转指令是cond生成的，而不是人为添加的！如果不存在cond，该块将无跳转语句造成OCE。因此最后需要一轮check或者在这里强制手动多添加一个无条件jump。\n进入body块：直接翻译 body 这个 Stmt ，然后跳到 stepBlock。\n进入stepBlock：处理 step 这个 ForStmt，并跳到 condBlock。\n出栈 IrLoop。\n进入 followBlock。\n关于 ForStmt： 其实就是多个 assign 语句。\nbreak / continue:\n直接查看当前所在的循环体 IrBuilder.LoopStackPeek()，break 跳到 followBlock，continue 跳到 stepBlock。\nreturn：\ngenerateReturnStmtIr 若语句带表达式则生成该表达式，否则对 int 函数默认补 0。返回值统一转到函数返回类型，然后 new ReturnInstr(value or null)。\nExp Exp 就是一个 AddExp。\n结点提供子表达式与连接符号，我们按子表达式列表迭代，逐个拼接 AluInstr。\n要注意在每次二元运算前，都把操作数提升到 i32，保证算术统一在 32 位整型上进行。\n新的 AluInstr 既作为指令插入，也作为下一轮的左操作数。这样实现了 AST → SSA 的顺序化运算。\n一直迭代到的最底层：一元表达式，分为三种。\nPrimary（括号、数字、左值）：括号就调用 generateExpIr，数字就构造 IrConstantInt，左值调用 VisitorLVal.generateLValIr(lval, false) 获取值。\nIdent 函数调用：getint（直接返回 GetIntInstr），其他函数从 SymbolRecorder 取 FuncSymbol，把实参列表递归成 IrValue，最后 new CallInstr(irFunction, paramList)。\n一元运算符：+ 返回原值；- 构造 0 - value 的 AluInstr；! 则先转 i32，再生成 CompareInstr(\u0026quot;==\u0026quot;, 0, value)，最后 ExtendInstr 把布尔结果扩展成 i32。\n布尔/条件表达式：\n左值加载：PrimaryExp 中的 LVal 调用 VisitorLVal.generateLValIr(lval, false)，这会根据是否数组、是否指针返回 LoadInstr 或 GEP+Load 的组合。所以 VisitorExp 不直接关心符号表，只处理表达式结构。\nCond generateCondIr 是 if、for 条件代码的入口。它把 Cond 降成 LOrExp，以 trueBlock 和 falseBlock 为目标生成短路控制流。\ngenerateLOrExpIr 为下一个 || 子表达式创建一个中间块，在每个块里调用 generateLAndExpIr，得到的值通过 BranchInstr 控制跳转；若当前子表达式为真，立刻跳trueBlock；否则落到下一个 LAnd 块，实现短路。\ngenerateLAndExpIr 类似，不过 \u0026amp;\u0026amp; 的短路条件是中途为假就跳 falseBlock。\n最后一个子表达式产生的 BranchInstr 直接指向 trueBlock/falseBlock。\nEqExp、RelExp 链式构建 CompareInstr，因为 a == b == c 这种语法递归展开后需要把前一次比较的结果转换为 i32 再与下一项比较。generateEqExpIr 保证自己是i1，因此还要把链式结果与 0 再比较一次，统一转换成 i1。\n构建的画笔：toString() 首先是IrModule本身的toString(),作为顶层架构，输出 IR 时，IrModule.toString() 先打印声明、常量、全局变量，再打印所有函数体。\n函数体的toString()：\ndefine dso_local type() irName(IrParameter.toString()) {IrBasicBlock.toString()\\n}\n参数的toString：类型+名字\n基本块的toString：irName(也就是IrBuilder给他生成的那个b_#): Instr.toString()\nInstr.toString: 我们在介绍Instr的时候已经说过了。\n目标代码生成 最后一关，把llvm转变为mips！这一段内容很考验计算机底层逻辑的一些内容， 毕竟我们已经从高级语言迈向了汇编语言。\n同样都是从某种语言转向某种语言，为什么高级语言到中间代码这么复杂， 但是中间代码到目标代码只需要简单一步呢？\n因为我们在遇到高级语言时，接受的只是字符串，我们要先把它的架构建造起来，才能完成语义翻译。 而中间代码被生成时，其结构是先被搭建出来的，反倒代码本身才是toString的附属品。\n在熟悉了LLVM的Module-Function-Block-Instr结构之后，如何转为mips并不是一件特别难的事。\nMIPS体系构建 像生成中间代码一样，我们首先要把MIPS的架构建造起来。\n类似地，这个结构的顶端是MipsModule.\nMipsModule被简单地分为两个部分，分别是.data和.text，这些我们已经很熟悉了。\n.data .data包含 .asciiz .space .word 分别用来定义字符串，数组空间和具体的值。\n使用方法大家可能也直接就想到了：\nIrConstantString 对应一条 .asciiz、 IrConstantInt 对应一条 .word、 IrConstantArray 初始化为0可直接对应一条 .space， 有其他初始值则对应 .word + 一堆数。\nRegister 寄存器当然是mips最最不能缺少的概念了，也是后端优化的核心难点所在。 不过在基础架构这一环节，我们只需要把寄存器的定义列出来就好。\nRegister.java 是一个枚举类，用于定义MIPS架构中的寄存器，在此我们需要强调哪些寄存器是不能动的。\n类型 名称 用途说明 零寄存器（专用） $zero 恒为0，不可修改，常用于需要常数0的场景（如清空寄存器）。 返回值寄存器（专用） $v0, $v1 用于存储函数的返回值，以及决定syscall的功能。不过v1就相对自由。 参数寄存器（专用？） $a0-$a3 用于传递函数的前4个参数，超过4个的参数通过栈传递（优化时可以考虑只传一部分哦） 临时寄存器 $t0-$t7, $t8-$t9 临时使用的寄存器，函数调用时无需保存其值。 保存寄存器 $s0-$s7 用于保存需要跨函数调用维持的值，函数调用时需保存和恢复其值。 内核寄存器（专用） $k0, $k1 内核专用寄存器，用户程序一般不使用。不过我们这里因为不涉及，所以反倒十分自由地使用了他们。 全局指针（可专用） $gp 全局指针，用于访问全局变量，也就是 la $gp, g_1 然后lw 栈指针（专用） $sp 指向当前栈顶。其重要性无需多言。 帧指针（可专用） $fp 指向当前函数栈帧的底部。我在本设计中没有使用。 返回地址 （专用） $ra 保存函数调用后的返回地址，jal指令强制使用该寄存器，所以不能乱用 我们有方法：getUsableRegisters()，返回程序中可自由使用的寄存器列表，包括：\n临时寄存器：T0-T9 保存寄存器：S0-S7\n其他的，比如V1以及只有特定时候才有用的A0-A3，我们暂且不放进去。 .text 接下来才是重头戏，也就是MIPS指令集。\ntext 文件夹中包含的 MIPS 文本段（代码段）相关类及其对应指令类型如下：\nMipsAlu：R: add,sub,addu,subu,and,or,nor,xor,slt,sltu I: addi,addiu,andi,ori,xori,slti,sltiu shiftv: sllv,srav,srlv shift: sll,sra,srl MipsCompare：slt、seq、sne、sle、sgt、sge、slti MipsBranch：beq、bne、bgtz、blez、bgez、bltz MipsJump：j、jal、jr MipsLoad：lw、lh、lhu、lb、lbu MipsStore：sw、sh、sb MipsMD：mult、div、mfhi、mflo、mthi、mtlo MipsSyscall：syscall MipsLabel：用于定义代码中的标签 MipsAnnotation：用于添加注释（以 # 开头的说明文本） MarsLi（fake）：li（伪指令，加载立即数到寄存器） MarsLa（fake）：la（伪指令，加载标签地址到寄存器） MarsMove（fake）：move（伪指令，寄存器间数据移动）\n需要特别注意的是，由于我们按照大类来划分，因此add与addi的构造方法显然应该是不同的，需要支持多构造函数。\n不过听起来复杂，其实也只是把指令的构造方法与toString实现了而已。指令具体的作用呢？那就是计组做的事情了。\n从中间代码到MIPS backend就这么简单的结束了。那还缺什么呢？要怎么把LLVM转到MIPS呢？这其实就是对LLVM的语义分析了：也就是我们生成的llvm代码的含义是什么？究竟该如何用mips表达？\n这个问题看起来复杂，但是LLVM与MIPS的相似度很高，结构也都比较简单，所以其实并不太难。整体的逻辑是一致的，两个工具：Builder和toString。\nMipsBuilder MipsBuilder和IrBuilder类似，都是控制整体逻辑结构的重要管理者。\naddContent 方法，实现将具体内容放入MipsModule的data与text段中。\n寄存器分配管理\n维护 valueRegisterMap 映射表，记录 LLVM IR 中的 IrValue与 MIPS 寄存器的对应关系。 提供 allocateReg 方法记录 IrValue 分配的寄存器 getValueToRegister 方法查询IrValue 分配的寄存器 getAllocatedRegList 方法获取已分配的寄存器集合，用于寄存器资源的跟踪与管理。 栈空间分配管理\n通过 stackOffset 记录当前栈偏移量（初始为 0，分配时递减） 提供 allocateStackForValue 为 IrValue 分配 4 字节栈空间并记录偏移地址 getStackValueOffset 查询 irValue 所在的栈空间位置。 注意：setCurrentFunction切换函数时，也要切换寄存器映射表，重置栈偏移为0，确保不同函数的寄存器和栈空间独立管理。\n遍历 IrModule 首先是最顶层的IrModule：\ndeclares、stringConstantMap、globalValues、functions.\n如何书写它的toMips?\ndeclare是LLVM要知道的，但在MIPS中直接靠syscall实现，无需提前声明。stringConstantMap对应生成.data段的.asciiz，globalValues对应生成.data段的.word与.space。\nasciiz和word的名字怎么取？可直接用irName去掉@这个首字母。\n把这些全局的东西做完，就开始具体的函数程序流了。\n首先是进入main函数： jal main + j end\n然后是各函数的具体内容。\n最后是end: new MipsLabel(\u0026quot;end\u0026quot;)，并syscall 10结束程序。\nfunction new MipsLabel(\u0026quot;函数名\u0026quot;) MipsBuilder.setCurrentFunction(this); 函数形参分配寄存器，根据IrParameter的信息，前四个参数要占用寄存器（具体传值是callInstr的事），并且所有参数都在栈上分配4字节空间（同样，传值不归它管） 遍历IrBasicBlock basicBlock 最简单的一集：\nnew MipsLabel(\u0026quot;block名\u0026quot;) 遍历Instr Instr 听起来很简单。不就是把原来的指令变成现在的指令嘛，逻辑我当然懂。可是难点不止这一个，不仅是操作符的更新，更复杂的是操作数的变化。不再像以前一样，可以弄出来一大堆变量，现在只有32个寄存器和立即数（含label）可以用，你该如何保证一致性？\n这里就介绍几个必要的方法，他们定义在Instr这个父类中：\nloadValue(IrValue, Register) 把一个 LLVM 的 IrValue 装进某个寄存器。指令在需要寄存器时，我们需要这个操作来将IrValue进行转换。\nIrValue 是个常量 IrConstant，那就用li直接装进寄存器。 IrValue 是个全局变量 IrGlobalValue，那他的值就是地址，直接la就可以。（后续做了优化，统一使用gp，这样不变的时候就不用再la，变的时候再move） IrValue 是个普通的变量： 他已经在某寄存器上了，那就move过来。 他还在栈上，先MipsBuilder.getStackValueOffset(irValue)，然后lw。 getRegisterOrXXForValue 刚才提到要把值放进寄存器，那该放进哪个寄存器呢？现在就做寄存器分配的话还是太难了，所以我腾了两个寄存器出来专门在无可奈何的时候用：就是K0和K1。（bzh学长的思路） 如果做了寄存器分配，当然是可以知道现在它有什么寄存器的，但是没做的话，或者压根没分配，那我就要暂时占用K0了。\nsaveResult(IrValue, Register)\n有load当然就有store，不过我这里起名叫save。 什么叫save呢？因为这个值如果没有分配寄存器的话，算出来默认占用的是K0,别人还要用呢。所以如果你有寄存器，就把这个值move到寄存器，否则就要allocateStackForValue，降低offset记录IrValue，用sw把它存栈上了。总之得记录一下到底放在哪。\n好嘞，这三个方法讲完，IrValue和寄存器的转移相信你已经了解了。相对于操作数的问题，运算符的问题其实是容易解决的，只是相对繁琐。\n接下来就是每个LLVM Instr的翻译过程了。\nIOInstr getint -\u0026gt; new MarsLi(Register.V0, 5); new MipsSyscall(); saveResult(this, Register.V0);\nprintchar/int -\u0026gt; loadValue(printValue, Register.A0); new MarsLi(Register.V0, 11/1); new MipsSyscall();\nprintstr -\u0026gt; new MarsLa(Register.A0, irConstantString.getMipsLabel()); （也可以用loadValue） new MarsLi(Register.V0, 4); new MipsSyscall();\nAllocateInstr 在初级阶段，我们的数都是存在栈上，霸占寄存器这种事还没有算好。因此这里就直接MipsBuilder.allocateStackSpace。具体的大小还要看一下IrValue的类型，如果是数组还要乘上size。\n有关栈的操作，我们一定要注意实时更新sp寄存器！这里就需要用ADDU，把sp减去我们分配的大小。\nCallInstr与ReturnInstr 这算是最难的一个部分了。前面我们提到IrFunction要登记a0-a3寄存器，但是具体传值是callInstr进行的。不仅如此，callInstr的整体流程为：保护现场-\u0026gt;传参-\u0026gt;jal-\u0026gt;恢复现场-\u0026gt;处理返回值。\nsaveCurrent 保存所有的寄存器，包括当前的ra，然后栈指针向下移动 fillParam 前四个直接将值load进对应的寄存器，之后的就先随便load个寄存器，然后sw进栈。 jal function_label 恢复现场 栈指针向上移动，把值lw回寄存器 处理返回值 函数的IrValue直接save进V0寄存器。 关于return就相对简单，因为事情都给callInstr做了。 return要提供返回值的内容到某寄存器（load），以及jr $ra\nBranchInstr 首先把cond放进寄存器，然后直接用bne跳转真，否则无条件跳转假\n1 2 3 4 Register condRegister = getRegisterOrK0ForValue(cond); loadValue(cond, condRegister); new MipsBranch(MipsBranch.BranchType.BNE, condRegister, Register.ZERO, getTrueBlock().getMipsLabel()); new MipsJump(MipsJump.JumpType.J, getFalseBlock().getMipsLabel()); GepInstr 这个指令可谓是LLVM时很特殊的指令了，现在转为MIPS其意义也很明显：目标地址 = 基地址 + 偏移量 × 4。\n所以就只是load一下，先左移，再add，最后save。\nLoad/StoreInstr 出于简单考虑，我们统一使用new MipsLoad(MipsLoad.LoadType.LW, targetRegister, pointerRegister, 0); 默认设置偏移为0，值和址都放入寄存器。\nMoveInstr 此move非彼move，不过也只是操作数不同。\nExtendInstr 这个指令在MIPS没有意义，因为没有type的区分。所以只需要进行一个赋值，和MoveInstr一样，把原来的ir的值赋给新的ir即可。\nTruncInstr 这个就有意义了，如果要压缩到一位，就需要和1进行andi。\nCompareInstr load+比较+save，比较运算符更是都能一一对应。\nAluInstr 运算符也都能对上。处于简单考虑，我们都先放进寄存器，然后用不含立即数的指令进行运算。\n注意：对于乘除法，还要加一句MFLO，取余则为MFHI\n后端的内容说多也不多，但是一定需要谨慎思考再落笔，否则很容易出现恶劣bug。其次，我们肉眼可见有大量值得优化的内容需要完成。\n中间代码优化 代码优化分为体系结构无关的中间代码优化与体系结构相关的目标代码优化。\n在边遍历边生成的过程中，不可避免会有很多冗余与机械性的指令产生。中端优化不仅可以直接缩减中间代码的行数，还能让后续的某些后端优化更容易发生。\n关于中端优化，最核心的对象不在于某一条指令，而是宏观上的感知，要充分挖掘指令之间、Value之间、基本块之间的联系。基本块之间的联系简单来说就是流图 ，Value之间的联系则是我们一直在维护的Use关系。\n需要注意： 很多优化会改写控制流边（例如把 branch 改写成 jump、删除 block、插入中间块），所以流水线中会多次执行 CfgBuilder 来重建 CFG 与支配信息，并同步修 phi 的前驱列表。\n为什么我们需要CFG并实时更新CFG？\nCFG 直接提供的关键信息\n前驱/后继（Pred/Succ）：CFG帮我们统计好所有的前驱与后继。这个的用处太多了，修 phi incoming、跳转改写时都得用到。 结构信息：哪里是 if/else，哪里汇和，哪里是循环回边。宏观上的结构提取离不开对CFG的分析。 为什么优化会依赖 CFG\nMemToReg / SSA / phi 插入：phi 的语义就是来自不同前驱边的值在这里合并。phi 插入位置依赖支配关系/支配边界，没有 CFG 的前驱列表，连phi 应该有几个 incoming都不知道。 常量传播 / 活跃分析 等数据流分析：理论课知识，经典数据流方程都是依赖于流图的前驱/后继块信息。 循环优化：要判断某指令外提到循环前是否安全，需要先准确知道哪些块属于这个循环、循环入口从哪来。这些都需要来自 CFG 。 CFG 的构建 RemoveUnreachableCode 为什么先说这个呢？因为这个逻辑太简单了，而且这个优化能够在一定程度上帮助CFG的构建。\n单个基本块内：跳转指令之后的指令在语义上永远不会执行 因为跳转以基本块为单位，执行完跳转指令一定会到达某基本块的开头。\n整体来看，entry不能跳转到的块也都是不可达的。 实现起来也很简单，不过注意删东西的时候要把Use关系也尽量删干净。\n基本块内遇到 jump/branch/return，删除后续所有指令。 从入口块 DFS，只保留可达块，其余块从函数的 blockList 中移除。 CfgBuilder 扫描每个基本块末尾终结指令来重建 beforeBlocks/nextBlocks，再把块首 phi 的 predecessor 列表与当前 beforeBlocks 对齐，最后计算支配关系、立即支配与支配边界，为 InsertPhi、GVN、LICM 等提供基础信息。\n无效代码删除 JumpThreading 跳转穿线的出发点是因为在处理控制流时，IR 很容易生成跳板块，也就是块里只有一条无条件跳转，这类块本身不提供任何语义增量，却会把 CFG 拉长、制造额外边与额外分支，从而让后续优化更难看清结构。\n我在实现时只处理了非 entry 且仅含无条件跳转的块，把所有前驱直接改跳到 target\n为了避免破坏 phi 语义，如果 target 块开头存在 phi，我选择保守地不做穿线，因为那意味着需要补齐 incoming value 才能保持语义一致。\nRemoveDeadCode 在中间代码非常容易产生算出来但没人用的值，这些值如果留到后端，会产生大量的寄存器压力与访存压力，还会阻碍后续的常量传播与去重（因为它们占据了 use/def 的一部分）。它不仅能删指令，更重要的是把依赖图变稀疏，让后续每一步优化都更容易触发。\n我们先从main出发构建调用可达信息，并标记有副作用的函数（包含 IO、store，或调用了有副作用的函数），然后以关键use指令为根（return、branch/jump、store、IO、以及调用了副作用函数的 call），逆着 use 关系把依赖链标记为 active，删除所有非 active 指令。\n我还做了一些简单的结构性清理：\n删除无前驱且非 entry 的块并在后继块里移除对应的 phi incoming 合并满足前驱唯一且前驱只有这一个后继的块 把只有一个 incoming 的 phi 直接展开为普通值。 RemoveDeadFunctions 不可达函数删除在没有函数指针的语言里收益很直接：函数可达性完全由 call 决定，删掉 main 不可达函数既能减小输出规模，也能减少后续优化的工作量。\n直接从 main 出发沿 CallInstr -\u0026gt; targetFunction 做 DFS 标记 reachable，然后删除不可达函数即可。\nSSA MemToReg + InsertPhi 前端生成 IR 时局部标量往往落成 alloca + store/load，各种变量都放在内存里。如果不提升至SSA，后端会机械地产生大量 lw/sw，而这些访存其实只是为了模拟变量当前值。一旦把它提升到 SSA，就把内存问题变成了值问题，常量传播、去重与窥孔会变得非常自然。\n我在实现时只处理了非数组的 alloca，先扫描该 alloca 的 use 收集 define（store）与 use（load），再利用支配边界在需要的块开头插入 phi，最后沿支配树做 rename。\nrename: 我们用栈来维护当前最新值，把 load 替换为栈顶值除，把 store 变成入栈，栈为空时用 0 作为默认初值。\nMemForward 即便做了 MemToReg，局部数组/局部指针这类不使用SSA，而是确定地址的对象仍然可能出现 store→load、重复 store 或重复 load。\n我当前实现是块内优化。在单个基本块内维护 address -\u0026gt; MemState：\n遇到 store 就记录最新地址写入值。\n遇到 load\n若该地址的值已有缓存，则替换 load 的 user 并删除该 load。 否则把该 load 的值记为已知值，用来做 load-load 的消除。 DeadLocalAllocaStore 这个优化的动机来自一种很典型的冗余：局部数组或局部变量可能被写了很多次（尤其是初始化）但从未被读过，这些 store 对语义没有任何贡献。我们可以把只写不读的初始化彻底抹掉。\n我以 alloca 为根向下追踪由它派生的 gep 地址，收集相关 store；只要发现任意 load，我就放弃优化，否则就删除所有相关 store，并进一步清理因为 store 消失而变成无用的 gep/alloca。\n表达式 Inline Function 这个测试点对testfile6有奇效。我在此仅实现了很简单保守的函数内联，就已经为后续的优化提供了极大的便利。函数内联的意思是把一次函数调用直接改写为被调函数的函数体。这样不仅消除了 call 本身的大量开销，还能把原本跨函数边界的常量传播、公共子表达式删除和死代码删除等暴露给后续优化。\n本次仅对非常小且形态简单的函数进行内联：目标函数 callee 满足非 main、非自递归、仅包含一个基本块、最后一条指令为 ReturnInstr、指令条数不超过阈值，且函数体中不包含 call/IO/load/store/alloca/分支跳转/phi 等可能引入副作用或 CFG 复杂性的指令时才允许内联。\n具体实现层面，首先建立好形参与实参的映射。然后按原顺序遍历基本块中的每条纯计算指令（Alu/Compare/Extend/Trunc/Gep），在调用点所在的基本块中利用映射关系创建一条新指令插入到 call 之前。当所有指令克隆完毕后，将 return 的返回值同样通过映射到调用点语境下得到 returnValue，还要将返回值的所有user替换为内联后的值，最后删除原 call 指令并清理 use-def 边。\nGVN 这里参考了bzh学长的字符串哈希法，为表达式维护了一个hash标识。我们沿支配树遍历，用 getGvnHash() 为表达式做哈希并维护一个当前支配路径上的表达式表，当发现哈希已出现就用已有值替换当前指令并删除它。\nLVN LVN 比 GVN 更适合边走边化简：在遍历过程中顺手做常量折叠、代数恒等化简，能把很多小冗余直接掐掉，不必等到后端再清。\n对 ALU/CMP/EXTEND/TRUNC 可以做常量折叠与简单代数化简，对 ALU/CMP/GEP 做基于哈希与MoveInstr的消除，也就是常量传播。其中针对MoveInstr，直接传播给user，然后删除 move。\nSparse Conditional Constant Propagation 稍微深入处理一点常量折叠：常量不仅来自字面量，还来自某些路径根本走不到：简单的说，就是提前预判某些分支是否必走，从而方便我们的传播。\n我对SSA值维护了三值格 UNDEFINED/CONSTANT/OVERDEFINED，并不断传播，phi指令触发值合并从而改变状态，最终把 CONSTANT 的SSA值替换成常量。\nPureFunctionEvaluation 这个点是testfile7直接提醒到的。在无副作用、返回值只由参数决定的前提下，call 可以被当成一种可优化的表达式：参数全为常量时可以直接算出结果。此外，同一支配区域内对同一参数重复调用也可以复用结果。\n首先是纯函数候选：非main、非void、有函数体、不出现 load/store/alloca/gep/io、不调用非纯函数。然后在遇到纯函数就解释执行目标函数（设置了较强的限制，防止算太久），得到结果并替换 call。我还沿支配树维护 (callee, args) 表，若已有支配的同 key 调用就复用结果。\n循环 LoopCanonicalization 循环规范化是为了便于LICM的执行的。因为 LICM 需要一个循环外唯一入口，也就是说被外提的指令需要一个确定且唯一的放置点。\n如果存在一条边 tail -\u0026gt; header，并且 header 支配 tail，那么 tail -\u0026gt; header 是回边，header 是循环头。然后从 tail 反向沿前驱回溯，把能回溯到 header 的那些块收集起来，得到循环块集合。\n我们观察header的前驱，有多少来自循环外，也就是外部入口有多少。若循环头存在多个来自循环外的前驱，我就插入新的 preheader统一外部入口，把所有外部入口重定向到 preheader，并修复 header 的 phi：把外部 incoming 先在 preheader 合并（必要时插入新的 phi），让 header 只从 preheader 接收一个外部 incoming。\nLICM LICM 的直觉是：循环里有些表达式每次迭代都一样，留在循环体内就是重复算，把它们挪到 preheader 只算一次，循环体就能更短更快。\n我只外提无副作用、无定义新值的指令（ALU/CMP/EXTEND/TRUNC/GEP），明确排除 load/store/call/IO/控制流/phi。更宽泛地，如果某指令的 operand 在循环内定义时，倘若能判定该 operand 也是 invariant的就也能外提。最终把可外提指令插入到 preheader 的终结指令之前。\n后端准备 ActiveAnalysis 活跃分析的原因是寄存器分配必须知道哪些值必须跨块保留，否则很容易把仍在后续使用的值提前释放掉；而跨块活跃由每个块的 in/out 集合决定。我们先计算每块的 def/use，再迭代求解 in/out（out 为后继 in 的并集，in 为 use 并上 out−def），并额外处理 phi 的沿边使用：把从当前块流向后继块那条边对应的 phi incoming value 纳入 out 集合，保证跨边的真实需求被计入。\nAllocateRegister 我做寄存器分配的目标是尽可能把 SSA 值放进物理寄存器，让后端少发 lw/sw，没有实现 spill。通过沿支配树递归分配，进入子块时临时释放不在子块 in 集合里的寄存器，处理完子块再恢复。\n在块内我记录每个 useValue 的 last-use，当某值在本条指令里是最后一次使用且该值不属于 block-out，就立即释放它占用的寄存器。\nRemovePhi 对每个基本块开头的 phi，先按从哪个前驱跳过来就取哪个 incoming 值的含义，把它拆成写在各条前驱边上的一组并行拷贝（同一条边上可能要同时给多个 phi 结果赋值，所以逻辑上必须并行）\n如果某条边前驱有多个后继且后继有多个前驱，就无法把拷贝安全地放在前驱块末尾或后继块开头，因此要先插入一个只服务这条边的中间块，把拷贝放到中间块里；接着把并行拷贝集合线性化成若干条顺序 MoveInstr。\n并行操作转为顺序操作可能出现矛盾，比如环状赋值。这个时候就需要引入临时变量先把右值存下来，再move肯定不会错。\n目标代码优化 后端优化我分为两各方面：一部分发生在 IR 的 toMips() 过程中，本质是指令翻译时就直接简化，是指令单位本身的优化，在不改变语义的前提下直接选择更省的 MIPS 序列。第二部分就是相对宏观的指令间优化，不过实际上还是非常局部、非常确定的窥孔。\n翻译期优化 立即数优先 对于ADD/SUB/AND/OR ，如果有一项是常数，我会在立即数满足范围时优先选用 addiu/andi/ori，可以少加载一次寄存器。如果这个常数是0/1还可以做特判。\n乘除模优化 乘法优化：对 0/1/-1、2^k、小常数（如 3/5/7/9/15）分别用 move/neg/shift/shift+add-sub 分解来避免 mult，此外如果执行了mult还会对 HI/LO 复用缓存。\n除法优化：对 1/-1 特判，对 ±2^k 走算术右移 + 符号修正的无 DIV 路径，对其它常数走 magic-number division（mult/mfhi + shift + 符号修正）尽量避免真实 div，对非常数才使用 div + mflo\n取余优化：对 ±1 直接为 0，对 ±2^k 用移位/掩码实现符合向 0 取整的余数语义，对其它常数直接用真实 div 并取 mfhi 。\nMipsOptimiser（peephole） MipsOptimiser 我也单独写成了一个类，其实做的都是窥孔。我把它写成了多条规则迭代到稳定的形式：每一轮按固定顺序尝试所有规则，只要本轮有改动就继续下一轮，直到整个 textSegment 不再变化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public void optimize() { boolean changed; do { changed = false; changed |= forwardStoreLoads(); changed |= removeDuplicateStores(); changed |= dropTrivialMoves(); changed |= simplifyZeroAlu(); changed |= removeJumpToNextLabel(); changed |= removeDuplicateLoads(); changed |= removeLoadStoreBack(); } while (changed); } forwardStoreLoads 刚 store 完马上又从同一地址 load等价于直接复用被 store 的那个寄存器值。它的价值是把一次访存变成一次 move，甚至在后续再被 move 消除。我们在遇到一条 sw/sh/sb 之后向后扫描，若遇到对同一地址且类型匹配的 lw/lh/lb...，就把该 load 替换成 move。扫描会在危险的地方直接停止（label、jump、branch、syscall 以及大多数乘除相关指令）。如果扫描过程中同址再次 store，要更新可转发的最新值寄存器。\nremoveDuplicateStores 我做连续 store 合并的原因是刚才的操作虽然消除了load，但没消除store。所以又判断了一下相邻 store 是否写同一地址，若相同就删除前一条。\nremoveDuplicateLoads 相邻两次从同一地址、同一类型的 load 在中间没有可能改写该地址的情况下，第二次 load 的值与第一次完全一致。若目标寄存器也相同就删除后一条，否则把后一条替换为 move dstB, dstA。\nremoveLoadStoreBack 针对lw r, addr; sw r, addr ， store 写回的就是刚读到的值，内存内容不变，属于纯浪费。\ndropTrivialMoves move r, r 直接删除。这个其实可以在翻译时实现的。\nsimplifyZeroAlu addi/sll/srl/sra 带 0 立即数，留着只会浪费一条指令。不过这个翻译时也有所实现。\nremoveJumpToNextLabel 这种跳转对控制流没有任何实际作用。检查 j L 的下一条有效指令（忽略 annotation）是否正好是标签 L:，若是就删除该跳转。\n小结 请总结本学期编译技术课程学习的收获，并提出对课程改进的意见、建议。\n我的收获 ​\t如果要对整门编译技术课进行总结，在理论课上的收获可能感受起来更加真实。或者说本来形式语言与自动机的理论就比较有趣，在计组课上初步接触状态机后，还能在编译课上以文法为媒介学习更多细节的知识，体验还是很不错的。此外，课堂上还涉及到了有关运行栈的计算机底层知识，使其和COOS一脉相承。第三点就是理论与实验的联动比较强，这里主要指的就是LL分析以及中间代码优化的部分，课上的知识真的能为实验提供理论支持，这种体验感上次感受还是在一年前的CO理论讲冒险的时候。\n​\t在实验上，虽然每项作业也有ddl，但整体的节奏感没有COOS那么紧张，这也导致了我在做编译这件事上很难做到久久为功，而往往是以多次集中突击的形式完成。编译实验是一门从0开始完成的大型项目，尽管经历了OO的磨练，我依旧难以培养起来比较清晰的模块观念，许多文件的设计都大量借鉴了学长的示例，例如IrModule，IrBuilder这样的类的设计。抛开这些不谈，经过编译实验我当然收获颇丰。从语法分析开始便一次又一次超出我的认知，类的数量太多以至于必须创建module，提取特征写父类，写抽象类，写记录类……静态类也是我之前OO课上未曾使用，但编译实验中频频使用的典例。\n意见与建议 编译课程整体的体验感就是难。削减难度这样的事可能未必是改进，但还是希望同学们能够稍微更轻松地完成实验，比如理论课可以增设llvm的讲解，然后适当减少用属性翻译文法进行中间代码生成那一部分的课时。\n","date":"2025-12-07T17:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-compiler-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/cuidu_hu2441458864436015250.jpg","permalink":"https://demiurge-zby.github.io/p/buaa-compiler-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","title":"BUAA Compiler 实验报告"},{"content":"实验报告 题面 感兴趣的同学可以看看：\n1 https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-challenge-shell/challenge_shell.pdf 说在前面 本次shell挑战性任务整体来说难度还是很大的，需要实现的内容太多了。不过在今年的几个挑战性任务中可能还算是最容易拿到满分的，因为数据点评测比较简单，难度不高于样例。（虽然样例也称不上简单）\n由于本次作业我选择在17周（也就是考试周）完成，所以做的时候时间比较赶，总共用了周一周二两天时间很极限地完成了。具体时间安排可以看下图。\n我完成的顺序是：\ntouch,mkdir,rm指令 完成O_APPEND（没必要这么早） 重写sh.c，完成AST架构构建（顺便就实现了注释，;和.b省略） 实现工作路径以及cd，pwd 实现相对路径操作 实现环境变量的declare与unset 实现环境变量的值替换 完成各种按键的效果 完成history 完成反引号 完成条件执行所需的返回值传递 因为内容太多，我这里将一些比较为难我的地方，以及我比较个性化的地方作为重点来讲。\n内建指令与外部指令 首先要理解这两种指令的实现方式，以及区别。\n外部指令 外部指令通过先fork子进程，子进程再spawn孙进程来实现。\nspawn本身的功能是开一个新进程来执行二进制文件，因此外部指令的执行方式就是单独在/user目录下建立新的.c文件，并经过make形成.b文件，通过spawn执行ELF文件，结束。\n（一定注意修改的是user/new.mk，修改内容是USERAPPS += mkdir.b \\touch.b \\ rm.b）\n外部指令不应对shell的环境产生任何影响。\n内建指令 内建指令则涉及到改变shell的环境，因此必须在原shell下执行。\n那么他就不能fork新进程，因为新进程中的信息改动可能带不回父进程。（这个要看具体实现，但如果我的shell信息与进程强绑定就不可以fork）\n执行的过程就必须在sh.c内部完成了，对于某个command就直接进行strcmp判断，如果是某条内部指令就直接执行然后结束。\n区别 那么区别主要就在于fork。我们的原版sh.c是无脑先fork再runcmd的，我们的实现就只能runcmd，进去之后再看是否fork。\nAST架构实现 这个可能是最阻挡人的一环，这一关过了，后面就会有内驱力促使你做下去。\n因为这个实在有点庞大，本来对sh.c就一知半解，现在更是要全部推翻重来，哪些要改哪些不改要改成啥都不是很明确。\n基本流程 个人建议是先用大模型直接根据sh.c生成一版AST版本的，然后再进行一定量的修改。大模型在枚举类构建，结构体构建以及函数调用层次架构上都是比较清楚和直观的。\n一般的流程是，readline读取buf,然后runcmd(buf)。\nruncmd里面是parse_list和execute_list两个函数，这两个函数都是递归下降的方法执行的。\n具体parse的过程和OOU1很像，根据时机使用get_next_token(也就是consume),访问的时候可以直接通过全局变量cur_token。\n大模型的问题 不过大模型基本上刚开始都会犯一个问题：使用malloc等动态空间请求和一些安全的字符串函数（比如strdup），以及一些我们不支持的字符串函数。因此我们需要告诉它我们实现的是微内核，对安全要求没那么高，内存空间用静态数组分配，支持的字符串函数只有strlen,strcpy,strcmp和strchr。\n此外大模型也经常在consume的时候出现问题，你可以对于lexer和parser进行简单的内容重写，并积极添加debugf调试，实时查看token的读取，parser的内容是否有问题。\n检查与调试 上面所说的debugf大法当然很有帮助。不过注意避免不同位置输出相同格式的话，这可能会引发误解。\n这个工作你可以通过写好的mkdir等指令去调试。不过请注意你还没有实现相对路径，因此根据ls.c，当你执行ls命令时（无其他参数），就会默认执行ls /，而不是ls ./。不要因此误以为自己的实现有问题。\n工作路径 我设置了两个系统调用进行工作路径的set与get。\n这里注意，在fork的时候需要让子shell继承工作路径，因此需要在sys_exofork前get，然后子函数中set。\n当然也要注意子函数退出时要恢复工作路径为原shell。\n相对路径转绝对路径 这个就相对复杂，关键在于处理无数的.与..，其中..的处理还不是很简单。\n但是字符串相关的繁杂内容，就大胆交给大模型就好了！最终的结果也确实都是一次过。\n相对路径支持 只需要进行类似于以下内容的修改。\n因为你各种路径信息的最终使用者还是这些函数。类似的函数还有fsipc_remove等等。\n比如：把\n1 r = fsipc_open(path, mode, fd); 改为\n1 2 3 4 5 6 7 8 9 10 11 12 char result[128]; char middle[128]; strcpy(middle, path); if (path[0] != \u0026#39;/\u0026#39;) { char curpath[128]; syscall_get_cur_path(curpath); change_to_abs_path(curpath, middle, result); } else { strcpy(result, path); } r = fsipc_open(result, mode, fd); 环境变量设置 本来打算用链表存的，但是宏写起来还是没那么方便。\n因此开了几个全局静态数组，存储这些信息。并且强制按顺序进行环境变量的放置，被删除了也不再使用这个位置。\n为了解决环境变量这一关，我写了七个系统调用：\n1 2 3 4 5 6 7 SYS_get_env_var, SYS_set_env_var, SYS_unset_env_var, SYS_print_env_var, SYS_clear_my_env_var, SYS_get_shell_id, SYS_set_shell_id, get主要在下一步环境变量值替换里使用。\n这里主要讲讲shell_id和clear两个设计。\n环境变量最难的点就在于 子Shell对环境变量的修改不会影响父Shell\n但环境变量的值需要传递给子进程，还可能被修改，又要返现，如何处理？\nshell_id 首先是shell_id的设置。shell_id和子进程是两个概念，我在这个shell里面完成外部指令是需要开子进程的，但是这个子进程就完全可以使用我这个shell的非global环境变量。\n因此必须设置shell_id。\nget就不说了，set方法是对shell_id进行加一或减一。在shell启动界面加一，执行exit指令时就减一。这两个是个人认为非常合适的时机。\n子shell如何不影响原shell 关于clear，主要就是在exit指令的时候进行一次clear，直接把这个shell_id对应的环境变量全删了。\n那有人要问了，你对父shell的环境变量的改变怎么复原？我采用的是个性化的set与unset。\n当我只是使用而不改变值就无事发生。如果要改变值，就新开一个条件变量。在get匹配的时候优先shell_id也对应的即可。如果要unset，就也新开一个条件变量，但是把global属性设置为异常值2，get的时候优先匹配同shell_id，检测到是2就直接返回没有找到。那如果unset之后又set呢？我们在set的时候也优先查找同shell_id的，然后在赋值的时候自然就实现了global属性的正常化，还能保证不影响原shell的环境变量。\n大模型的使用 在解析的时候要处理 xxx=xxx 的结构，这种字符串任务还是交给大模型。\n环境变量值替换 这个的实现我放在了get_token之中。如果我读到$，就也把他当做WORD型token，但token的value就要经过get_env_var的解析。\n可是难点在于$key与其他字母是可以直接拼接的，\n就比如declare A=l的条件下，\t$As也要翻译为ls\n这种复杂任务也是选择交给了大模型。\n这里的实现是错误的，必须$紧跟的那一串有var_key才行。\n比如上面的例子，理应不能处理$decAare，而我的这种设计会处理为declare。不过这个问题交给大模型也容易修复。\n快捷键 这一块的内容我没有什么特别的地方要说，主要就是回显的抵消以及字符串相关函数，改动的内容是sh.c里的readline函数。\n之前确实也不知道printf一些字符居然可以实现光标的移动与显示的变化。\n快捷键怎么解析和操作，可以参考往年的博客。\n这里特别强调一些内容，在qemu中Ctrl+A会进入某种等待触发qemu快捷键(如 Ctrl+A+X)的特殊状态，这可能导致本地出现一些问题。\n此外，在VSCode中，Ctrl+E可能会触发VSCode的快捷键；在跳板机中，Ctrl+W可能触发网页的快捷键。解决方式是把代码中case的内容改为其他不常用的快捷键进行调试。调试成功再改回去即可。\nhistory 历史信息处理难度不小。\n基本流程是开启shell时加载/.mos_history，加载到本地数组。\t然后每readline完毕执行一条非空指令就写入.mos_history的末尾。\n难点在于切换指令。也就是本地数组与屏幕显示的处理。\n在你按上下键切换指令的时候，你需要将当前的内容存进你本地数组的对应位置。 你要存一整个字符串，不能因为空格而影响存储 切换后显示内容清空再加载，光标自动放在末尾 反引号 基本实现方式 实现方式是开启一个子shell，在子shell中完成指令并用输出的内容替换反引号及引住的内容。\n这个我也是在get_token中实现的，不过这个的优先级很高，只要读到反引号我就一直读一直等，直到等到反引号结束其属性为WORD，否则异常退出。\n那么读完反引号之后，我们要把内容取出来，开一个新shell，然后把内容传进shell让他去readline和runcmd，输出的内容还要传出来作为token的value。\n传递的方式是管道。\ndebugf与printf 其实当时很担心，怎么把输出的内容提取出来？每次控制台上的输出除了我们想要的之外，还有一堆env_kill的相关句子，难道要手动排除吗？\n实践发现只有printf的句子会被提取。\n那么就警示我们两点：\n标准的输出必须要使用printf而不能用debugf shell启动页面是printf！需要被特殊处理！ 其中关于第二点，我的方式是为shell启动提供-s参数，并设置如果有这个参数就不执行哪些启动页面的输出。\n条件执行 这个是我花费时间最长的一个点，最终也是耗到凌晨三点半才搞定。其实条件执行功能本身并不难，在AST里已经实现了，难点在于如何得到返回值。\n内建指令的返回值直接就返回，很直白。难点在于外部指令。\n外部指令先是套了一层fork，fork里面spawn又是一层fork，更何况spawn是通过执行ELF文件，我怎么获取ELF文件本身的返回值？\n经过研究发现，那些.b文件的返回值只能通过user/lib/libos.c中的main的返回值来体现。\n那么这么一个奇怪的位置的值又怎么传回那么遥远的原shell呢？\n我的答案还是管道。此外，我还强制了文件描述符2,3，便于解决困难的传参问题。其中libos.c只能写管道，并且强制通过fdnum=3的fd来实现。\n进程必须要趁它在kill之前发出信息，否则就再也找不到了。\n当然还有一种解法是修改libos.c的exit函数，让父进程掌管子进程的destroy，从而在子进程消失前拿到它的exit_value。这种一般要为进程添加属性exit_value，并添加set与get的系统调用。\n后记 实验报告很粗浅地写完了，OS的路程也终于画上了句号。在内核态打下的基础终于在用户态体现出如此强大的功能，个人还是很有成就感的。shell本身的可交互性与易懂性是吸引很多人选择它这个挑战的重要原因，实际上它也确实相较于swap更便于调试。但是难点就是内容实在是太多了，又不简单，两整天30个小时才侥幸拿下。我当前的实现也有一些我已知的错误，但是温柔的测试点并没有测出来。\n赞美OS。\n另外，祝今天高考查分的学弟学妹们取得优异成绩！\n","date":"2025-06-25T00:45:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-challenge-shell/123_hu5493953193122514291.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-challenge-shell/","title":"BUAA OS Challenge Shell"},{"content":"关于正向建模 正向建模是基于需求分析，创建一系列模型来表达系统的静态结构、动态行为和交互逻辑的过程。这些模型以可视化方式帮助我们理解系统设计，并为后续开发与实现提供指导。其核心是借助模型逐步细化的过程，从高层概念推进到低层实现，确保设计与需求一致。\n因此正向建模的核心并不在于画图，而需求分析才是正向建模的重要基础。\n需求分析 需求分析是将用户的需求转化为清晰、可验证的系统要求的活动。它涉及收集、分析、记录和验证需求，旨在理解系统的目标、功能、约束和性能要求。\n简单点来说，需求分析要从任务里读出：\n有哪些种类的对象？ 对象需要管理什么属性？ 需要实现什么功能？ 功能需要哪些对象进行协作？ \u0026hellip;\u0026hellip; 本次作业中，原则上只有书，人和图书馆。但是图书馆的功能太过复杂，我们根据单一职责原则，将图书馆拆成了一个管理类（Library）和四个功能类（主要负责取书的bs，主要负责预约的ao，主要负责归还的bro和主要负责阅读的rr）。\n图的设计 不同种类的图是回应需求分析结果的不同手段。\n类图：定义系统静态结构\n类图定义了最基础的原材料。它的核心功能就是将需求中的实体抽象为类，并通过关联、聚合、组合、继承等关系，描述实体之间的联系。通过这样的实现，系统的静态结构便一目了然。\n状态图：描述对象动态行为\n如果说类图是原料是基础，那状态图就应该是效果的呈现。无论属性如何影响方法，方法又如何影响属性，最终我们要实现的是功能。通过状态图描述系统中某个对象在不同状态之间的转换以及触发转换的事件，我们可以得知对象的动态行为具体可以产生什么影响。\n顺序图：描述对象交互时序\n顺序图在正向建模中帮助团队明确系统如何实现功能，它通过消息传递来描述类与类之间的协作，并解释了如何通过不同对象的协作来实现功能。\n关于架构 本次作业的架构设计其实花了我很大的功夫。在hw13的时候，我浏览学长的代码，但又不愿深入阅读过度模仿；我阅读学长的博客，也总觉得不能心领神会。最后无奈先写了一份需求分析出来，将散落在各处的要求集中起来，选定合适的数据结构与方法，才得到了类图的雏形。\n很遗憾没能早点接触状态图与顺序图，类图是类的构造蓝图，那这两张图可以说是具体方法实现的蓝图。\n具体架构的内容见下图。\n关于大模型 我本来是抵触使用大模型的。倒也不是因为追求所谓的“独立自主”，只是觉得让一个尚不靠谱的大模型帮我完成作业，心里面觉着没底，出了问题还要自己琢磨，去重新理解它可能并不合理的架构。但倘若是自己写的代码，无论如何，你理解每个属性每个方法的功用，你很熟悉你的静态设计。\n那么大模型辅助正向建模这件事，便深刻地影响了我。我只需要把指导书发给大模型，大模型就能直接给出它的实现思路。这个思路不同于代码，它易读易懂，我也可以随时进行指正或者改善，最后形成我对这个任务的处理方法设计。不仅如此，我借此将架构与实现相分离，实现了将程序分为数据结构与算法的过程。\n不过在如何使用大模型上，“直接把指导书扔给大模型”属于缺乏技术力的懒人行为。实验课上传授的ROSES与COT能够不错地规范自己的输入要求与大模型的思维方式。目前我也习惯开局来一句：假如你是xxx专家，让大模型定位好它要解决的问题领域。Steps与Example在具体使用中常常无暇书写，但如果真的需要大模型给出相对符合预期的答案，我们也可以借助这种描述方式来辅助实现。\n学期总结 当一个学期有了OO，它便已经被无情地切割为了16份。任务不断推进，我们终于走进hw16，这个学期也已然走向了尾声。本学期的面向对象课程通过风格迥异的四个单元，深刻阐述了如何认识类，如何设计类，如何书写类。\n架构设计 四个单元以来，我从只会写一个个简单的方法，逐渐有能力从任务中提取信息，从零开始建类，并实现最终的作业要求。犹记得OOhw1的时候，刚刚迈入新学期，迎接我的便是深不可测的汪洋。我当时尚且没有什么面向对象的思想，对类也没有认知，喊着“递归下降”就冲过去了，结果发现什么也写不出来。最终通过层次化的架构设计，借助lexer将读到的内容转化为token对象，并通过parser实现Expr到Term再到Factor的递归下降，将表达式拆成最小单位的组合。拆解后的表达式也同样借助递归下降计算化简结果。\nU2的架构设计则以生产者消费者模型为核心，大多数类都只是为了多线程的信息读取而实现。实际上具体的难点反而在于电梯类本身的策略，架构设计基本上与实验课的代码无异。U3可以说没有进行架构设计。U4作为引领同学们实现正向建模的一章，本身的架构设计却也意外的清晰。Library类管理书和人，图书馆的地点又分为四个类bs,ao,bro,rr。\n另外，不得不提到的是，实验课在代码架构方面对我的启发是极大的。当我面对一个新的问题和一个空的仓库，我能做的往往只是一个MainClass和一段空想。但是通过在实验课上阅读代码架构，填写空缺，我能够更快地理解作业的难点和重点究竟在哪里，然后花很长时间复刻架构，并叹息之前浪费的时间之多。我个人认为，写不出来任何东西的原因就是经验过于匮乏！对于解决一个问题没有基本的架构设计认知，每学会一个就只知道这样做“行”，但没有想过为什么这么做，如何想到这么做。因此OOU4的正向建模从需求分析出发，并以一个简单的例子入手，引领我从零开始，实现了完全自主的代码架构设计。\n测试思维 本学期另外一个大的个人突破，便是第一次尝试搭建了评测机。评测机是一个黑盒测试，根据狂轰滥炸式的输入来看代码能不能始终输出正确的结果。\n在OOU3前，我仍然认为数据量越大，次数越多就越容易找到问题。在学完之后，我虽然不能直白地否认这个说法，但我不得不佩服白箱测试的精准与强悍。JUnit与JML规格强强联合，为代码写出覆盖所有情况的寥寥几个测试，便能直接实现方法的完整评测。此外，以更小的单位进行测试也更容易定位问题所在。\n但影响我对测试认知的，不仅仅是OOU3。\nOOU1中，我的评测机借助sympy库，实现了表达式值的测试。然而难点在于格式错误问题————这个地方到底可不可以只有一层括号？这样的错误该如何检查？我发现测试的内容需要是足够全面的。 OOU2中，“抽奖修复bug”大法广为流传。线程间锁的抢夺已然使结果变化多端，随机分配策略更是让bug复现的概率锐减。测试要足够多，压力要足够大，测试才可能变得更有效。 OOU3中，我成为了测试的书写者。我发现我想不到，是什么样的代码能够做到，执行一次方法是正确的，连续执行两遍就会出错？是没有满足pure方法？还是说他的结果其实是随机数出来的，只是第一遍运气好？我意识到，测试要贯彻无情的态度。不思考对方怎么实现，我只关注后置条件与副作用范围。 OOU4中，我首次见识到交互式测试。我只会data.exe \u0026gt; stdin.txt，java -jar xxx.jar \u0026lt; stdin.txt \u0026gt; out.txt，python check.py，想不到如何实时根据out的内容去改变stdin。可惜第四单元事务繁多，又没有互测要求，尚没有了解评测机的具体实现方法。\n其他收获 要说还有什么其他收获，那不得不提到大模型了！我从未想过，会有这样一门课，支持我用大模型去完成本该由我完成的任务，还详尽地教导我如何更好地使用大模型。将大模型变为一个趁手高效的工具，而不是一个自说自话胡言乱语的对话框，这是大学期间需要培养的重要技能。\nOO带来的独特生活体验也是不得不品的一环。倒也没有天天熬夜debug，但是每个星期都在围着OO转还真是一点不假。\n最后感谢课程组的辛苦付出！祝愿OO课程不断进步！\n","date":"2025-06-09T21:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-oo-u4-uml%E6%AD%A3%E5%90%91%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/123_hu3121082540248508962.png","permalink":"https://demiurge-zby.github.io/p/buaa-oo-u4-uml%E6%AD%A3%E5%90%91%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","title":"BUAA OO U4 UML正向建模与图书管理系统"},{"content":"实验报告 思考题 Thinking 6.1 只需对父子进程的读写端口与管道行为等进行对调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 switch(fork()) { case -1: break; case 0: /*子进程-作为管道的写者*/ close(fildes[0]); /*关闭不用的读端*/ write(fildes[1],\u0026#34;Helloworld\\n\u0026#34;,12); /*向管道中写数据*/ close(fildes[1]); /*写入结束，关闭写端*/ exit(EXIT_SUCCESS); default: /*父进程-作为管道的读者*/ close(fildes[1]); /*关闭不用的写端*/ read(fildes[0],buf, 100); /*从管道中读数据*/ printf(\u0026#34;father-processread:%s\u0026#34;,buf); /*打印读到的数据*/ close(fildes[0]); /*读取结束，关闭读端*/ exit(EXIT_SUCCESS); } Thinking 6.2 下面是原来的dup函数的映射部分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if ((r = syscall_mem_map(0, oldfd, 0, newfd, vpt[VPN(oldfd)] \u0026amp; (PTE_D | PTE_LIBRARY))) \u0026lt; 0) { goto err; // 文件描述符的映射 } if (vpd[PDX(ova)]) { for (i = 0; i \u0026lt; PDMAP; i += PTMAP) { pte = vpt[VPN(ova + i)]; if (pte \u0026amp; PTE_V) { // should be no error here -- pd is already allocated if ((r = syscall_mem_map(0, (void *)(ova + i), 0, (void *)(nva + i), pte \u0026amp; (PTE_D | PTE_LIBRARY))) \u0026lt; 0) { goto err; // 文件内容的映射 } } } } 可以看到dup先对文件描述符进行映射，后对文件内容进行映射。\n如果在这两个系统调用中发生进程的中断，根据文件描述符的pp_ref将判断映射已经完成，而实际上文件内容并未被映射。\nThinking 6.3 我们的MOS是单核的，一般来说只有一个内核线程。\n那么引发系统调用被中断，只有可能是外部中断。\n而我们的MOS保证进入核心态后，会屏蔽外部中断。\n1 2 3 4 5 6 7 8 9 exc_gen_entry: SAVE_ALL mfc0 t0, CP0_STATUS and t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE) mtc0 t0, CP0_STATUS // unset IE to globally disable interrupts mfc0 t0, CP0_CAUSE andi t0, 0x7c lw t0, exception_handlers(t0) jr t0 Thinking 6.4 其实指导书说的也很明白了：\n一般情况下pageref(pipe)肯定大于读或写其中一个fd的pp_ref。通过调整顺序，先降低fd的pp_ref，保证了pageref(pipe) \u0026gt; pageref(fd)在彻底close前恒成立，从而解决了中途pageref(pipe)先降低导致出现pageref(pipe) == pageref(fd)的问题。\n对于未修改的dup函数，同样地也会出现这个问题。正如Thinking 6.2中所说，若先增加fd的pp_ref，后增加文件内容（也就是pipe）的pp_ref，就不能保证始终有pageref(pipe) \u0026gt; pageref(fd)。在两个map的间隙，就会存在pageref(pipe) == pageref(fd)的时刻，导致误判。\n倘若修改map的顺序，先对pipe进行map，就可以解决这一问题。\nThinking 6.5 打开文件的过程 用户调用open函数，提供路径和打开方式\n1 2 3 4 int fd; if ((fd = open(prog, O_RDONLY)) \u0026lt; 0) { return fd; } open函数在file.c中，负责申请fd，并利用fsipc完成文件的open与map，返回fd的编号\n以fsipc_open为例，他将路径与打开方式打包为struct Fsreq_open放进fsipcbuf（即req），并return fsipc(FSREQ_OPEN, req, fd, \u0026amp;perm);\n其中fsipc函数借助ipc通信，把value与页面传递给1号进程，也就是文件服务进程。\n1 2 3 4 5 6 static int fsipc(u_int type, void *fsreq, void *dstva, u_int *perm) { u_int whom; // Our file system server must be the 2nd env. ipc_send(envs[1].env_id, type, fsreq, PTE_D); return ipc_recv(\u0026amp;whom, dstva, perm); } // 给文件管理进程通信，传的值是type，共享的页面是一个结构体(一段内存)fsreq 发出的信息在fs/serv.c中的死循环函数serve中被接收\n1 req = ipc_recv(\u0026amp;whom, (void *)REQVA, \u0026amp;perm); 并将其转化为serve_open函数\n1 2 func = serve_table[req]; func(whom, REQVA); serve_open函数则进行真正的打开文件操作。\t其实也就是为它申请好了一个struct Open。\n如何读取并加载ELF文件 我们在spawn中已经打开了二进制文件，接下来便使用readn进行读取。\nreadn在fd.c中，实现了少量多次read的过程。\n1 2 3 4 5 6 7 8 9 10 11 int readn(int fdnum, void *buf, u_int n) { int m, tot; for (tot = 0; tot \u0026lt; n; tot += m) { m = read(fdnum, (char *)buf + tot, n - tot); if (m \u0026lt; 0) { return m; } if (m == 0) { break; } } return tot; } 读取完毕后使用elf_from进行检查，并得到ehdr。\n1 2 3 4 5 6 7 8 9 const Elf32_Ehdr *elf_from(const void *binary, size_t size) { const Elf32_Ehdr *ehdr = (const Elf32_Ehdr *)binary; if (size \u0026gt;= sizeof(Elf32_Ehdr) \u0026amp;\u0026amp; ehdr-\u0026gt;e_ident[EI_MAG0] == ELFMAG0 \u0026amp;\u0026amp; ehdr-\u0026gt;e_ident[EI_MAG1] == ELFMAG1 \u0026amp;\u0026amp; ehdr-\u0026gt;e_ident[EI_MAG2] == ELFMAG2 \u0026amp;\u0026amp; ehdr-\u0026gt;e_ident[EI_MAG3] == ELFMAG3 \u0026amp;\u0026amp; ehdr-\u0026gt;e_type == 2) { return ehdr; } return NULL; } 整体流程就是下面所示，得到了elf的入口entrypoint。\n1 2 3 4 5 6 7 8 9 if ((r = readn(fd, elfbuf, sizeof(Elf32_Ehdr))) != sizeof(Elf32_Ehdr)) { goto err; } const Elf32_Ehdr *ehdr = elf_from(elfbuf, sizeof(Elf32_Ehdr)); if (!ehdr) { r = -E_NOT_EXEC; goto err; } u_long entrypoint = ehdr-\u0026gt;e_entry; 接下来就是加载ELF文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ELF_FOREACH_PHDR_OFF (ph_off, ehdr) { if ((r = seek(fd, ph_off)) \u0026lt; 0) { goto err1; } if ((r = readn(fd, elfbuf, ehdr-\u0026gt;e_phentsize)) != ehdr-\u0026gt;e_phentsize) { goto err1; } Elf32_Phdr *ph = (Elf32_Phdr *)elfbuf; if (ph-\u0026gt;p_type == PT_LOAD) { void *bin; r = read_map(fd, ph-\u0026gt;p_offset, \u0026amp;bin); if (r != 0) { goto err1; } r = elf_load_seg(ph, bin, spawn_mapper, \u0026amp;child); if (r != 0) { goto err1; } } } bss段如何占据空间并初始化为0 这个就涉及到具体的加载过程。\t详见Lab3博客 Thinking 3.3\n1 2 3 4 5 6 7 8 9 10 11 int elf_load_seg(Elf32_Phdr *ph, const void *bin, elf_mapper_t map_page, void *data) { ... ... while (i \u0026lt; sgsize) { // 文件大小\u0026lt;内存，将剩余的内存都写入NULL if ((r = map_page(data, va + i, 0, perm, NULL, MIN(sgsize - i, PAGE_SIZE))) != 0) { return r; } i += PAGE_SIZE; } return 0; } 文件大小小于内存大小时，仍继续映射，用NULL写入剩余内存\n而回调函数spawn_mapper的逻辑保证不对NULL的部分作处理，就可以保证空间仍然为最开始的0。\n1 2 3 4 5 6 7 8 9 static int spawn_mapper(void *data, u_long va, size_t offset, u_int perm, const void *src, size_t len) { u_int child_id = *(u_int *)data; try(syscall_mem_alloc(child_id, (void *)va, perm)); if (src != NULL) { ... } return 0; } Thinking 6.6 如指导书所说，0和1是在init.b执行之后所规范的。\n1 2 3 4 // stdin should be 0, because no file descriptors are open yet if ((r = opencons()) != 0) { user_panic(\u0026#34;opencons: %d\u0026#34;, r); } opencons() 函数打开控制台设备，并返回一个文件描述符。\t由于进程初始时没有打开任何文件描述符，第一个打开的文件描述符默认是 0（最小可用值）。\t如果返回值不是 0，程序会触发 panic，确保标准输入必须绑定到文件描述符 0。\n1 2 3 4 // stdout if ((r = dup(0, 1)) \u0026lt; 0) { user_panic(\u0026#34;dup: %d\u0026#34;, r); } dup(0, 1) 函数将文件描述符 0（已绑定到控制台输入）复制到文件描述符 1。 这使得文件描述符 1 也指向控制台设备，从而实现标准输出的功能。 如果复制失败，程序同样会触发 panic。\nThinking 6.7 外部命令。在我们的spawn中，每次运行都要使用child = syscall_exofork();\ncd 命令的作用是改变当前进程的工作目录。\n如果像普通外部命令一样，运行时创建新进程，那么它对文件系统的操作就不会影响父进程的环境，当前目录不会改变，这显然不符合用户预期。\nThinking 6.8 下面是运行结果：\t（我在spawn函数的开头加了一句debugf）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ ls.b | cat.b \u0026gt; motd [00003003] pipecreate spawn! spawn! [00004005] destroying 00004005 [00004005] free env 00004005 i am killed ... [00004806] destroying 00004806 [00004806] free env 00004806 i am killed ... [00003804] destroying 00003804 [00003804] free env 00003804 i am killed ... [00003003] destroying 00003003 [00003003] free env 00003003 i am killed ... 可以观察到2次spawn，分别对应ls.b与cat.b的启动\n可以观察到4次进程销毁，分别对应ls.b，cat.b以及他们用于管道的两个子进程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 if (r != 0) { debugf(\u0026#34;pipe: %d\\n\u0026#34;, r); exit(); } r = fork(); // 为了管道进行一次fork if (r \u0026lt; 0) { debugf(\u0026#34;fork: %d\\n\u0026#34;, r); exit(); } *rightpipe = r; if (r == 0) { dup(p[0], 0); close(p[0]); close(p[1]); return parsecmd(argv, rightpipe); // 管道右端再运行一次 } else { dup(p[1], 1); close(p[1]); close(p[0]); return argc; } 难点分析 本次作业建立在前面所有lab的基础上，尤其是lab5，需要我们对文件系统足够了解才能顺利搭建管道和SHELL。\n管道的核心难点在于pageref的管理，这也是MOS首次出现关于调整先后执行顺序的问题。问题的核心原因在于判断读端或写端是否关闭时，使用了pageref的方法，而这个条件在某些中间状态下并不充分。\nSHELL需要我们熟悉流程，关键是parsecmd和spawn两个函数。从SHELL中读取token并解析命令，然后调用spawn对ELF文件进行打开加载运行等等操作。\n整体来说，lab6实现的主要是上层建筑，将MOS的功能以可交互的形式展现了出来，不再只能运行既定程序，而是支持了命令行的各项操作。\n实验体会 随着lab6的结束，这个学期也要走向了尾声。不过这个博客并不是OS系列的终点，我们还有看起来非常有挑战性的挑战性任务！\nOS课程走到现在，虽然做的只是一些补全代码的工作，但是也极大地锻炼了我们阅读代码的能力，尤其是在不能直接Ctrl+Click用跳转到环境下，我们只能使用grep -nr xxx ./去寻找，或者对MOS的架构烂熟于心。\n最后感谢课程组的辛苦付出！希望OS课程越办越好！\n","date":"2025-06-04T20:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab6-%E7%AE%A1%E9%81%93%E4%B8%8Eshell/123_hu18230510939799483266.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab6-%E7%AE%A1%E9%81%93%E4%B8%8Eshell/","title":"BUAA OS Lab6 管道与SHELL"},{"content":"终于还是来到了最后一次上机。\n可能是作为第一届拥有OS官方课下答案的试验品，同学们对OS整体架构的把握情况貌似远不如前。毕竟花的时间可能确确实实地少了。\t我自己则更是深刻感受到与学长们的差距。直到上机，也还在疯狂地寻找结构体成员的名字是什么，找结构体在哪里宏定义，找各种各样的lookup，walk与get究竟要怎么用。\n在上机前，我还在抱有幻想。我自以为对各种方法的基本功能不太陌生。给我一个方法名，我知道大概记得它能得到什么，它会改变什么。\t但我并没有意识到我根本不会用。当我真的要填写参数的时候，这里要填谁？这个参数来源于谁？那个结构体成员变量名到底是谁？\nexam 这次的exam我个人认为是不难的。尽管总共用了1个小时，中途de了很久bug，但是上完机和别人交流后发现花费1个小时貌似并不是特别长。\n题面 见：\n1 https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab5-%E4%B8%8A%E6%9C%BA/lab5_exam.pdf 其实题目本身并不是很简单，但是给的提示太全面了。本来我看到深搜的时候有点慌，但是具体实现都已经给出来了。\n基本上所有人在这里卡住，都只是把path与name拼接时出错。不过这也是这道题在给予如此多的提示之下最大的难点了。\n不过，这个难点并不是很易于察觉。\n注意到题干上明确指出了给出的path以\u0026rsquo;/\u0026lsquo;结尾。\t但是样例上在输出时却又发现结尾并不含\u0026rsquo;/\u0026rsquo;。\n这意味着我们至少要做出一点改动：\t要么保证所有的path都以\u0026rsquo;/\u0026lsquo;结尾，但保存时要把最后一个\u0026rsquo;/\u0026lsquo;变为\u0026rsquo;\\0\u0026rsquo;\t如果保证path以\u0026rsquo;/\u0026lsquo;结尾，在拼接时应当直接拼接name再加上\u0026rsquo;/\u0026rsquo;\n要么就保证所有的path都不以\u0026rsquo;/\u0026lsquo;结尾，保存时直接用path\t这样的话，我们就需要在拼接时，先在path后追加\u0026rsquo;/\u0026rsquo;，再拼接name\t但是刚开始的path是保证以\u0026rsquo;/\u0026lsquo;结尾的，因此，在path后追加\u0026rsquo;/\u0026lsquo;时，要先判断现在的结尾是不是\u0026rsquo;/\u0026rsquo;\n这时有同学要说了：哎呀这也太复杂了吧，这怎么想得到呢？\n为了让大家顺利通过，助教现场添加了一条又一条新的HINT，并疯狂地参与答疑。\n最后的结果应当是不错的。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int traverse_file(const char *path, struct File *file, const char *name, struct Find_res *res) { u_int nblock; nblock = file-\u0026gt;f_size / BLOCK_SIZE; //\tdebugf(\u0026#34;now path is %s\\n\u0026#34;, path); // 1. 检查路径长度是否符合要求，如不符合，直接返回 if (strlen(path) == 0 || strlen(path) \u0026gt; MAXPATHLEN/* path 的长度为零或不小于最大路径长度*/) { /*返回*/ return; } // 2. 比较当前文件名是否等于 name，如果相等则更改 res if (strcmp(name, file-\u0026gt;f_name) == 0/*file 的名字等于 name*/) { //\tdebugf(\u0026#34;path is %s, name is %s\\n\u0026#34;, path, file-\u0026gt;f_name); /*增加 res-\u0026gt;count*/res-\u0026gt;count++; /*添加 res 的路径*/strcpy(res-\u0026gt;file_path[res-\u0026gt;count - 1], path); } if (file-\u0026gt;f_type == FTYPE_DIR) { for (int i = 0; i \u0026lt; nblock; i++) { void *blk; try(file_get_block(file, i ,\u0026amp;blk)); struct File *files = (struct File *)blk; for (struct File *f = files; f \u0026lt; files + FILE2BLK; ++f) { char curpath[MAXPATHLEN + MAXNAMELEN + 3]; // 3. 把 path 和 name 拼接起来得到下一层文件路径，注意结尾的 \u0026#39;\\0\u0026#39; // 提示：我们没有实现 strcat 工具函数，你可以用 strcpy 实现拼接 strcpy(curpath, path); if (curpath[strlen(curpath) - 1] != \u0026#39;/\u0026#39;) { strcpy(curpath + strlen(curpath), \u0026#34;/\\0\u0026#34;); } strcpy(curpath + strlen(curpath), f-\u0026gt;f_name); strcpy(curpath + strlen(curpath), \u0026#34;\\0\u0026#34;); // 其实可以不需要 // 4. 递归调用 traverse_file 函数 traverse_file(curpath, f, name, res); } } } return 0; } int find_files(const char *path, const char *name, struct Find_res *res) { struct File *file; int r; // 用 walk_path 来找到 path 对应的文件夹 // Lab5-Exam: Your code here. (1/2) if ((r = walk_path(path, 0, \u0026amp;file, 0)) \u0026lt; 0) { return r; } // debugf(\u0026#34;I have found\\n\u0026#34;); // 在 path 对应的文件夹下面遍历，找到所有名字为 name 的文件，你可以调用下面的参考函数 traverse_file // Lab5-Exam: Your code here. (2/2) traverse_file(path, file, name, res); return 0; } extra jby学长出的很有意思的综合性很强的加密文件extra。\n其实流程给的也很详细了，奈何自己的熟练程度还是太差。\n题面 见：\n1 https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab5-%E4%B8%8A%E6%9C%BA/lab5_extra.pdf 错误的代码 下面是我跟着流程，装模作样写出来的其中一个函数。其中很多用法自己也不确定，*(blk-\u0026gt;data) != FS_MAGIC好像还编译错误了。（我还特意看了block的data是字节的指针呢。 哦，笔者刚刚意识到FS_MAGIC是字）\n仅仅这么点看起来很公式，很平凡的代码，还充满了提示，我却足足用了半个多小时的时间。此时还有8个有流程的函数没有完成，还有serve_map与serve_close没有修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void serve_key_set(u_int envid, struct Fsreq_key_set *rq) { // 判断当前状态是否已加载密钥，如果已加载密钥， IPC 返回 -E_BAD_KEY if (encrypt_key_set != 0) { ipc_send(envid, -E_BAD_KEY, 0, 0); return; } // 利用 open_lookup 找到对应的 Open 结构体，判断文件大小是否至少有两个磁盘块大小 // 利用 file_get_block 读取文件的第一个磁盘块，判断第一个字是否为 FS_MAGIC // 如果密钥文件不合法， IPC 返回 -E_INVALID_KEY_FILE struct Open *o; if ((r = open_lookup(envid, rq-\u0026gt;req_fileid, \u0026amp;pOpen)) \u0026lt; 0) { ipc_send(envid, r, 0, 0); return; } if (o-\u0026gt;o_file-\u0026gt;f_size \u0026lt; 2 * BLOCKSIZE) { ipc_send(envid, -E_INVALID_KEY_FILE, 0, 0); return; } struct Block *blk; if ((r = file_get_block(o-\u0026gt;o_file, 0, \u0026amp;blk)) \u0026lt; 0) { ipc_send(envid, r, 0, 0); return; } if (*(blk-\u0026gt;data) != FS_MAGIC) { ipc_send(envid, -E_INVALID_KEY_FILE, 0, 0); return; } // 利用 file_get_block 读取文件的第二个磁盘块，将密钥复制到 encrypt_key 中 if ((r = file_get_block(pOpen-\u0026gt;o_file, 1, \u0026amp;blk)) \u0026lt; 0) { ipc_send(envid, r, 0, 0); return; } strcpy(encrypt_key, blk-\u0026gt;data); // 将当前状态标记为已加载密钥 encrypt_key_set = 1; // IPC 返回 0 ipc_send(envid, 0, 0, 0); } 后记 OS上机结束了，回头看来，真是一无是处。曾经还在为lab0-extra懊悔不已，现在已经连连溃败。\nOOhw13因为重构代码，漏了一句很重要的话，却没被中测测出来，导致强测完全失败，比hw7的分数还要低得多。\n乒乓球也因为平时没有经常与老师交流，考试时错误频出，等待下周再次测试。\n没几天就要去考OS理论期末了。准确来说，就是端午节假期后的第一个上午。本学期最高学分的课程就要结束了。\n祝好运。\n","date":"2025-05-31T11:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab5-%E4%B8%8A%E6%9C%BA/123_hu7752363953855477225.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab5-%E4%B8%8A%E6%9C%BA/","title":"BUAA OS Lab5 上机"},{"content":"实验报告 思考题 Thinking 5.1 可能产生的问题： 1.映射到kseg0可能会和重要内核数据或代码段发生地址冲突。\n2.外设寄存器的访问需要实时性和强一致性，kseg0使用cache操作延迟较高。\n3.外设寄存器的值可能会自发变化，这种变化不会被Cache记录，从而使CPU读取错误数据。\n串口设备相对于IDE磁盘有更强的实时性需求，串口信息的交流若使用cache，很容易出现数据一致性问题。\nThinking 5.2 在user/include/fs.h:\n1 2 #define BLOCK_SIZE PAGE_SIZE // #define PAGE_SIZE 4096 #define FILE_STRUCT_SIZE 256 还有：\n1 #define FILE2BLK (BLOCK_SIZE / sizeof(struct File)) 所以一个磁盘块可存储 4096/256 = 16 个文件控制块。\n对于一个目录文件来说，其指向的磁盘块存储着目录项，目录项为文件所在的磁盘块号。\n因此其包含1024个目录项，对应16 * 1024 = 16K 个文件。\n单个文件最大时，10个直接索引对应10个磁盘块，1个间接索引对应1024个磁盘块号（前10个不用）。\n也就是一个文件的内容最多共占用1024个磁盘块。\n也可根据以下宏定义推算。\n1 2 #define NINDIRECT (BLOCK_SIZE / 4) #define MAXFILESIZE (NINDIRECT * BLOCK_SIZE) 即一共1024*4096 = 4MB大小。\nThinking 5.3 在fs/serv.h:\n1 2 /* Maximum disk size we can handle (1GB) */ #define DISKMAX 0x40000000 注释中已经表明，我们可以处理的最大磁盘大小为1GB。\nThinking 5.4 在Thinking 5.2 与 Thinking 5.3 我给出的两段宏定义便分别出自这两个文件。\t除此之外，还有许多重要的内容在这两个文件中。\n在user/include/fs.h:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 有关\tblock 与 file #define BLOCK_SIZE PAGE_SIZE #define BLOCK_SIZE_BIT (BLOCK_SIZE * 8) #define FILE_STRUCT_SIZE 256 #define FILE2BLK (BLOCK_SIZE / sizeof(struct File)) // 关于 file struct File { char f_name[MAXNAMELEN]; // filename uint32_t f_size;\t// file size in bytes uint32_t f_type;\t// file type uint32_t f_direct[NDIRECT]; uint32_t f_indirect; struct File *f_dir; // the pointer to the dir where this file is in, valid only in memory. char f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (3 + NDIRECT) * 4 - sizeof(void *)]; } __attribute__((aligned(4), packed)); 文件控制块的结构还是很需要熟悉的。\n在fs/serv.h:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 用于dirty #define PTE_DIRTY 0x0004 // file system block cache is dirty // PTE_D是可写位 PTE_DIRTY才是脏位 // 有关 sector #define SECT_SIZE 512\t/* Bytes per disk sector */ #define SECT2BLK (BLOCK_SIZE / SECT_SIZE) /* sectors to a block */ /* Disk block n, when in memory, is mapped into the file system * server\u0026#39;s address space at DISKMAP+(n*BLOCK_SIZE). */ #define DISKMAP 0x10000000 /* Maximum disk size we can handle (1GB) */ #define DISKMAX 0x40000000 extern uint32_t *bitmap; // 位图法记录空间占用 Thinking 5.5 会共享。\n我并没有深研Makefile，也不知道这些xxxtest程序是如何变成user_xxx进程从而直接被init调用的，因此我选择了改装已有的程序fstest.c，至于/newmotd到底在哪，我也不得而知，但我知道它的内容是： This is a different massage of the day!\\n。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;lib.h\u0026gt; int main() { int r; int fdnum; char buf[512]; int n; if ((r = open(\u0026#34;/newmotd\u0026#34;, O_RDWR)) \u0026lt; 0) { user_panic(\u0026#34;wrong when open /newmotd: %d\u0026#34;, r); } fdnum = r; debugf(\u0026#34;fdnum == %d\\n\u0026#34;, fdnum); // 拿到fdnum号 if ((n = read(fdnum, buf, 5)) \u0026lt; 0) { user_panic(\u0026#34;wrong when read /newmotd: %d\u0026#34;, r); } // 读5个字符 debugf(\u0026#34;read: %s\\n\u0026#34;, buf); struct Fd *fdd; fd_lookup(r, \u0026amp;fdd); debugf(\u0026#34;fd == %x\\n\u0026#34;, fdd); // fdd的值 debugf(\u0026#34;now offset == %d\\n\u0026#34;,fdd-\u0026gt;fd_offset); // 偏移量 int id; if ((id = fork()) == 0) { if ((n = read(fdnum, buf, 5)) \u0026lt; 0) { user_panic(\u0026#34;child: wrong when read /newmotd: %d\u0026#34;, r); } debugf(\u0026#34;child read: %s\\n\u0026#34;, buf); struct Fd *fdd; fd_lookup(r, \u0026amp;fdd); debugf(\u0026#34;child: fd == %x\\n\u0026#34;, fdd); debugf(\u0026#34;child: now offset == %d\\n\u0026#34;,fdd-\u0026gt;fd_offset); } else { if((n = read(fdnum, buf, 5)) \u0026lt; 0) { user_panic(\u0026#34;father: wrong when read /newmotd: %d\u0026#34;, r); } debugf(\u0026#34;father read: %s\\n\u0026#34;, buf); struct Fd *fdd; fd_lookup(r, \u0026amp;fdd); debugf(\u0026#34;father: fd == %x\\n\u0026#34;, fdd); debugf(\u0026#34;father: now offset == %d\\n\u0026#34;,fdd-\u0026gt;fd_offset); } } 运行结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 init.c: mips_init() is called Memory size: 65536 KiB, number of pages: 16384 to memory 80430000 for struct Pages. pmap.c: mips vm init success FS is running superblock is good read_bitmap is good fdnum == 0 // 可能是因为第一个文件，分配了号码0 read: This // 读到\u0026#39;T\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39; \u0026#39; fd == 5fc00000 // 文件描述符的地址 now offset == 5 // 当前的偏移量 为 5 father read: is a // 读到\u0026#39;i\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;a\u0026#39;,\u0026#39; \u0026#39; father: fd == 5fc00000 father: now offset == 10 // 当前的偏移量 为 10 child read: diffe // 读到\u0026#39;d\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;e\u0026#39; child: fd == 5fc00000 child: now offset == 15 // 当前的偏移量 为 15 [00000800] destroying 00000800 [00000800] free env 00000800 i am killed ... [00001802] destroying 00001802 [00001802] free env 00001802 i am killed ... panic at sched.c:45 (schedule): schedule: no runnable envs ra: 800260a0 sp: 803ffe80 Status: 00008000 Cause: 00000420 EPC: 004002c0 BadVA: 7fd7f004 curenv: NULL cur_pgdir: 83fd1000 由此可以看出fork前后，父子进程会共享文件描述符和定位指针。\nThinking 5.6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct File { // 文件控制块（元数据） char f_name[MAXNAMELEN]; // filename 且最大长度为128 uint32_t f_size;\t// 文件大小的字节数 uint32_t f_type;\t// 文件类型：普通文件FTYPE_REG与目录FTYPE_DIR uint32_t f_direct[NDIRECT]; // 直接索引，放着NDIRECT个磁盘块号\tuint32_t f_indirect; // 间接索引，指向放着许多磁盘块号的磁盘块 struct File *f_dir; // 指向所在的目录文件 char f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (3 + NDIRECT) * 4 - sizeof(void *)]; // 字节对齐，保证 #define FILE_STRUCT_SIZE 256 } __attribute__((aligned(4), packed)); struct Fd { // 用于描述文件操作 u_int fd_dev_id; // 文件对应的设备id u_int fd_offset; // 文件当前读写的偏移量，在read/write作用较大 u_int fd_omode; // 文件的打开方式 }; struct Filefd { // 文件操作所需的整体信息 struct Fd f_fd; // 文件的相关描述 u_int f_fileid; struct File f_file; // 文件控制块 }; Thinking 5.7 不同箭头的意义各不相同。\n先是由init实现user_env与fs_serv进程的启动的两个箭头。\t然后fs_serv进行初始化，执行serve()，开始等待用户进程提出的请求。\nuser_env进行fsipc，并通过IPC向fs_serv通信，fs_serv调用serv相关函数，并通过IPC返回信号给用户进程。fs_serv继续等待请求。\n难点分析 lab5内容十分复杂，涉及到前面lab的很多知识，也包含大量的全新知识。\t其次它的模块又大又多：\n磁盘IDE的读写操作 ide_read，ide_write\n磁盘上的文件系统架构 disk与block的关系，block与va的关系，block与file的关系，file与文件的关系\n用户发起文件系统操作 fd与ffd的作用，file.c调用fsipc.c\nserv实现文件系统操作 serv.c实现具体的文件操作\n博客阅读随笔 参考博客：Wokron: 点击跳转阅读\n参考博客：杨导: 点击跳转阅读\n磁盘块号为bno, 则block为 disk[bno]\n(disk是一个struct block数组)\nstruct block就是data与type两个属性\n目录文件与普通文件都在BLOCK_FILE的16个FILE中\n目录文件的direct与indirect指向的block都是BLOCK_FILE\n普通文件的direct与indirect指向的block都是BLOCK_DATA\n目录项是FILE文件，也就是该目录中的文件的意思。\n文件管理系统必须是第二个进程(envs[1])。\nsuper块必须是第二个磁盘块(disk[1])。\nfsipc.c: ipc_send(envs[1].env_id, type, fsreq, PTE_D);\nfsreq存处理参数：(struct Fsreq_xxx *)并页面共享\ntype存储value，直接到serv.c的req\nserv.c: req = ipc_recv(\u0026amp;whom, (void *)REQVA, \u0026amp;perm);\n实验体会 文件系统的内容确实较大，完全可以拆成文件系统的架构搭建、文件操作处理流程两个Lab进行实现。\n整体的感受是任务大，又不知从何看起。跟着博客走一圈，再跟着指导书走一圈，应该需要花上不少时间才能够对这个Lab有一个比较系统的认识。\n15周周二就要OS期末。可是13、14周的OO还要照旧，14周还有lab5上机等着自己。15周周末要考航概，可能乒乓也要考试了，挑战性任务也不知道是什么时候。虽然课少了好多，但是临近期末的任务量只会不减反增。\n这种情况下，如果lab5的exam容易拿到分数，放弃深研lab5可能是一种选择。（虽然之前有所研究的lab也没很好的做出extra，或者说exam和extra的核心考点并不在整体架构的认识上（当然笔者对每个lab的架构也并没有多深刻的见解））\n但是果然还是想要知道lab5是怎么实现的。无论如何，还有很多东西不清楚不明白，就先这样。把OO的UML先看一看，再来弥补一下lab5吧。\n","date":"2025-05-18T20:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/123_hu3166823588037151944.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","title":"BUAA OS Lab5 文件系统"},{"content":"关于架构 本单元的核心任务是根据接口提供的需求，写出其具体实现。\n三次迭代的递进关系并不很强，更像是不同模块的各自实现。\n第一次迭代明确了Network作为中枢，并引入了核心对象person与tag\n第二次迭代引入account模块与article系统\n第三次迭代则引入了综合性很强的message系统，其中涉及到了tag与article的相关内容\n由于接口的需求很明确，整个图模型的架构相对确定，我们的核心内容主要只是完成方法与辅助方法。\n关于测试 本单元对测试的要求较高，中测的核心问题主要出现在Junit测试中。\n但为了通过中测所进行的测试，往往是最简单的单元测试。 因此哪怕已经经历了一整个单元，我对许多其他测试的具体内容仍然是完全陌生的。\n单元测试 针对软件中的最小可测试单元进行的测试，确保每个单元能正常工作。\n特点：\n粒度最小：聚焦单个单元，测试范围独立。 白盒测试为主：需了解代码内部结构，设计测试用例覆盖不同分支、边界条件等。 功能测试 基于软件需求规格说明书，验证功能是否符合用户预期，不关注内部实现细节。\n特点：\n黑盒测试为主：从用户视角出发，仅关注输入与输出。 粒度较大：对整体进行测试，系统性强，只能鉴定问题的存在性，而很难做好定位 集成测试 将多个单元或模块组合起来，测试它们之间的接口和交互是否正常。\n特点：\n关注接口与协作：测试重点往往是模块间的依赖关系和数据流动。 渐增式测试：一般采用自顶向下、自底向上或混合方式逐步集成模块，便于定位模块间交互出现异常的位置。 压力测试 通过模拟高负载、高并发场景，测试系统在极限条件下的性能、稳定性和容错能力。\n特点：\n破坏性测试：常常故意施加超过正常范围的压力。 关注性能指标：如CPU time，Running time，内存等指标。 回归测试 在发生如代码修改、功能新增等变化后，重新测试已验证过的功能，确保变更未引入新缺陷或破坏原有功能。\n特点：\n重复性测试：可重复执行历史测试用例来检验是否破坏原有功能。 关于大模型 本次作业我使用大模型的地方并不是很多，但第六次上机实验给了我很大的启发。\n上机实验中的三个阶段分别是：\n直接生成 给出相关知识与解释 给出具体的示例 在根据这三个步骤实现之后，大模型的表现确实有很大进步。首先给出任务目标，然后再明确期望格式和核心目的，采用的是采用目标层→约束层→示例层的三层结构，减少模型理解偏差。\n在实际使用过程中，我还有一些其他的使用体验，例如动态反馈。其实这个是我使用大模型时的常态，究其根本原因，可能便是对自己要解决什么问题都不清楚。于是在大模型的输出中进一步寻找问题，寻求解释，从而一层一层地解决问题。虽然最后一般也有不错的结果，但是还是相对耗时。 可能由自己直面问题，将核心目的拆解出来再借助大模型，会有更好的效果。\n关于性能 规格与实现分离。规格是题干，实现是题解。题干限定了你的结果，但是做题的过程由你的实现所决定。一道选择题可能大家都能写出正确答案，但是不同人的思考模式与做题技巧是不同的。如果你的实现能够满足规格的所有要求，那么这个实现便是正确的，但未必是优秀的。\n在本次作业中，优秀的评断主要体现在TIME。因此我们一般要考虑构建一些数据结构，试图以空间换时间。\n并查集 在query_circle中，我采用了并查集的方法，结合了路径压缩与按秩合并。\n并查集的核心思想就是为一个连通分支选出一个代表结点。\n路径压缩：\n1 2 3 4 5 private int find(int id) { if (parent.get(id) != id) { parent.put(id, find(parent.get(id))); // 压缩 } return parent.get(id); } 按秩合并：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void union(int id1, int id2) { int root1 = find(id1); int root2 = find(id2); if (root1 != root2) { // 按秩合并 if (rank.get(root1) \u0026lt; rank.get(root2)) { parent.put(root1, root2); } else if (rank.get(root1) \u0026gt; rank.get(root2)) { parent.put(root2, root1); } else { parent.put(root2, root1); rank.put(root1, rank.get(root1) + 1); } } } 但是并查集便于增添，不便于删改。当某段关系被解除，路径压缩后的并查集不能再判断出这个人是否会脱离该连通分支。因此此时须考虑重新构建并查集。\n增量化设计 这一优化对我的影响相对较深，至少让我首次意识到size的维护居然能避免一次大遍历。\n增量化设计的核心思想就是在变化时对数值做维护，在查询时直接得到当前结果。或者说这是一种在线算法，求值不从头开始，而是由上一状态+变化过程而得来。\n在query_tag_value_sum，query_triple_sum和query_tag_age_var中，我主要使用了这一思想。具体实现上的易错点就不必在这里赘述了。\n缓存与脏位 缓存类似于增量化设计，但缓存的内容不一定是正确的。\n某些值虽然我知道在某个过程中发生了改变，但是维护起来相对复杂，甚至效率堪比重新计算。倘若在每次改变的时候都进行维护，虽然精准，但会造成效率的损失。\n例如均值是方便增量化维护的，而方差就不方便。\n因此可以选择设置dirty位，仅在需要查询时再进行缓存数据的更新。\n我在query_best_acquaintance，query_best_contributor，query_tag_age_var以及并查集的重建中主要使用了这一思想。\nMyContainer 主要解决在有序列表中按值删除对象中的遍历问题。\nLinkedlist固然好，但是它只是能很快的删除某个结点，内部不存在值与结点的映射。因此只需仿照Linkedlist构建一个类，但增加一个属性HashMap用来由值索引到结点。（因为一个值可能对应多个节点，所以可以考虑HashMap\u0026lt;Integer,HashSet\u0026lt;...\u0026gt;\u0026gt;）\n在hw10强测中因未采用这一数据结构而发生了CTLE。\n关于Junit 我在本单元的研讨课上较多地讲述了如何由规格构建测试的方法论。在此将主要内容进行重述。\n自动化测试基本方法 @RunWith(Parameterized.class) 切换到 Parameterized 运行器，让测试类依据多组参数生成多个Test对象，多次执行同一个测试方法，避免了手动编写大量重复的测试代码。 @Parameterized.Parameters\n定义一个返回测试数据集合的静态方法，返回的集合包含testNum个小集合，每个小集合包含生成Test对象的参数。\n多次@Test 手动构建测试样例，覆盖能够触发 JML 规格中所有可能行为的输入数据和对象状态。\n基于规格的数据生成 数据限制 requires明确了方法的某种输入约束（如参数范围、对象状态）。 invariant是类级别的约束，必须确保测试数据满足这些基本约束。 多场景构造 正常场景：构造满足前置条件的典型输入，触发 JML ensures 条款中的正常行为。 边界场景：构造边缘输入，如空集合、边界值、单一元素等。 异常场景：构造违反前置条件的输入，触发 JML signals 条款中的异常。 复杂场景：构造具有复杂关系或大规模数据的场景，测试方法在高负载下的正确性。 基于规格的断言生成 invariant -\u0026gt; 基本数据要求，可断言执行方法后是否满足\nconstraint -\u0026gt; 数据变化要求，可保存old信息进行断言\nassignable -\u0026gt; 对没被assign的变量做pure断言\nsignal -\u0026gt; 异常捕捉方法或assertThrow\nensures -\u0026gt; 方法核心效果的断言\npure -\u0026gt; 保存old信息（或备份信息）进行断言\n关于心得 本单元整体给我的感觉是比较舒适的。除了hw10的实验预习题中那颗树的JML让我感到深刻畏惧，其他的JML读起来都让人很明白自己需要做什么。哪怕是看起来最复杂的sendMessage，很多行JML也只是对应一个小方法的调用。而有些言简意赅的JML，背后却需要十分复杂的实现。\n有了颜色标注之后，阅读JML的枯燥与混乱已经基本消失殆尽。\n但是JML的书写对我来说仍然是极为困难的课题，哪怕强如助教也会在官方包出现小的失误。但JML作为根本要旨，要保证绝对的严格与严谨，书写JML需要有对方法极高的概括力，还有对细节的全面把握。不过学完了这个单元，我们终于可以说自己走出了了解JML的第一步。\n","date":"2025-05-16T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-oo-u3-jml%E4%B8%8E%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/123_hu8134739115865899318.png","permalink":"https://demiurge-zby.github.io/p/buaa-oo-u3-jml%E4%B8%8E%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/","title":"BUAA OO U3 JML与社交网络"},{"content":"exam 往年的lab4上机分为4-1和4-2两个部分。\n其中lab4-1侧重于考察系统调用本身的实现，而lab4-2仍以系统调用为载体，但更多地强调像fork一样，借助系统调用去实现某些功能。\n对于本次上机：\n在上机伊始，助教便提醒：\n本次上机exam难度较易，请多用心挑战extra题目。 我认为主要原因是lab4的拆分，从而导致某些必考考点在简单的exam里得不到充分的测试。\n本次exam共两项内容。\nsys_get_ppid 得到当前进程的父进程的env_id，若没有父进程则返回0.\n他甚至连try(envid2env(id, \u0026amp;e, 0))都不让你写，只需返回curenv的env_parent_id\n至于没有父进程则返回0这一点不必担心，此时env_parent_id也就是0.\n因此最耗时的地方反而是更改这些： include/syscall.h 扩充enum include/error.h 扩充新的error\nkern/syscall_all.c 扩充syscall_table\nuser/include/lib.h 函数声明 user/lib/syscall_lib.c 用户sys调用msys (这个有的时候有些门道，不仅仅是return msys那么简单)\nPTE_PROTECT 在fork的duppage中额外考虑PTE_PROTECT\n题意也很明白：若权限位含PTE_PROTECT（注意是不为0），直接终止duppage函数。\n也即在duppage函数中：\n1 2 3 4 5 6 7 /* Hint: The page should be first mapped to the child before remapped in the parent. (Why?) */ /* Exercise 4.10: Your code here. (2/2) */ if ((perm \u0026amp; PTE_PROTECT) != 0) { return; } if (((perm \u0026amp; PTE_D) == 0) || (perm \u0026amp; PTE_LIBRARY) || (perm \u0026amp; PTE_COW)) ... 至于PTE_PROTECT怎么来的，都不关我们的事。\n大家这一题做的都很快，因为根本没有卡人的地方。\nextra extra其实也是一道比较简单的题。但正因为题面简单，导致题干的提示少了一点，容易让自己瞎想。\n在大多数人都轻松做对extra的时候，笔者又一次拿了0分。\n比较搞笑的是，犯这样错误的人还不少。\n原因是一个struct Shm shm_pool[];\n大家总是要写shm_pool[key].npage等这样的信息，有些烦躁，就直接 struct Shm shm = shm_pool[key];\n被面向对象宠坏了的同学们，完全没有想到这里已经不再是对象了。而是一个新的被赋了初值的变量。\n这里应当采用 struct Shm* shmptr = \u0026amp;shm_pool[key];\n题面 见：\n1 https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab4-%E4%B8%8A%E6%9C%BA/lab4_extra.pdf 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 struct Shm shm_pool[N_SHM]; int sys_shm_new(u_int npage) { if (npage == 0 || npage \u0026gt; N_SHM_PAGE) { return -E_SHM_INVALID; } // Lab4-Extra: Your code here. (5/8) int id; for (id = 0; id \u0026lt; N_SHM; id++) { if (shm_pool[id].open == 0) { shm_pool[id].npage = npage; /* 太蠢了太蠢了太蠢了!!!*/shm_pool[id].open = 1;// 笔者的核心错因是忘记写这句话！！！！！！！ for (int i = 0; i \u0026lt; npage; i++) { int r; struct Page* pp; r = page_alloc(\u0026amp;pp); if (r \u0026lt; 0) { shm_pool[id].npage = 0; shm_pool[id].open = 0; for (int j = 0; j \u0026lt; i; j++) { page_decref(shm_pool[id].pages[j]); shm_pool[id].pages[j] = NULL; } return -E_NO_MEM; } shm_pool[id].pages[i] = pp; pp-\u0026gt;pp_ref++; } return id; } } return -E_SHM_INVALID; } int sys_shm_bind(int key, u_int va, u_int perm) { if (key \u0026lt; 0 || key \u0026gt;= N_SHM) { return -E_SHM_INVALID; } // Lab4-Extra: Your code here. (6/8) if (shm_pool[key].open == 0) { return -E_SHM_NOT_OPEN; } u_int addr = va; for (int i = 0; i \u0026lt; shm_pool[key].npage; i++) { page_insert(curenv-\u0026gt;env_pgdir, curenv-\u0026gt;env_asid, shm_pool[key].pages[i], addr, perm); addr += PAGE_SIZE; } return 0; } int sys_shm_unbind(int key, u_int va) { if (key \u0026lt; 0 || key \u0026gt;= N_SHM) { return -E_SHM_INVALID; } // Lab4-Extra: Your code here. (7/8) if (shm_pool[key].open == 0) { return -E_SHM_NOT_OPEN; } u_int addr = va; for (int i = 0; i \u0026lt; shm_pool[key].npage; i++) { if (shm_pool[key].pages[i] == NULL) break; page_remove(curenv-\u0026gt;env_pgdir, curenv-\u0026gt;env_asid, addr); addr += PAGE_SIZE; } return 0; } int sys_shm_free(int key) { if (key \u0026lt; 0 || key \u0026gt;= N_SHM) { return -E_SHM_INVALID; } // Lab4-Extra: Your code here. (8/8) if (shm_pool[key].open == 0) { return -E_SHM_NOT_OPEN; } shm_pool[key].open = 0; for (int i = 0; i \u0026lt; shm_pool[key].npage; i++) { page_decref(shm_pool[key].pages[i]); } return 0; } 后记 这次上机exam大多数同学在20min以内都能完成。\n但是如此简单的extra，是如何让大家虚空debug 100min 的呢？\n我的vim出现了一次很可怕的问题。在粘贴之后，一些奇怪的位置也被粘贴了那段代码。整个syscall.c都被毁了，于是从OS gitlab里重新复制代码粘了上去。\n这可能浪费了一点时间？\n此外，lab3-exam告诉我们不要太高估exam，lab4-extra则告诉我们不要太高估extra!\n这句话有点太狂妄了() 但是希望大家做题的时候千万不要想太多！ 必须实现的奇思妙想一定会在HINT里指出!!!\n由于题目里告诉我们可以用page_remove来实现shm_unbind，却没有明确指出用page_insert来实现shm_bind。 我便一口认定要自己重新手搓shm_page_insert函数。后面的一切努力当然都是徒劳。\n怎么能忘记把open置1啊？！！\n宛如曾经P6上机循环没有变量初始化、忘记写[31:0]一般的无力感\n哦对！今天是我的生日！生日快乐！祝大家都要快乐！！！\n","date":"2025-05-09T11:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab4-%E4%B8%8A%E6%9C%BA/123_hu17546119963486967881.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab4-%E4%B8%8A%E6%9C%BA/","title":"BUAA OS Lab4 上机"},{"content":"实验报告 思考题 Thinking 4.1 要想回答这个问题，我们先重新梳理一下系统调用的流程。\n用户主动调用 用户sys_* 在user/lib/syscall_lib.c中：\n1 2 3 4 5 6 7 8 void syscall_putchar(int ch) { msyscall(SYS_putchar, ch); } int syscall_print_cons(const void *str, u_int num) { return msyscall(SYS_print_cons, str, num); } ... 在调用函数时，参数已经被压入了栈帧中对应的位置。\n执行msyscall 在user/lib/syscall_wrap.S中：\n1 2 3 4 LEAF(msyscall) syscall jr\tra END(msyscall) PC跳转进入异常入口 CPU执行syscall，直接跳转pc到异常入口\n并执行entry.S中的:\n1 2 3 4 5 6 7 8 9 exc_gen_entry: SAVE_ALL mfc0 t0, CP0_STATUS and t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE) mtc0 t0, CP0_STATUS mfc0 t0, CP0_CAUSE andi t0, 0x7c lw t0, exception_handlers(t0) jr t0 这个过程就回答了前两个问题。\tSAVE_ALL保护了所有通用寄存器。\n并且$a0-$a3没有被重新赋值。因此陷入内核调用后仍可以直接从当时的$a0-$a3参数寄存器中得到用户调用msyscall留下的信息。\n得到异常类型 由traps.c中的exception_handlers:\n1 2 3 4 5 6 7 8 9 void (*exception_handlers[32])(void) = { [0 ... 31] = handle_reserved, [0] = handle_int, [2 ... 3] = handle_tlb, #if !defined(LAB) || LAB \u0026gt;= 4 [1] = handle_mod, [8] = handle_sys, #endif }; 调用异常处理函数 1 2 3 4 5 6 7 8 9 10 11 .macro BUILD_HANDLER exception handler NESTED(handle_\\exception, TF_SIZE + 8, zero) move a0, sp addiu sp, sp, -8 jal \\handler addiu sp, sp, 8 j ret_from_exception END(handle_\\exception) .endm BUILD_HANDLER sys do_syscall 传参与调用内核sys_* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void do_syscall(struct Trapframe *tf) { int (*func)(u_int, u_int, u_int, u_int, u_int); int sysno = tf-\u0026gt;regs[4]; if (sysno \u0026lt; 0 || sysno \u0026gt;= MAX_SYSNO) { tf-\u0026gt;regs[2] = -E_NO_SYS; return; } tf-\u0026gt;cp0_epc += 4; func = syscall_table[sysno]; u_int arg1 = tf-\u0026gt;regs[5]; u_int arg2 = tf-\u0026gt;regs[6]; u_int arg3 = tf-\u0026gt;regs[7]; u_int arg4, arg5; arg4 = *((u_int *)tf-\u0026gt;regs[29] + 4); arg5 = *((u_int *)tf-\u0026gt;regs[29] + 5); tf-\u0026gt;regs[2] = func(arg1, arg2, arg3, arg4, arg5); } 这里可以回答后两个问题：\n用户sys中的6个参数，第一个用来对应内核sys，其他参数按照原来的顺序依次用于传参，因此数值是完全对应的。\n对于syscall后的改动：\n系统调用的（正常/异常）返回值会赋值给$2即$v0 tf-\u0026gt;cp0_epc += 4; Thinking 4.2 结合以下两段代码：\n1 2 3 4 u_int mkenvid(struct Env *e) { static u_int i = 0; return ((++i) \u0026lt;\u0026lt; (1 + LOG2NENV)) | (e - envs); } 1 2 3 #define LOG2NENV 10 #define NENV (1 \u0026lt;\u0026lt; LOG2NENV) #define ENVX(envid) ((envid) \u0026amp; (NENV - 1)) 可以知道ENVX只取了envid的后10位，也就是取了e-envs的值\n这个值反映的就是e在envs中的相对位置，所以可以用来找到这个进程。\n但是它并不构成双射。\n例如0xF01,0x801,0x401等等envid都可以对应到envs[1],但是这些envid大多是不合法的。因此必须再进行反向确认。\nThinking 4.3 这个问题不难解释。\n1 2 3 4 5 6 7 8 9 int envid2env(u_int envid, struct Env **penv, int checkperm) { struct Env *e; if (envid == 0) { *penv = curenv; return 0; } e = \u0026amp;envs[ENVX(envid)]; ... } 我们知道envid取0时，其含义即为curenv。\n因此mkenvid避免了返回0，没有进程的envid为0，从而防止在envid2env(0, \u0026amp;env, 0)时，只能取到curenv而不能取envid确实为0的进程的情况。\n而envid2env(envid, \u0026amp;env, 0)在IPC的sys_ipc_try_send中被调用，若存在envid为0的进程，将影响进程间通信的正常实现。\nThinking 4.4 答案为C。\n参见任务指导书：\n• fork 之前只有父进程存在。\n• fork 之后，父子进程同时开始执行fork之后的代码段\n以及此图：\t可以确定fork代码本身是父进程执行的。\nfork在父、子进程的返回值分别是子进程pid与0。\nThinking 4.5 一般认为，用户空间从0到USTACKTOP需要被映射。\n在env_init中:\n1 2 3 4 5 ... base_pgdir = (Pde *)page2kva(p); map_segment(base_pgdir, 0, PADDR(pages), UPAGES, ROUND(npage * sizeof(struct Page), PAGE_SIZE), PTE_G); map_segment(base_pgdir, 0, PADDR(envs), UENVS, ROUND(NENV * sizeof(struct Env), PAGE_SIZE), PTE_G); ... 进程的UPAGES与UENVS已经映射到pages与envs了，因此不需要再在duppage中进行继承。\n而一些进程临时占用的区域往往在fork时是无效的，因此也不会被复制。\nThinking 4.6 1 2 #define vpt ((const volatile Pte *)UVPT) #define vpd ((const volatile Pde *)(UVPT + (PDX(UVPT) \u0026lt;\u0026lt; PGSHIFT))) vpt就是用户页表起始位置UVPT，指针为Pte*类型，即vpt+1即指向下一页表项。\nvpd则是利用了自映射，PDX号即为页目录在二级页表中的位置。\n也可写作 #define vpd ((const volatile Pde *)UVPT + (PDX(UVPT) ))\n已知： vpn: va的前20位\tPTX：va的中间10位\tPDX：va的前10位\n则有：\tva对应的页目录项： vpd[PDX(va)]\tva对应的页表项： vpt[vpn]\n这便是用户态访问页表项的基本方法。\n进程无权修改页表项。为什么？ 在env_init中我们只额外赋予了PTE_G，\t即map_segment(base_pgdir, 0, PADDR(pages), UPAGES, ROUND(npage * sizeof(struct Page), PAGE_SIZE), PTE_G);\t详见map_segment中的page_insert中的\t*pte = page2pa(pp) | perm | PTE_C_CACHEABLE | PTE_V;。\n所以其属性只有PTE_G | PTE_C_CACHEABLE | PTE_V。\nThinking 4.7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void do_tlb_mod(struct Trapframe *tf) { struct Trapframe tmp_tf = *tf; if (tf-\u0026gt;regs[29] \u0026lt; USTACKTOP || tf-\u0026gt;regs[29] \u0026gt;= UXSTACKTOP) { tf-\u0026gt;regs[29] = UXSTACKTOP; } // 切换为异常栈 tf-\u0026gt;regs[29] -= sizeof(struct Trapframe); *(struct Trapframe *)tf-\u0026gt;regs[29] = tmp_tf; // 将异常现场tmp_tf压入栈 Pte *pte; page_lookup(cur_pgdir, tf-\u0026gt;cp0_badvaddr, \u0026amp;pte); if (curenv-\u0026gt;env_user_tlb_mod_entry) { tf-\u0026gt;regs[4] = tf-\u0026gt;regs[29]; tf-\u0026gt;regs[29] -= sizeof(tf-\u0026gt;regs[4]); // 设置栈指针为参数$a0 tf-\u0026gt;cp0_epc = curenv-\u0026gt;env_user_tlb_mod_entry; // 进入异常处理函数 // 返回epc是异常处理entry，参数tf和本函数的tf一致 } else { panic(\u0026#34;TLB Mod but no user handler registered\u0026#34;); } } 我们可以看到异常栈的使用与tf的嵌套保存实现了类似于异常重入的处理。\t当COW处理函数自身某个环节触发异常时就会触发异常重入。\n这时候，新的异常环境被压入异常栈，并被处理，返回到原异常环境，重新处理原异常。\n内核需要将异常的现场Trapframe复制到用户空间，由用户态实现现场的恢复。\nThinking 4.8 在用户态处理页写入异常，相比于在内核态：\n主观能动性更强，用户可以相对自由地控制异常的产生与处理 减少状态的切换，提高运转效率 与内核独立开来，保证内核的安全 Thinking 4.9 如果syscall_set_tlb_mod_entry的调用放置在syscall_exofork之后，甚至放置在写时复制保护机制完成之后，\tsyscall_exofork中可能产生的tlb_mod异常将没有处理函数，即panic(\u0026quot;TLB Mod but no user handler registered\u0026quot;);\n难点分析 我认为lab4的难度主要在于理解FORK和TrapFrame。\n关于系统调用，Thinking 4.1的流程解释已经相对清晰了。\n关于IPC，核心内容就是进程状态的变化，进程的切换，data的传递或页的共享。\nfork 借助于系统调用，用户态下的函数可以实现许多安全的内核操作。这避免了内核态与用户态的频繁切换，不需多余的SAVE与RESTORE。\nfork函数就是用户态下的，能够由用户主动产生新进程的函数。\n此外，fork函数通过复用异常机制，实现了COW操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int fork(void) { u_int child; u_int i; if (env-\u0026gt;env_user_tlb_mod_entry != (u_int)cow_entry) { try(syscall_set_tlb_mod_entry(0, cow_entry)); } // 填入COW异常处理函数 child = syscall_exofork(); // env_alloc + 赋值tf,pri,status // 最后额外更改 $v0 if (child == 0) { env = envs + ENVX(syscall_getenvid()); // envid中ENVX的含义 return 0; // child的fork结束 } for (i = 0; i \u0026lt; PDX(UXSTACKTOP); i++) { if (vpd[i] \u0026amp; PTE_V) { for (u_int j = 0; j \u0026lt; PAGE_SIZE / sizeof(Pte); j++) { u_long va = (i * (PAGE_SIZE / sizeof(Pte)) + j) \u0026lt;\u0026lt; PGSHIFT; if (va \u0026gt;= USTACKTOP) { break; } if (vpt[VPN(va)] \u0026amp; PTE_V) { duppage(child, VPN(va)); // 全部标记 COW } } } } syscall_set_tlb_mod_entry(child, cow_entry); syscall_set_env_status(child, ENV_RUNNABLE); // 先设置好COW异常处理函数，再RUNNABLE return child; } 这便是fork的全流程。整体看起来还比较清晰？\nTrapFrame 这是一块很大的内容，存储着进入内核态前的信息。\n陷阱帧也是栈结构，支持重入。\ntf-\u0026gt;regs是我们访问基础寄存器的途径，\t常用的有：\ttf-\u0026gt;regs[2]代表返回值\ttf-\u0026gt;regs[4..7] 代表传入参数\ttf-\u0026gt;reg[29]代表sp\n注意：可以通过*(struct Trapframe *)tf-\u0026gt;regs[29]来得到上一次保存环境时的栈帧。\n此外，tf-\u0026gt;cp0_epc 代表eret要返回到的PC。将其设置为某个函数的指针，便可以实现函数的跳转（并非调用）\ttf-\u0026gt;cp0_badvaddr代表出现异常的虚拟地址，往往在处理与内存相关的异常时有帮助。\n实验体会 理解Trapframe的过程很痛苦，哪怕是现在我也仍然有很多地方不明所以。\n在写思考题的过程中，我总是想要诉之以理，结果却连自己都无法信服。\n用户态陷入异常后，进程是否切换？此时的tf存着什么？在异常处理过程中处于内核态吗？那又如何理解“调用”用户态的函数？\u0026hellip;\n诸多谜题解决起来确实困难，但回到实验指导书重新阅读可能会有曾未发现的收获。\n","date":"2025-04-29T20:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8Efork/123_hu2251115424422531117.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8Efork/","title":"BUAA OS Lab4 系统调用与FORK"},{"content":"exam 往年题资源约等于无。只能对着学长git仓库的源码疯狂地想象题目\u0026hellip;\n个人认为lab3的exam相对来说随机性比较大，很有extra的风格。\n题面大概率是实现一种新的调度算法。\n预备任务 在实现这个任务之前，会有许多复制粘贴的操作。\n如Env结构体中新属性的增添，新的宏，新的全局变量，新的初始化等等。\n这些内容虽然都需要自己手动去改，但是代码基本都已经在题面中明确给出了。\n核心任务 新的调度算法的原理在题面上会十分详尽地讲解，容易出现bug的点与解决方法也都有加粗标志。\n题面复杂时甚至会直接给出部分实现框架。但是不能过于依赖，可能有重要的句子是没有在框架里体现出来的。\n23级题面摘要 实现RR算法与原来的时间片流转算法的混合使用。\n每个进程在建立时已经确定它采用哪种调度算法。\nRR算法可抢占时间片流转算法。时间片流转被抢占结束后会默认回到被抢占的进程。\n大家可以看一下sched.c的核心代码。\n除了我添加注释的几行，其他内容都是题面上已经把代码内容全部用文字描述了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static struct Env* lastenv = NULL; //这句话有简单引导 void schedule(int yield) { static int clock = -1; clock++; struct Env *env; LIST_FOREACH (env, \u0026amp;env_edf_sched_list, env_edf_sched_link) { if (clock == env-\u0026gt;env_period_deadline) { env-\u0026gt;env_period_deadline += env-\u0026gt;env_edf_period; env-\u0026gt;env_runtime_left = env-\u0026gt;env_edf_runtime; } }\tstruct Env *en; struct Env *min = NULL; if (!LIST_EMPTY(\u0026amp;env_edf_sched_list)) { min = LIST_FIRST(\u0026amp;env_edf_sched_list); } LIST_FOREACH (en, \u0026amp;env_edf_sched_list, env_edf_sched_link) { if (en-\u0026gt;env_runtime_left \u0026gt; 0) { if ((min-\u0026gt;env_runtime_left \u0026lt;= 0) || (en-\u0026gt;env_period_deadline \u0026lt; min-\u0026gt;env_period_deadline) || ((en-\u0026gt;env_period_deadline == min-\u0026gt;env_period_deadline) \u0026amp;\u0026amp; (en-\u0026gt;env_id \u0026lt; min-\u0026gt;env_id))) { min = en; } } } if (min != NULL \u0026amp;\u0026amp; min-\u0026gt;env_runtime_left \u0026gt; 0) { //printk(\u0026#34;%x\\n\u0026#34;, min-\u0026gt;env_id); min-\u0026gt;env_runtime_left--; // 这句话是没有提示的 env_run(min); return; } static int count = 0; struct Env *e = lastenv; //这句话是有简单引导的 //printk(\u0026#34;%x\\n\u0026#34;, e-\u0026gt;env_id); if (e == NULL || count == 0 || e-\u0026gt;env_status != ENV_RUNNABLE || yield) { if (e != NULL \u0026amp;\u0026amp; e-\u0026gt;env_status == ENV_RUNNABLE) { TAILQ_REMOVE(\u0026amp;env_sched_list, e, env_sched_link); TAILQ_INSERT_TAIL(\u0026amp;env_sched_list, e, env_sched_link); } e = TAILQ_FIRST(\u0026amp;env_sched_list); lastenv = e; //没有引导，但也不需要引导 //printk(\u0026#34;%x\\n\u0026#34;, e-\u0026gt;env_id); if (e == NULL) { panic(\u0026#34;schedule: no runnable envs\\n\u0026#34;); } count = e-\u0026gt;env_pri; } count--; env_run(e); } extra 基本上都是书写异常处理函数，可能要调整epc,或者调整指令本身。\n题面 见：\n1 https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab3-%E4%B8%8A%E6%9C%BA/lab3_extra.pdf 重要代码 不再多说，送你一段重要代码。\n这里以I型指令为例。\n1 2 3 4 5 6 7 8 9 10 11 u_long va = tf-\u0026gt;cp0_epc; Pte *pte; page_lookup(curenv-\u0026gt;env_pgdir, va, \u0026amp;pte); u_long va = PTE_ADDR(*pte) | (va \u0026amp; 0xfff); u_long kva = KADDR(pa); int *instr = (int *)kva; int opcode = (*instr) \u0026gt;\u0026gt; 26; int _base = ((*instr) \u0026gt;\u0026gt; 21) \u0026amp; 0x1f; int _rt = ((*instr) \u0026gt;\u0026gt; 16) \u0026amp; 0x1f; int imm = (*instr) \u0026amp; 0xffff; 后记 exam做了110min才过，真的是心惊胆战呢。\n刚开始是没有min-\u0026gt;env_runtime_left--;导致任务一直做不完死循环，但是这个问题读了题面很快就解决了。\n不再死循环后，我交上第一发，居然只有30分。根据测试点的正确情况，矛头指向了不同调度算法的抢占。\n我本来写的是struct Env *e = (lastenv == NULL) ? TAILQ_FIRST(\u0026amp;env_sched_list) : lastenv;\n事实上完全不应该对NULL特判。反而是你自作主张地先定为TAILQ_FIRST(\u0026amp;env_sched_list)，会被视作这个进程已经被执行过了一次的。更何况此时count == 0，第一个进程直接就被吞了。\n这个bug我第一次修复失败了，我修复的方法是：\tif (e != lastenv || e == NULL || count == 0 || e-\u0026gt;env_status != ENV_RUNNABLE || yield)\n这更是荒唐可笑的，但是e == lastenv就更不对了。\n没想到最终正解却是最简单的：\tstruct Env *e = lastenv; 在考场上啼笑皆非。\n毕竟这次extra并不难，但已经没时间了。\n事后复盘exam也不难，不容易想到的东西都已经告诉你了。个人的启示是exam往往很简单。所以首先想想最简单的语句。\n","date":"2025-04-27T11:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab3-%E4%B8%8A%E6%9C%BA/123_hu14670671952143100775.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab3-%E4%B8%8A%E6%9C%BA/","title":"BUAA OS Lab3 上机"},{"content":"实验报告 思考题 Thinking 3.1 实现自映射，也就是需要页目录作为二级页表时对应的区域是整个页表，页目录的每一页表项对应的是每一个二级页表。\n也即在pgdir中PTX的值和PDX相等的项对应的是一级页表首地址。\ne-\u0026gt;env_pgdir[PDX(UVPT)] = PADDR(e-\u0026gt;env_pgdir) | PTE_V要表达的就是这个意思，又加上了有效位。\nThinking 3.2 不可以没有data参数。\n我们先找找这个函数的使用实例吧。\n1 int elf_load_seg(Elf32_Phdr *ph, const void *bin, elf_mapper_t map_page, void *data) 首先在env_create中：\n1 2 3 4 5 6 7 8 9 struct Env *env_create(const void *binary, size_t size, int priority) { struct Env *e; try(env_alloc(\u0026amp;e, 0)); e-\u0026gt;env_pri = priority; e-\u0026gt;env_status = ENV_RUNNABLE; load_icode(e, binary, size); TAILQ_INSERT_HEAD(\u0026amp;env_sched_list, e, env_sched_link); return e; } 调用了函数load_icode()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void load_icode(struct Env *e, const void *binary, size_t size) { const Elf32_Ehdr *ehdr = elf_from(binary, size); if (!ehdr) { panic(\u0026#34;bad elf at %x\u0026#34;, binary); } size_t ph_off; ELF_FOREACH_PHDR_OFF (ph_off, ehdr) { Elf32_Phdr *ph = (Elf32_Phdr *)(binary + ph_off); if (ph-\u0026gt;p_type == PT_LOAD) { panic_on(elf_load_seg(ph, binary + ph-\u0026gt;p_offset, load_icode_mapper, e)); } } e-\u0026gt;env_tf.cp0_epc = ehdr-\u0026gt;e_entry; } 在load_icode函数中我们找到了elf_load_seg()的调用。在这次调用中，回调函数map_page函数即为load_icode_mapper()，而data参数是传入的进程指针e，在env_create中的体现则是新分配的进程e。\n我们在load_icode_mapper()函数中\n1 2 3 4 5 6 7 8 9 static int load_icode_mapper(void *data, u_long va, size_t offset, u_int perm, const void *src, size_t len) { struct Env *env = (struct Env *)data; struct Page *p; try(page_alloc(\u0026amp;p)); if (src != NULL) { memcpy((void *)page2kva(p) + offset, src, len); } return page_insert(env-\u0026gt;env_pgdir, env-\u0026gt;env_asid, p, va, perm); } 可以看到data需要用于构造页表映射，为其提供pgdir与asid信息。\n假如没有这个参数，page_insert函数就会缺少应有的参数。\nThinking 3.3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int elf_load_seg(Elf32_Phdr *ph, const void *bin, elf_mapper_t map_page, void *data) { u_long va = ph-\u0026gt;p_vaddr; size_t bin_size = ph-\u0026gt;p_filesz; size_t sgsize = ph-\u0026gt;p_memsz; u_int perm = PTE_V; if (ph-\u0026gt;p_flags \u0026amp; PF_W) { perm |= PTE_D; } int r; size_t i; u_long offset = va - ROUNDDOWN(va, PAGE_SIZE); if (offset != 0) { //第一个不完整的页的映射 if ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, PAGE_SIZE - offset))) != 0) { return r; } } // 完整的页的映射 for (i = offset ? MIN(bin_size, PAGE_SIZE - offset) : 0; i \u0026lt; bin_size; i += PAGE_SIZE) { if ((r = map_page(data, va + i, 0, perm, bin + i, MIN(bin_size - i, PAGE_SIZE))) != 0) { return r; } } while (i \u0026lt; sgsize) { // 文件大小\u0026lt;内存，将剩余的内存都写入NULL if ((r = map_page(data, va + i, 0, perm, NULL, MIN(sgsize - i, PAGE_SIZE))) != 0) { return r; } i += PAGE_SIZE; } return 0; } 因此函数考虑了：\n对于段头不页对齐的段，通过Offset将第一个不完整的页进行映射 对于文件内容未占满整页时，通过MIN来保证写入内容的长度 文件大小小于内存大小时，仍继续映射，用NULL写入剩余内存 在每一次映射都及时检查返回值并报出异常 Thinking 3.4 参见指导书：\n这里的env_tf.cp0_epc字段指示了进程恢复运行时PC应恢复到的位置。我们要运行的 进程的代码段预先被载入到了内存中，且程序入口为e_entry，当我们运行进程时，CPU将自 动从PC所指的位置开始执行二进制码。\n而CPU执行过程中用到的都是虚拟地址，因此这里的env_tf.cp0_epc也是虚拟地址。\n此外，e_entry本身的属性也是虚拟地址。\n1 2 3 4 5 6 7 typedef struct { //unsigned char e_ident[EI_NIDENT]; // ... Elf32_Addr e_entry;\t/* Entry point virtual address */ //Elf32_Off e_phoff; // ... } Elf32_Ehdr; Thinking 3.5 在genex.S中：\n0号异常处理handle_int：\n1 2 3 4 5 6 7 8 9 10 NESTED(handle_int, TF_SIZE, zero) mfc0 t0, CP0_CAUSE mfc0 t2, CP0_STATUS and t0, t2 andi t1, t0, STATUS_IM7 bnez t1, timer_irq timer_irq: li a0, 0 j schedule END(handle_int) 对于其他异常使用了宏定义同一处理方法。\t1号异常 do_tlb_mod以及\t2、3号异常 do_tlb_refill:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 .macro BUILD_HANDLER exception handler NESTED(handle_\\exception, TF_SIZE + 8, zero) move a0, sp addiu sp, sp, -8 jal \\handler addiu sp, sp, 8 j ret_from_exception END(handle_\\exception) .endm BUILD_HANDLER tlb do_tlb_refill #if !defined(LAB) || LAB \u0026gt;= 4 BUILD_HANDLER mod do_tlb_mod BUILD_HANDLER sys do_syscall #endif BUILD_HANDLER reserved do_reserved 函数的具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void do_tlb_mod(struct Trapframe *tf) { struct Trapframe tmp_tf = *tf; if (tf-\u0026gt;regs[29] \u0026lt; USTACKTOP || tf-\u0026gt;regs[29] \u0026gt;= UXSTACKTOP) { tf-\u0026gt;regs[29] = UXSTACKTOP; } tf-\u0026gt;regs[29] -= sizeof(struct Trapframe); *(struct Trapframe *)tf-\u0026gt;regs[29] = tmp_tf; Pte *pte; page_lookup(cur_pgdir, tf-\u0026gt;cp0_badvaddr, \u0026amp;pte); if (curenv-\u0026gt;env_user_tlb_mod_entry) { tf-\u0026gt;regs[4] = tf-\u0026gt;regs[29]; tf-\u0026gt;regs[29] -= sizeof(tf-\u0026gt;regs[4]); tf-\u0026gt;cp0_epc = curenv-\u0026gt;env_user_tlb_mod_entry; } else { panic(\u0026#34;TLB Mod but no user handler registered\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 NESTED(do_tlb_refill, 24, zero) mfc0 a1, CP0_BADVADDR mfc0 a2, CP0_ENTRYHI andi a2, a2, 0xff .globl do_tlb_refill_call; do_tlb_refill_call: addi sp, sp, -24 sw ra, 20(sp) addi a0, sp, 12 jal _do_tlb_refill lw a0, 12(sp) lw a1, 16(sp) lw ra, 20(sp) addi sp, sp, 24 mtc0 a0, CP0_ENTRYLO0 mtc0 a1, CP0_ENTRYLO1 nop tlbwr jr ra END(do_tlb_refill) Thinking 3.6 在entry.S:\n1 2 3 4 5 6 7 8 9 10 11 .section .text.exc_gen_entry exc_gen_entry: # 进入异常 SAVE_ALL mfc0 t0, CP0_STATUS and t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE) # IE置0，禁止一切中断 mtc0 t0, CP0_STATUS mfc0 t0, CP0_CAUSE andi t0, 0x7c # 得到同步异常码 lw t0, exception_handlers(t0) jr t0 在env_asm.S中的env_pop_tf和genex.S中的handle_\\exception都调用了genex.S定义的ret_from_exception：\n1 2 3 FEXPORT(ret_from_exception) RESTORE_ALL # 恢复寄存器的值，也即恢复时钟中断 eret # 恢复用户态 env_pop_tf的调用可以参见env_run()，即启动一个线程时，应开启时钟中断。\n因此总结来看：\n在线程启动时，时钟中断开启 线程在用户态正常运行，时钟中断保持开启 线程陷入中断或异常后，取消时钟中断 线程异常处理结束，恢复时钟中断 Thinking 3.7 首先，每一次时钟中断都会进入exc_gen_entry。\n我曾经对这个感到十分困惑，在文件夹里找了很久也没有找到，到底是谁调用了exc_gen_entry\u0026hellip;\n直到我扒到kernel.lds。\n我突然明白：这就是PC地址啊！\t检测中断，跳转PC这些事，都是我们P7硬件所实现的啊！\n到达exc_gen_entry不需要函数调用的入口！它就是CPU当前PC执行的指令！\n接下来思路畅通无阻。\nexc_gen_entry进入内核态，检测异常信息，并进行handle_int的跳转。\nhandle_int的最后一句便是j schedule调用schedule函数。\nschedule函数：\n不切换进程时就进行count\u0026ndash;,然后继续env_run\ncount减为零或其他三个条件之一满足时\n进行进程的切换: 若当前进程未执行完毕，就移到队尾 若执行完毕会触发env_destroy无需处理 接着取出队首进程进行执行 若已无执行进程则panic 设置count的值，并进行count\u0026ndash;与env_run 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void schedule(int yield) { static int count = 0; struct Env *e = curenv; if (e == NULL || count == 0 || e-\u0026gt;env_status != ENV_RUNNABLE || yield) { if (e != NULL \u0026amp;\u0026amp; e-\u0026gt;env_status == ENV_RUNNABLE) { TAILQ_REMOVE(\u0026amp;env_sched_list, e, env_sched_link); TAILQ_INSERT_TAIL(\u0026amp;env_sched_list, e, env_sched_link); } e = TAILQ_FIRST(\u0026amp;env_sched_list); if (e == NULL) { panic(\u0026#34;schedule: no runnable envs\\n\u0026#34;); //Panic if the list is empty } count = e-\u0026gt;env_pri; } count--; env_run(e); } 难点分析 本次lab3主要分为进程与异常两部分，但异常的实现也建立在进程上，因此核心处理的问题就是进程。\n进程的建立 mkenvid: 创建一个独一无二的标识符\nasid_alloc: 分配一个asid标识\nmap_segment: 创建页的映射\nenv_init: 初始化进程管理系统的数据结构\n初始化链表： env_free_list：使用 LIST_INIT 初始化空闲进程链表。\tenv_sched_list：使用 TAILQ_INIT 初始化调度进程队列。 初始化所有环境： 遍历 envs 数组，将每个进程的状态设置为 ENV_FREE。\t将这些进程插入到 env_free_list 中，且顺序与 envs 数组中的顺序一致。 映射内核数据结构到用户空间： 分配一个页作为基础页目录 base_pgdir。\t将内核的 pages 和 envs 数组映射到用户空间的 UPAGES 和 UENVS 区域，权限为只读（PTE_G）。 env_setup_vm: 为给定的进程 e 初始化用户地址空间。\n分配页目录并复制模板： 分配一个物理页作为页目录，将页的内核虚拟地址赋给 e-\u0026gt;env_pgdir。\t从 base_pgdir 复制 [UTOP, UVPT) 部分的页目录项到 e-\u0026gt;env_pgdir。这样所有进程的内核部分地址空间是一致的。 自映射页表： 将进程的页目录映射到 UVPT，使得用户进程可以通过 UVPT 读取自己的页表（只读权限）。 env_alloc: 分配并初始化一个新的进程\nload_icode_mapper: 实现段的映射与复制\nload_icode: 加载可执行文件，并初始化进程入口\nenv_create: alloc + 属性设置 + 文件加载 + env_sched_list 插入\n进程的启动 env_pop_tf: 恢复用户态执行上下文\n1 2 3 4 5 mtc0 a1, CP0_ENTRYHI move sp, a0 RESET_KCLOCK RESTORE_ALL eret env_run: 切换到目标用户进程并执行\n如果当前有正在运行的进程（curenv != NULL），保存其上下文到 curenv-\u0026gt;env_tf。\n其中KSTACKTOP 是内核栈的顶部地址，则\t(struct Trapframe *)KSTACKTOP - 1 指向内核栈中保存的 Trapframe（即当前进程的寄存器状态）\t将内核栈中的 Trapframe 复制到 curenv-\u0026gt;env_tf，以便后续恢复。\n然后切换进程、切换页表、恢复当前进程对应的上下文\n进程的结束 env_free: 释放一个线程。\n具体实现中要清除的内容还是蛮复杂的: 遍历页表并释放物理页、释放页表和页目录、释放 ASID、刷新 TLB、放回空闲链表\nenv_destroy: 若当前进程就是要被destroy的，需要再进行schedule\n进程的异常 异常的识别由硬件实现，硬件会直接把PC跳转到entry。\n异常入口: 保存上下文，进入内核态，得到异常类型，跳转到异常处理函数\n异常处理函数: 见Thinking 3.5\n实验体会 本次实验相较于Lab2，用到的宏数量有所降低。此外，许多宏在Lab2就有所接触，因此上手起来比Lab2要更顺利一点。\n由于Lab2中的page_alloc()是可以失败的，而lab3的进程又高度依赖页面，因此在Lab3中较多地使用了try()与panic()宏。\nLab3的异常处理和P7明明讲的是同一件事，却完全是两套内容。然而软硬两套内容的内部逻辑如此自洽，以至于我惊讶于当前OS的实现原来也离不开CO的异常判断；也从未想过学CO时所谓的异常处理函数并不是简简单单的六个字。\n目前我对于load_icode的理解还不够深入，只是能接受这个函数。面对lab3的丰富函数，不理一下调用场景与逻辑，难免会感到迷茫。\n望一切顺遂。\n","date":"2025-04-18T20:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BC%82%E5%B8%B8/123_hu18081601262862879330.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BC%82%E5%B8%B8/","title":"BUAA OS Lab3 进程与异常"},{"content":"迭代过程综述 请求的迭代 第一次作业：PersonRequest 第二次作业：ScheRequest 第三次作业：UpdateRequest\n分配的迭代 第一次作业：指定分配 第二次作业：手动分配、SCHE静默 第三次作业：Update静默、高低楼层分配\n运行的迭代 第一次作业：LOOK 第二次作业：专属SCHE运行 第三次作业：专属UPDATE运行、重写MOVE方法\n输出的迭代 第一次作业：ARRIVE/OPEN/OUT/IN/CLOSE 第二次作业：SCHE、RECEIVE以及OUT-F/S 第三次作业：UPDATE\n迭代分析 作业核心内容 hw5核心实现：\n生产者消费者模型 LOOK算法 hw6核心实现：\n调度器 SCHE策略 hw7核心实现：\nUPDATE策略 强制中转 双轿厢的同步与互斥 UML类图 红色为hw5，绿色为hw6，蓝色为hw7\n其中对于RequestCoordinator，每个电梯都有一把这样的锁，当电梯没有request时，就会调用这个里的条件变量的wait,也即封装好的waitForRequest()函数。被唤醒则通过分发线程分给各个Queue后触发唤醒。\nsequence 电梯线程的run方法： 主线程(?)的main方法： 稳定与易变 稳定： 生产者消费者模型的整体框架与类的构建 strategy中的LOOK算法 poll、open、setEnd等基本函数的实现\n易变： 具体的运行方法，如doubleGo()、sche()、update() 电梯的属性要不断增添以适应需求\n整体感受下来， hw5是初识多线程、生产者消费者模型与LOOK算法，主要是接受多线程的并发感，掌握一对一的通信方法（End的实现）\nhw6开始出现单锁双开：不再是一对一的通信，scheRequest与personRequest都能让正在wait的电梯苏醒。\nhw7则出现了更加复杂的线程通信。主要体现在同类对象同一方法过程中的互相通信。如果不做好同步就擅自拿锁，很容易触发死锁。\n同步块的设置和锁的选择 在第一次作业中，我基本掌握了synchronize块的用法，配套使用wait与notify。到了第二次作业，我突然决定尝试使用读写锁。在自学了条件变量及其await和signal后，我由于不熟悉、不确定而深受其扰，也常常感到后悔为何要自作主张，但逐渐地，也终于感受到了读写锁的清晰与直白。\n在两者的关系上： 同步块其实是隐式使用了对象的内置锁 而显式锁可以跨方法使用，可以设置公平性，还更加清晰易读。\n条件变量的引入与传递也极大便利了线程之间的通信。\n调度器设计 虽然我采用了随机分配的策略，但是在正确性上要考虑的问题依旧存在。\n被SCHE/UPDATE时不能RECEIVE 在调度器中当然需要拿到电梯的相关信息，六部电梯Elevators是调度器的属性之一。\n但是在判断到isSche()后，我并不采用重新选电梯的方法，而是用wait方法等待这个电梯SCHE结束，再把那个任务分配给电梯。\n这样写自然是有缺陷的，你的调度器线程居然为了一个随机分配的结果而等待？ 但是正相对地，他保证了分配结果一定是完全随机的。（hw6 mid5的教训） 此外，随机性也导致等待这一现象的发生也是随机的，并不容易导致调度器被恶意阻塞。\n不能RECEIVE我接不到的人 一旦你被升级，且RECEIVE了你接管范围外的人： 在接到这个人之前，你将没有机会把RECEIVE转让。 而你也并不能接到这个人。\n在这里，我则强制让它的伙伴来接。\n何为范围外：\n1 2 3 4 5 6 7 8 9 10 11 12 private boolean cannotArrive(Elevator elevator, PersonRequest request) { boolean upperCannot = (getFloorNumber(request.getFromFloor()) \u0026lt; elevator.getTransferFloorNumber()) || (getFloorNumber(request.getFromFloor()) == elevator.getTransferFloorNumber() \u0026amp;\u0026amp; getFloorNumber(request.getToFloor()) \u0026lt; getFloorNumber(request.getFromFloor())); boolean lowerCannot = (getFloorNumber(request.getFromFloor()) \u0026gt; elevator.getTransferFloorNumber()) || (getFloorNumber(request.getFromFloor()) == elevator.getTransferFloorNumber() \u0026amp;\u0026amp; getFloorNumber(request.getToFloor()) \u0026gt; getFloorNumber(request.getFromFloor())); return ((elevator.isUpper() \u0026amp;\u0026amp; upperCannot) || (!elevator.isUpper() \u0026amp;\u0026amp; lowerCannot)); } 同步与防撞设计 在这两处上我都是用了信号+while+sleep的方法。 他看起来很像轮询，但他可慢太多了，循环的次数不会超过15次。\n同步启动UPDATE 当电梯满足UPDATE条件时，我会设置该电梯的canUpdate属性为true。 当upper电梯已经setCanUpdate(true)，试图发送UPDATE-BEGIN之前， 在大家准备sleep(1000)之前， 便会经历\n1 2 3 4 5 6 7 8 try { canStartUpdate = true; while (!other.getCanStartUpdate()) { //System.out.println(othId + \u0026#34; is closing\u0026#34;); Thread.sleep(50); } } catch (InterruptedException e) { throw new RuntimeException(e); } 电梯防撞 我将transferFloor楼层的运转高度规范化。\n对于advice为GO时，会根据当前电梯是否为双轿厢而执行go()或doubleGo()\ndoubleGo()存在一个判断，就是你是不是正在前往transferFloor。\n如果不是就正常go，如果是的话，会触发：\n1 2 3 while (other.curFloor.equals(transferFloor)) { halt(100); } 和一个tryToGo()操作。\ntryToGo()会直接先把电梯的楼层设置为transferFloor，避免撞车。接着进行睡200与输出ARRIVE，接着进行开门放人与进人，接着关门和离开这一楼层，最后再更新电梯楼层。\n核心目标就是transferFloor的操作要尽可能的规范与固定，这样虽然死板，但是可控性很强。\nBUG与DEBUG 不忍提及。本次作业的滑铁卢是我始料未及的，也许从我放弃搭评测机的那一刻就决定了\u0026hellip;\n没有评测机的话，我只能识别出最基本的RTLE与CTLE。\nhw5没有什么好说的。 hw6已经初现端倪：强测1bug，互测1bug hw7的bug已经数不胜数了。\n这其中最最重要的原因，就是DispatchThread的终结控制。 实际上，这可能是我这一整次迭代作业最大的败笔。\n一般来说，应当设置一个计数器，记录request的完成情况。没有完成就不要让分发线程终结。对于需要重新分发的请求，只需要扔回分发线程即可。\n可我并非如此。\n我所有的OUT-F、SCHE、UPDATE导致的无效化，全部都是手动分配电梯，手动输出RECEIVE。\n这么做的漏洞： RECEIVE重复！\n可能你一个任务被dispatch分发给了电梯A，而电梯A自身的RECEIVE逻辑与dispatch并没有沟通交流，使得电梯A极有可能把dispatch给他的新请求当作无效请求分配出去。除此之外，其他电梯给电梯A分配的新请求在某种时机下也会被重新分配。\n但是只要交给dispatch，RECEIVE一定能在这个电梯离开无效状态后才会分配给他。\n其实本质上就是，自己由于对死锁的畏惧，并没有增添电梯对分发线程的信息获取。\n直到bug修复阶段，经过评测机的重重评测，我在重构了receive和发现隐藏bug后，终于实现了稳定通过bug修复。\n评测机是必要的！OOU2不能没有评测机！\n心得体会 今天回顾了OOU1的单元总结。哈，还真是高高在上呢。\n直到现实重击才清醒过来吗？优美的层次化结构并不是轻易就能实现的。\n在bug修复的重重测试之下，终于交出一份满意答卷后，方才意识到自己的问题，竟在于没有做好elevator到requestQueue的回撤，导致自己自行添加了混乱的数据线，毁坏了原有的逻辑链条。在大家都在de撞车、de静默状态RECEIVE的同步问题时，我却在为自己特有的无意义实现而缝缝补补。\n层次化结构很重要，也很值得考量。要在局部书写的时候尽力保有全局观。\n至于线程安全，我认为线程之间的通信接口主要就是getter与setter，只是取当前时间的情况进行策略决断，可以避免长时间占用锁。\n此外避免死锁可以通过规避相互调用。尤其是在两个同类线程在相互上锁的时候，死锁率极高。因此一般考虑用对地位不等、也就是不会相互调用的两个对象上锁，例如在做receive回撤的时候，就直接返回到allrequest中，对它上锁当然是不会死锁的。\n在电梯反复运行中感受时间的流逝，从线程的独立与交融中培养多核大脑。\n","date":"2025-04-17T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-oo-u2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%B5%E6%A2%AF/123_hu11594760490529333566.png","permalink":"https://demiurge-zby.github.io/p/buaa-oo-u2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%B5%E6%A2%AF/","title":"BUAA OO U2 多线程与电梯"},{"content":"exam 参考往年题总是有帮助的。\n21级 参考博客 (点击查看题面)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 u_int page_perm_stat(Pde *pgdir, struct Page *pp, u_int perm_mask) { u_int count = 0; for (u_int i = 0; i \u0026lt; (1u \u0026lt;\u0026lt; 10); i++) { Pde *pgdir_entryp = pgdir + i; if (*pgdir_entryp \u0026amp; PTE_V) { Pte *pte = (Pte *) KADDR(PTE_ADDR(*pgdir_entryp)); for (u_int j = 0; j \u0026lt; (1u \u0026lt;\u0026lt; 10); j++) { Pte *pte_entryp = pte + j; if ((*pte_entryp \u0026amp; PTE_V) \u0026amp;\u0026amp; (*pte_entryp \u0026amp; perm_mask) == perm_mask) { if (pa2page(PTE_ADDR(*pte_entryp)) == pp) count++; } } } } return count; } 你需要掌握：\n如何对页表进行遍历 一些判断条件的写法（有效性判断、权限位判断、物理页判断） 22级 未找到题面，但内容相对简单，不难看懂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 u_int page_filter(Pde *pgdir, u_int va_lower_limit, u_int va_upper_limit, u_int num) { u_int begin = va_lower_limit; u_int end = va_upper_limit; struct Page *cur_page; u_int count = 0; for (u_int addr = begin; addr \u0026lt; end; addr += PAGE_SIZE) { cur_page = page_lookup(pgdir, addr, NULL); if (cur_page != NULL \u0026amp;\u0026amp; cur_page-\u0026gt;pp_ref \u0026gt;= num) { ++count; } } return count; } 你可以先试着读一读。\n你需要掌握：\n如何遍历某虚拟地址范围内的物理页 注意到page_lookup(pgdir, addr, NULL)中的NULL，思考一下为什么可以用NULL 23级 先来看题面，试着自己想一想！\n实现u_int page_conditional_remove(Pde *pgdir, u_int asid, u_int perm_mask, u_long begin_va, u_long end_va)\n操作：\t在从begin_va到end_va的虚拟地址对应的所有页表项中，删除 权限位与perm_mask交集非空的表项 的映射。\n返回值：\t删除的映射数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 u_int page_conditional_remove(Pde *pgdir, u_int asid, u_int perm_mask, u_long begin_va, u_long end_va) { struct Page *cur_page; Pte *pte_entryp; u_int count = 0; for (u_long addr = begin_va; addr \u0026lt; end_va; addr += PAGE_SIZE) { cur_page = page_lookup(pgdir, addr, \u0026amp;pte_entryp); if (cur_page != NULL \u0026amp;\u0026amp; (*pte_entryp \u0026amp; perm_mask) != 0) { page_decref(cur_page); tlb_invalidate(asid, addr); *pte_entryp = 0; count++; } } return count; } 你问我怎么知道要page_decref(cur_page);,tlb_invalidate(asid, addr);和*pte_entryp = 0;？\n考场是有HINT的！提示你模仿page_remove()函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void page_remove(Pde *pgdir, u_int asid, u_long va) { Pte *pte; /* Step 1: Get the page table entry, and check if the page table entry is valid. */ struct Page *pp = page_lookup(pgdir, va, \u0026amp;pte); if (pp == NULL) { return; } /* Step 2: Decrease reference count on \u0026#39;pp\u0026#39;. */ page_decref(pp); /* Step 3: Flush TLB. */ *pte = 0; tlb_invalidate(asid, va); return; } 笔者第一次提交就是没有认真参考这个函数，导致漏写*pte_entryp = 0;\n那么你应当知道：\tcur_page = page_lookup(pgdir, addr, \u0026amp;pte_entryp); 这时候为什么不是NULL？\t因为你需要用到这个页表项的信息了，仅仅拿到cur_page是不够的。\n经过简单的练习， 相信你应该没有那么畏惧lab2_exam了！\nextra 还是老样子，我直接给出题面和我的代码。\n由于我曾经没能正视lab2上机，认为通过exam就很难了，因此刚开始看到extra这么全新背景且高度系统化的题面，只是抱着尽力做一做，而不是一定要拿下的态度。\t等到发现它并没有那么难时，时间也流逝得差不多了。\n这次extra相较于往年，更多地考查了对宏定义的运用，函数操作过程完全依据题意。\t而往年改写函数的套路则直接用在了exam上。\n往年题extra就像笔者的lab1_extra一样，例如page_alloc改写为buddy_alloc、swap_alloc\n题面 见：\n1 https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab2-%E4%B8%8A%E6%9C%BA/lab2_extra.pdf 解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 void *malloc(size_t size) { /* Your Code Here (1/2) */ size_t true_size = ROUND(size, 8); struct MBlock *cur; LIST_FOREACH(cur, \u0026amp;mblock_list, mb_link) { if (cur-\u0026gt;size \u0026gt;= true_size \u0026amp;\u0026amp; cur-\u0026gt;free == 1) { if (cur-\u0026gt;size - true_size \u0026lt; 32) {\tcur-\u0026gt;free = 0; return cur-\u0026gt;ptr; } size_t leave = cur-\u0026gt;size - true_size - 24; cur-\u0026gt;size = true_size; struct MBlock* newMBlock = (struct MBlock*)(cur-\u0026gt;ptr + true_size); newMBlock-\u0026gt;size = leave; newMBlock-\u0026gt;free = 1; newMBlock-\u0026gt;ptr = (void*) newMBlock-\u0026gt;data; LIST_INSERT_AFTER(cur, newMBlock, mb_link); cur-\u0026gt;free = 0; return cur-\u0026gt;ptr; } } return NULL; } void free(void *p) { /* Your Code Here (2/2) */ if (p \u0026lt; HEAP_BEGIN + MBLOCK_SIZE || p \u0026gt; HEAP_BEGIN + HEAP_SIZE) { return; } void *nowp = p - MBLOCK_SIZE; struct MBlock* now = (struct MBlock*)nowp; if (now-\u0026gt;ptr != now-\u0026gt;data || now-\u0026gt;free == 1) { return; } struct MBlock* next = LIST_NEXT(now, mb_link); if (next != NULL \u0026amp;\u0026amp; next-\u0026gt;free == 1) { now-\u0026gt;size += 24 + next-\u0026gt;size; now-\u0026gt;ptr = now-\u0026gt;data; now-\u0026gt;free = 1; LIST_REMOVE(next, mb_link); } if(now != LIST_FIRST(\u0026amp;mblock_list)) { struct MBlock* prev = MBLOCK_PREV(now, mb_link); if (prev-\u0026gt;free == 1) { LIST_REMOVE(now, mb_link); prev-\u0026gt;size += 24 + now-\u0026gt;size; prev-\u0026gt;ptr = prev-\u0026gt;data; return; } } now-\u0026gt;free = 1; return; } 笔者这次lab2_extra是失败的，上述代码是开放lab2_extra线下评测（不记分数）后经过修改的版本。\n笔者虽然拿了30分，但其实代码的问题很可怕。\n13行的struct MBlock* newMBlock = (struct MBlock*)(cur-\u0026gt;ptr + true_size);\t笔者将true_size误写成了size，也就是没有经过对齐的size\t这看起来很微不足道，但很致命。\n反倒是笔者的室友，只是把mb_link都写成了field导致过不了编译，事后修改完直接满分更显遗憾。\n后记 目前对extra题有一些小小的感受。\t你看往年题的extra是看不懂一点的，\t但是真上机了你又能一点点磨出来。\t我觉得是题目引导+考场氛围共同作用吧\n所以可能确实没必要对着往年的extra深研（？）\n此外，笔者在本周，遭遇了OOhw7的重创。C房要交10次才能拿到base，可是再刀下去可能就会无意形成恶意hack。\n此外，笔者现在正在经历北京13级狂风。但是貌似学校这里的风并不是很大。\n此外，蓝桥杯也顺利延迟了。可是大英赛没有延迟。但是笔者没报大英赛。\n","date":"2025-04-13T11:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab2-%E4%B8%8A%E6%9C%BA/123_hu12266348634778516995.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab2-%E4%B8%8A%E6%9C%BA/","title":"BUAA OS Lab2 上机"},{"content":"实验报告 思考题 Thinking 2.1 在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址。 MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟地址。\n参见实验指导书：\n在计算机组成原理等硬件实验中，CPU 通常直接发送物理地址，这是为了简化内存操作，让大家关注 CPU 内部的计算与控制逻辑。而在实际程序中，访存、跳转等指令以及用于取指的 PC 寄存器中的访存目标地址都是虚拟地址。我们编写的 C 程序中也经常通过对指针解引用来进行访存，其中指针的值也会被视为虚拟地址，经过编译后生成相应的访存指令。\nThinking 2.2 用宏实现链表的好处 首先，在可重用性上自然是能够被多次反复使用，便于代码书写与阅读。 其次，宏相较于函数，其自由度大大增加。它可以支持不同数据类型的链表，因为其本质上只是字符串替换，可操作性更强。 第三，宏不是函数调用，不需额外占用函数栈空间。\n比较单向、双向、循环链表 由于 /usr/include/sys/queue.h 里面的双向链表和我们自己实现的差别不大，因此都使用了/usr/include/sys/queue.h的进行对比分析。\n单向链表： 双向链表： 循环链表： 可以看出，在结构体定义上，单向链表与双向链表都只需要头指针，而循环链表需要头尾两个指针； 在link定义上，单向链表只有next，而双向链表与循环链表都有next与prev。\n需要注意的是：循环链表的next与prev都是数据的指针，而双向链表的prev是前一数据的next指针的指针！\n在功能性上的差异在此不再赘述了，实现的功能越多，效率上可能就会有折损。\n插入 单向链表只能实现插入到某个节点之后，但相应的语句也只有两条。 双向链表能够实现插入到前、后两种位置，但是每个方法都需要四条语句。 循环链表能实现插入到前、后两种位置，需要的语句更加复杂。 此外，循环链表出了插入到HEAD之外，还有独有的插入到TAIL 删除 三种链表在删除上的区别更加显著： 单向链表要想删除某个结点，必须通过遍历来定位好他的位置，才能让它前面的结点链接上它后面的结点。 而双向链表可以直接知晓其前一结点的next指针，因此只需要O(1)的操作 循环链表也是O(1)的，但是对于head指针要特殊处理。 整体来看，双向链表是权衡了时间复杂度与空间复杂度的不错设计，性能优良。\nThinking 2.3 选择C项。\n接下来分析一下Page_list的结构。\nPage_LIST_entry_t 结合 与 得知\n1 2 struct Page *le_next; struct Page **le_prev; 构成了结构体Page_LIST_entry_t。\nPage 接着根据 得知\n1 2 struct Page_LIST_entry_t pp_link; u_short pp_ref; 构成了结构体struct Page。\nPage_list 根据 与 得知\n1 struct Page *lh_first; 构成了结构体struct Page_list。\nAnswer 经过整理总结，也即：\n1 2 3 4 5 6 7 8 9 struct Page_list{ struct { struct { struct Page *le_next; struct Page **le_prev; } pp_link; u_short pp_ref; }* lh_first; } Thinking 2.4 根据任务指导书：\nASID：Address Space IDentifier 用于区分不同的地址空间。 查找 TLB 表项时，除了需要提供 VPN，还需要提供ASID 同一虚拟地址在不同的地址空间中通常映射到不同的物理地址\n在多进程操作系统中，每个进程都有自己独立的虚拟地址空间。ASID 作为唯一的标识符，要用于区分不同进程的地址空间。\nASID通常为8位，即有256种ASID，就可以支持256个不同的地址空间。\nThinking 2.5 调用关系显然： tlb_invalidate函数通过调用tlb_out函数，把va对应的页表项清空。 其中(va \u0026amp; ~GENMASK(PGSHIFT, 0)) | (asid \u0026amp; (NASID - 1)) 是传入的参数，也就是$a0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 LEAF(tlb_out) # 定义为叶函数，这决定了它的栈帧结构 .set noreorder # 确保指令按照代码中的顺序依次执行 # 保存和修改 CP0_ENTRYHI 寄存器 mfc0 t0, CP0_ENTRYHI # 保存 CP0_ENTRYHI 寄存器 mtc0 a0, CP0_ENTRYHI # 修改 CP0_ENTRYHI 寄存器 nop tlbp # 查找与 ENTRYHI 寄存器中值匹配的条目，存入CP0_INDEX nop mfc0 t1, CP0_INDEX # 取出index .set reorder # 即将有分支跳转，允许汇编器对指令进行重新排序 bltz t1, NO_SUCH_ENTRY # index == -1 即不存在对应的tlb .set noreorder # tlb表项存在，继续顺序执行 mtc0 zero, CP0_ENTRYHI # 清空 mtc0 zero, CP0_ENTRYLO0 # 清空 mtc0 zero, CP0_ENTRYLO1 # 清空 nop tlbwi # 把这些值写入tlb，也就是清空该tlb表项 .set reorder # 不管 tlbp 指令是否找到匹配的 TLB 条目 # 执行完 tlbwi 之后 # 程序最终都会恢复 ENTRYHI 寄存器的值 # 并且返回到调用者处 NO_SUCH_ENTRY: mtc0 t0, CP0_ENTRYHI # 恢复CP0_ENTRYHI j ra # 返回到tlb_invalidate函数 END(tlb_out) 参考： Thinking A.1 页面大小4KB，页内偏移为12位。\n一级页表指向512个二级页表，每个二级页表指向512个三级页表。\n若三级页表的基地址为PTbase， 则三级页表页目录的基地址应当是PTbase + PTbase\u0026raquo;9\n映射到页目录自身的页目录项地址为PTbase + PTbase\u0026raquo;9 + PTbase\u0026raquo;18\nThinking 2.6 函数调用需要开启进程，env_init就需要pgdir_alloc为其分配页。 load_icode在加载进程指令代码时，需要page_alloc和page_insert为加载二进制代码到内存而分配物理页并建立映射。 当进程结束或内存区域不再使用时使用env_free，需要page_remove从页表移除相关映射，page_decref减少物理页引用计数。 Thinking 2.7 X86 存在逻辑地址、线性地址和物理地址三种地址。 逻辑地址由段基址和偏移量构成，是程序直接使用的地址。 通过分段机制，逻辑地址转换为线性地址； 再利用分页机制，线性地址转换为物理地址用于实际访存。\n比较来说，X86有分段和分页两层地址转换，先分段后分页； MIPS主要是分页机制，内存管理粒度更统一。\n难点分析 本次实验整体来说看还是蛮大的，从物理内存到虚拟内存再到TLB，形成了综合的一体化架构。\npmap.c pmap.c是本次实验最核心的文件之一。主要函数如下：\nmips_detect_memory: 得知可用物理页数\nalloc：增大freemem，返回申请的物理空间\nmips_vm_init：为两级页表alloc物理空间\npage_init：把物理空间划分为物理页，根据freemem区分已用页与未用页，并将未用页都放进page_free_list\npage_alloc：从page_free_list申请物理页\npage_free：将物理页放回page_free_list\npgdir_walk：得到va对应的二级页表中的对应项的索引\npage_insert：建立pgdir_walk找到的项与物理页的映射\npage_lookup：找到va对应的物理页\npage_decref：降低物理页引用次数，降低到0时自动执行page_free\npage_remove：降低va对应物理页的引用次数，并清空va对应的TLB表项\n其中关于Pde、Pte指针的阅读理解难度比较大，并且涉及到大量的头文件，需要反复阅读pmap.h与queue.h才能解决问题。\nTLB 关于TLB表项的清空与重填，我们主要进行阅读与理解的工作。\n由于TLB miss，do_tlb_refill被触发。 do_tlb_refill为_do_tlb_refill传参 _do_tlb_refill调用tlb_invalidate进行TLB清空 _do_tlb_refill寻找page并进行页表重填 _do_tlb_refill返回值用于do_tlb_refill重填TLB 实验体会 第一次接触这些内容的时候，会感受到一片茫然。不过实验指导书从内到外的引导还是很到位的，跟着指导书读完源代码后，基本上知道内存管理干了什么事，是如何实现的。\n在具体实现代码内容的时候，基本上是被HINT牵着走，没有HINT的话，我也确实不能直接明白该怎么去实现具体的功能。\nLab2只顺着过一遍大抵是会忘光的。如果能够为所有的函数都写上自己的注释，可能理解会更加深入一点。\n近期事务很多很乱，如果能像解决Lab2的诸多函数一样，逐个攻克，希望会有好的结果。\n","date":"2025-04-05T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/jpg_hu9259821900430245864.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"BUAA OS Lab2 内存管理"},{"content":"exam exam难度相较上次已大幅降低，如果lab1本身实现没有问题，再看过一点点学长博客或代码，基本就约等于点击即送了。\n在此统计一下近三年的exam。再往前lab1就主要学习readelf，考核点不在于vprintfmt了。\n近三年的exam均采用了新增%\u0026hellip;[字母]的形式，也不必担心新的字母有什么新的实现，一般就是%d,%s,%c等等的组合罢了。\n21级：%R 21级（2023上机）：\n实现 %...R:\t%...R等价于(%...d,%...d)\n所以只需要\n1 2 3 4 5 6 7 8 case \u0026#39;R\u0026#39;: print_char(out, data, \u0026#39;(\u0026#39;, 0, 0); //... 照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;,\u0026#39;, 0, 0); // width可无脑取0，因为width是最小长度限制，大于此长度不会截断 //... 再次照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;)\u0026#39;, 0, 0); break; 不用畏惧两个参数，无非是两次va_arg，照搬两次case \u0026rsquo;d\u0026rsquo;的内容的时候都是实现了的。\n具体可参见nr的博客 (点击阅读)\n22级：%P 22级堪称与21级一模一样，唯一的改变是读两个参数需要输出三个数：\n%...P等价于(%...d,%...d,%...d)\n读取两个数x,y\t输出三个数x,y,z\t其中z=(x+y)*(x-y)\n记不大清了，反正只是x,y某种简单计算后的结果\n所以也只需要\n1 2 3 4 5 6 7 8 9 10 case \u0026#39;P\u0026#39;: print_char(out, data, \u0026#39;(\u0026#39;, 0, 0); //... 照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;,\u0026#39;, 0, 0); // width可无脑取0，因为width是最小长度限制，大于此长度不会截断 //... 再次照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;,\u0026#39;, 0, 0); //... 再再次照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;)\u0026#39;, 0, 0); break; 需要注意的是，第三次照搬就不需要通过va_arg了，而是直接计算出来。\nMYGO!!!!! : %k 我们的上机相较过去有一定的突破，但也不多：\t%...k等价于%...s =\u0026gt; %...d\n但是%...k中的...的属性并不是全部无脑分配给%s与%d了\n这些属性具体给谁按照题意要求即可\n其实也只需要\n1 2 3 4 5 6 case \u0026#39;k\u0026#39;: //... 照搬case \u0026#39;s\u0026#39;的内容 print_str(out, data, \u0026#34; =\u0026gt; \u0026#34;, 0, 0); // 这里width还可以可无脑取0 //... 照搬case \u0026#39;d\u0026#39;的内容 break; 如果lab1不出意外还出这类题的话，相信你看完这些讲解，应当是能直接秒杀了。\n这里给你一点更快的建议：\nnyy可以复制自光标起的n行 p可以实现粘贴 在实验报告中也提到过的，print_char,print_num,print_str之类的函数也可以提前了解一下\textra 本次extra题考验你C语言指针功夫！\n其实和往年题也比较类似的：\t考查你对out函数的理解。\n一般来说都会设置一个比较新的背景，\n21级的sprintf写入到字符串 22级的模仿print写scan 23级的fmemprintf写入到内存信息流 本质上都是仿照着kern/printk.c来书写\nHINT也会提示你去参考这个函数（）\n核心的方法就是写一个新的out函数\n因为调用vprintfmt的时候，最终都是落实到out函数上，vprintfmt主要做的就是格式解析的工作。因此只需要写好自定义out函数，就能实现自定义支持格式的新功能。\n其他的内容在此不愿详细解释，大家根据题面与HINT努力实现就好，都是一些很简单的，功能明确的C函数。（大多数人挂都是这些环节的C语言bug）\n题目背景：\tFILE*结构体：\tchar *base; 基地址（起始地址） char *ptr; 写地址（当前地址） char *end; 末地址\n可以理解为FILE*掌管着一段字符串以及一个用于操作的指针\n下面是实现的五个函数，其中四个函数是明确要求的必需函数，还有一个是实现过程中需要自主实现并调用的。\nfmemopen 笔者debug了30min便在于strcmp前面忘加!\nOS的debug难度实在太大。 当你出现错误，你得不到任何有效信息，有可能就只是make run之后系统卡死\t如果错的不那么错误（例如我这样），也许会返回一个无厘头的错误结果，但事实上这个结果反而误导了我的debug过程\nfmemoutput(此函数为自主命名实现) fmemprintf fseek fclose 后记 在OOU2hw5电梯、冯如杯、lab2等多项繁杂事务的强压之下，居然还能抽出时间点开这篇文章复习OS的lab1，真切希望我的内容可以帮助到你！！！\n大概率很多人是没有怎么看extra的代码的，因为确实没必要看。 在这里放出来，是希望大家能对extra的整体代码量与实现难度有一定基础的认知。\n祝上机顺利！\n","date":"2025-03-28T11:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab1-%E4%B8%8A%E6%9C%BA/123_hu17637424243101368024.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab1-%E4%B8%8A%E6%9C%BA/","title":"BUAA OS Lab1 上机"},{"content":"实验报告 思考题 Thinking 1.1 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 1; int b = 2; int c = a + b; printf(\u0026#34;%d\\n\u0026#34;,c); return 0; } gcc 与 readelf 可以发现readelf在不使用mips交叉编译工具链的时候也可以正确阅读由mips交叉编译工具链编译得到的内容。\nobjdump 用原生x86的objdump反编译gccmain.o结果如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 gccmain.o： 文件格式 elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 83 ec 10 sub $0x10,%rsp c: c7 45 f4 01 00 00 00 movl $0x1,-0xc(%rbp) 13: c7 45 f8 02 00 00 00 movl $0x2,-0x8(%rbp) 1a: 8b 55 f4 mov -0xc(%rbp),%edx 1d: 8b 45 f8 mov -0x8(%rbp),%eax 20: 01 d0 add %edx,%eax 22: 89 45 fc mov %eax,-0x4(%rbp) 25: 8b 45 fc mov -0x4(%rbp),%eax 28: 89 c6 mov %eax,%esi 2a: 48 8d 05 00 00 00 00 lea 0x0(%rip),%rax # 31 \u0026lt;main+0x31\u0026gt; 31: 48 89 c7 mov %rax,%rdi 34: b8 00 00 00 00 mov $0x0,%eax 39: e8 00 00 00 00 call 3e \u0026lt;main+0x3e\u0026gt; 3e: b8 00 00 00 00 mov $0x0,%eax 43: c9 leave 44: c3 ret Disassembly of section .rodata: 0000000000000000 \u0026lt;.rodata\u0026gt;: 0: 25 .byte 0x25 1: 64 0a 00 or %fs:(%rax),%al Disassembly of section .comment: 0000000000000000 \u0026lt;.comment\u0026gt;: 0: 00 47 43 add %al,0x43(%rdi) 3: 43 3a 20 rex.XB cmp (%r8),%spl 6: 28 55 62 sub %dl,0x62(%rbp) 9: 75 6e jne 79 \u0026lt;main+0x79\u0026gt; b: 74 75 je 82 \u0026lt;main+0x82\u0026gt; d: 20 31 and %dh,(%rcx) f: 33 2e xor (%rsi),%ebp 11: 33 2e xor (%rsi),%ebp 13: 30 2d 36 75 62 75 xor %ch,0x75627536(%rip) # 7562754f \u0026lt;main+0x7562754f\u0026gt; 19: 6e outsb %ds:(%rsi),(%dx) 1a: 74 75 je 91 \u0026lt;main+0x91\u0026gt; 1c: 32 7e 32 xor 0x32(%rsi),%bh 1f: 34 2e xor $0x2e,%al 21: 30 34 29 xor %dh,(%rcx,%rbp,1) 24: 20 31 and %dh,(%rcx) 26: 33 2e xor (%rsi),%ebp 28: 33 2e xor (%rsi),%ebp 2a: 30 00 xor %al,(%rax) Disassembly of section .note.gnu.property: 0000000000000000 \u0026lt;.note.gnu.property\u0026gt;: 0: 04 00 add $0x0,%al 2: 00 00 add %al,(%rax) 4: 10 00 adc %al,(%rax) 6: 00 00 add %al,(%rax) 8: 05 00 00 00 47 add $0x47000000,%eax d: 4e 55 rex.WRX push %rbp f: 00 02 add %al,(%rdx) 11: 00 00 add %al,(%rax) 13: c0 04 00 00 rolb $0x0,(%rax,%rax,1) 17: 00 03 add %al,(%rbx) 19: 00 00 add %al,(%rax) 1b: 00 00 add %al,(%rax) 1d: 00 00 add %al,(%rax) ... Disassembly of section .eh_frame: 0000000000000000 \u0026lt;.eh_frame\u0026gt;: 0: 14 00 adc $0x0,%al 2: 00 00 add %al,(%rax) 4: 00 00 add %al,(%rax) 6: 00 00 add %al,(%rax) 8: 01 7a 52 add %edi,0x52(%rdx) b: 00 01 add %al,(%rcx) d: 78 10 js 1f \u0026lt;.eh_frame+0x1f\u0026gt; f: 01 1b add %ebx,(%rbx) 11: 0c 07 or $0x7,%al 13: 08 90 01 00 00 1c or %dl,0x1c000001(%rax) 19: 00 00 add %al,(%rax) 1b: 00 1c 00 add %bl,(%rax,%rax,1) 1e: 00 00 add %al,(%rax) 20: 00 00 add %al,(%rax) 22: 00 00 add %al,(%rax) 24: 45 00 00 add %r8b,(%r8) 27: 00 00 add %al,(%rax) 29: 45 0e rex.RB (bad) 2b: 10 86 02 43 0d 06 adc %al,0x60d4302(%rsi) 31: 7c 0c jl 3f \u0026lt;main+0x3f\u0026gt; 33: 07 (bad) 34: 08 00 or %al,(%rax) ... 用MIPS交叉编译工具链的objdump反编译mipsgccmain.o结果如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 mipsgccmain.o： 文件格式 elf32-tradbigmips Disassembly of section .text: 00000000 \u0026lt;main\u0026gt;: 0: 27bdffd0 addiu sp,sp,-48 4: afbf002c sw ra,44(sp) 8: afbe0028 sw s8,40(sp) c: 03a0f025 move s8,sp 10: 3c1c0000 lui gp,0x0 14: 279c0000 addiu gp,gp,0 18: afbc0010 sw gp,16(sp) 1c: 24020001 li v0,1 20: afc2001c sw v0,28(s8) 24: 24020002 li v0,2 28: afc20020 sw v0,32(s8) 2c: 8fc3001c lw v1,28(s8) 30: 8fc20020 lw v0,32(s8) 34: 00621021 addu v0,v1,v0 38: afc20024 sw v0,36(s8) 3c: 8fc50024 lw a1,36(s8) 40: 3c020000 lui v0,0x0 44: 24440000 addiu a0,v0,0 48: 8f820000 lw v0,0(gp) 4c: 0040c825 move t9,v0 50: 0320f809 jalr t9 54: 00000000 nop 58: 8fdc0010 lw gp,16(s8) 5c: 00001025 move v0,zero 60: 03c0e825 move sp,s8 64: 8fbf002c lw ra,44(sp) 68: 8fbe0028 lw s8,40(sp) 6c: 27bd0030 addiu sp,sp,48 70: 03e00008 jr ra 74: 00000000 nop ... Disassembly of section .reginfo: 00000000 \u0026lt;.reginfo\u0026gt;: 0: f200003c .word 0xf200003c ... Disassembly of section .MIPS.abiflags: 00000000 \u0026lt;.MIPS.abiflags\u0026gt;: 0: 00002002 srl a0,zero,0x0 4: 01010005 lsa zero,t0,at,0x1 ... Disassembly of section .pdr: 00000000 \u0026lt;.pdr\u0026gt;: 0: 00000000 nop 4: c0000000 ll zero,0(zero) 8: fffffffc .word 0xfffffffc ... 14: 00000030 tge zero,zero 18: 0000001e .word 0x1e 1c: 0000001f .word 0x1f Disassembly of section .rodata: 00000000 \u0026lt;.rodata\u0026gt;: 0: 25640a00 addiu a0,t3,2560 ... Disassembly of section .comment: 00000000 \u0026lt;.comment\u0026gt;: 0: 00474343 .word 0x474343 4: 3a202855 xori zero,s1,0x2855 8: 62756e74 .word 0x62756e74 c: 75203132 jalx 480c4c8 \u0026lt;main+0x480c4c8\u0026gt; 10: 2e332e30 sltiu s3,s1,11824 14: 2d313775 sltiu s1,t1,14197 18: 62756e74 .word 0x62756e74 1c: 75312920 jalx 4c4a480 \u0026lt;main+0x4c4a480\u0026gt; 20: 31322e33 andi s2,t1,0x2e33 24: Address 0x24 is out of bounds. Disassembly of section .gnu.attributes: 00000000 \u0026lt;.gnu.attributes\u0026gt;: 0: 41000000 mftc0 zero,c0_index 4: 0f676e75 jal d9db9d4 \u0026lt;main+0xd9db9d4\u0026gt; 8: 00010000 sll zero,at,0x0 c: 00070405 .word 0x70405 由于CO课掌握的MIPS代码基础，本人阅读mips交叉编译工具链的反编译代码时更为流畅。\nobjdump的参数含义 通过阅读man objdump给出的内容，我们可以得知一些参数信息\n下面举出几例简单的：\n参数 作用 -e或-g 显示调试信息 -D 反汇编所有section -r 显示文件的重定位入口 -S 尽可能反汇编出源代码 -z 将0也进行反汇编 我传入的参数-DS便是反编译所有section，并且同时显示反编译代码与源代码\nThinking 1.2 用readelf解析mos 下图是用自己的readelf阅读mos的结果\n用readelf解析文件本身 我们发现运行没有任何输出结果。\n根据hint，我们使用readelf -h来研究文件头。\n下图是可被自己的readelf分析的mos与hello的信息。 下图是不可被自己的readelf分析的readelf.o的信息。 可以发现他们的类别分别是ELF32与ELF64。\n那么问题就迎刃而解了，我们清晰地记得，在完成readelf.c的书写时，我们采用的都是ELF32类型的数据结构。\n因此我们的readelf不能用来解析身为ELF64的readelf.o文件。\nThinking 1.3 指导书上的启动过程：\n为什么操作系统的内核入口并没有放在上电启动地址，还能保证内核入口被正确跳转到？\n因为内核入口和上电启动地址本来就是没有关系的。\n上电启动位置是用于启动bootloader，实现硬件初始化等内容。 而bootloader所加载的内容才决定了内核的入口，也就是说我们在start.S中所写的_start函数即EXPORT(_start)才是mips_init的入口。\n难点分析 本次实验的核心内容：\n认识elf文件 _start函数 printk函数与vprintfmt函数 认识elf文件 什么是elf文件 .elf包含.exe，.o和.so （不过linux对扩展名要求并不严格，扩展名不能用来判断文件类型！） 准确来说应该是： 可执行文件，可重定位文件和共享对象文件。\n也就是说我们可以用readelf来解析我们在tools/readelf里的hello,readelf,readelf.o, main.o等等多种文件。\n在elf.h中，我们对于ELF32的种种内容做出了定义。 具体来说便是Elf32_Ehdr Elf32_Shdr Elf32_Phdr这三个结构体类型\nElf32_Ehdr描述ELF头，Elf32_Shdr描述节(Section)头表，Elf32_Phdr描述段(Segment)头表，又名程序(Program)头表。\n如何实现readelf 我们自己实现的readelf，是只能解析ELF32的section地址的可执行程序。 功能很简单，只需要从elf文件本身拿到我们想要的信息并输出。\n根据代码逻辑，你需要知道sh_entry_count，并通过shdr这一指针去定位到各个section，从而输出其地址。\n现根据ELF头得到节头表的位置、节头数量等信息，然后让sh_table指针去指向节头表第一项的地址:binary + ehdr-\u0026gt;e_shoff。\n接下来循环输出即可，其中得到节头表下项的方法，只需要将sh_table这一指针变为(Elf32_Shdr *)类型，然后加1即可。也可以用上sh_entry_size，直接加上这个数值实现地址空间的移动。\n如何链接elf文件 只需要将所有的section放在一起，尤其是\n.text 代码段 .data 需要被初始化的全局变量与静态变量 .bss 未被初始化的全局变量与静态变量 放在一起的方法： . = 一个地址 .text:{*(.text)} 把所有.text依次放在.的位置，其他section同理\n若不再修改.则继续顺延放置。 若修改，就以新的地址继续顺延放置。\n_start! 读这道题时会发现有很多宏定义的内容。\nasm.h 通过阅读asm/asm.h，其定义了EXPORT()\n发现它真的只是一个标签而已；\n其中又include了asm/cp0regdef.h与asm/regdef.h\ncp0regdef.h CP0寄存器的一些define\nregdef.h 寄存器堆的一些define\n这就解释了很多看似是无厘头的简写，实则都有依据的内容\n当然还有mmu.h为我们的KSTACKTOP提供了define\n而mips_init可以直接使用，则是因为程序经过预处理编译等等后，函数名也会变为标签，并和start.S的.text段组合在一起，那自然就可以访问到了。\nprintk 本次实验代码量最大的一环，核心内容就是书写vprintfmt函数。\n简单了解va变长数组的基本方法后，我们便可以开始了解这一函数。\n了解vprintfmt 首先，vprintfmt的参数是out函数指针，data指针，fmt字符串，ap数组。\nout函数指针能实现在同一函数(vprintfmt)中调用不同形式的out函数\nout函数可以实现输出以buf为起点，长度为len的字符串。\ndata指针指向out紧挨的内存空间，用于存储additional output sink-specific data（尚不知道有何用）\nfmt是格式字符串，ap则是%对应的参数列表，通过va_arg(ap, type)来获取内容\n实现vprintfmt 核心处理当然在于fmt的解析 在printf(\u0026quot;%d + %d = %d\\n\u0026quot;, a, b, c);中我们知道，fmt字符串中的非占位符直接输出，%xxx则要被变量所替换。那么分析的核心就是找到%并解析%后面的内容。\n整体逻辑是一个大循环\n然后需要一个小循环内寻找%，找不到就length++， 找到了就把之前length长的内容全部out出来。\ns的作用是更新起始点到进入当前小循环时的fmt。\n为了避免一直就没有%无法输出，走出小循环后要再执行一次out函数。如果有%的话也不必担心，因为length就已经更新到0了。\n接下来就该结束大循环了。如果到达了\\0，就break。\n如果survive了这次break，说明你找到了%, 那接下来就是通过对%后内容的解析来改变参数。\n后续的内容难度就不大了。\n需要注意，10进制有符号数输出时会改动neg_flag 因为 它用的是unsigned long！\n更基本的函数 也就是print_char print_str 和 print_num，他们是直接由out函数实现的，用于为vprintfmt提供方法，因此也需要简单了解。\n实验体会 整个实验给我的感觉就是浩大，一时间突然接手了这么多文件，会不知道该看什么，谁是重点（因为每个文件都是必要的）\n那么我们容易做到的，就是跟着实验指导书一点点去探索，从表面的应用层逐渐向内挖掘到实现层，从而了解各个文件的内容。\n倘若研究完lab1，可以搞清楚整个目录下的主要文件的功能与服务关系，我想这对于操作系统体系结构的理解应该是有好处的。\n笑传：笔者打完这行字之后自动输入了Esc :wq 丝滑小连招 ","date":"2025-03-19T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab1-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B8%8Eprintk/jpg_hu16008541044371850100.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab1-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B8%8Eprintk/","title":"BUAA OS Lab1 内核、启动与printk"},{"content":"本次作业以解析表达式并简化后输出为核心任务。\n主要的实现过程为： 预处理-\u0026gt;解析-\u0026gt;化简-\u0026gt;输出\n迭代过程综述 预处理的迭代 第一次作业：空白字符与正负号 第二次作业：递推函数 第三次作业：自定义函数\n解析的迭代 第一次作业：常数因子、幂函数因子、表达式因子 第二次作业：三角因子 第三次作业：求导因子\n化简的迭代 第一次作业：多项式的加乘幂 第二次作业：含三角函数的加乘幂及其化简 第三次作业：求导运算\n输出的迭代 第一次作业：输出多项式 第二次作业：输出含三角函数的表达式 第三次作业：无\n第一次作业 刚刚走进面向对象课堂的第一天，就被HW1深刻地击溃了。 不同于其他同学只是担心可扩展性不够强而不肯动笔————我的大脑是完全空白的。\n我知道是这个道理，但是到底怎么写？\n我认为理解递归下降实际运行的关键，在于深刻理解lexer的执行逻辑，lexer作为parser的属性，是唯一确定的，当我解析完成，lexer也就走完了。解析的过程就是lexer的前进过程。\n而我们做的事情，就是根据读取expression，自行出构建一个新的、有结构的Expr。\n接下来的toPoly便也是递归下降的一种体现。我已经知道最小单元Mono与Power有它具体的toPoly()方法，那么我就可以采用递归下降，对每一个类只着眼于它自身的运算过程。\n代码量 可以看出核心代码在于解析Parser与化简Poly这两个类中。\nUML类图 方法数则是Poly类遥遥领先，不过都是加、乘、幂、去零、取反、输出等基本方法\n复杂度 同样的，Parser与Poly的复杂度是远高于其他类的。\n类的设计 PreProcess为预处理类，直接把空格与连续正负号解决掉，简化Parser的处理。\nMono类与Power类则对应了最小解析单元（因子中的常数，幂函数与表达式因子），这里将常数与幂函数都归为Mono类是很方便的。\n第二次作业 如果说第一次作业是从零到一的突破，那么第二次作业可能就是从1到x的蜕变。 三角因子本身的复杂性太强，不能像之前一样简单的归类，更没有统一的计算方法。\n曾经Poly里的加与乘，如今全部都复杂起来了！ 我们只能进行重构。\n对于加法，我们没有曾经直接看x的幂次来进行合并同类项的简单解法， 因此只有写出同类项判别方法，才能实现加法的简化\n对于乘法，我们需要先实现最小单元之间幂函数幂次与三角因子幂次的累积 再进行所有乘积项的求和\n代码量 较上次作业新增了近800行，其中parser变化不大，而Mono与Poly代码量激增 此外还有新增的类: 递归函数RecursiveFunc\nUML类图 我调整了类的相对位置使之更加清晰。\n图片从上到下分别是函数预处理，表达式解析，表达式化简运算与输出\n复杂度 Parser与Poly不出意外的高复杂度。 但是递推函数类的复杂度异常的高，我承认我当时采用的方法过于粗暴。 后续果然发现了bug，只是到了第三次作业的环境中才得以体现出来。\n类的设计 Mono类秉承着原来解析的最小单元的地位，现在的它，是一个除了表达式因子以外可以包罗万象的Factor,含有常数，幂函数的幂次，三角函数的HashMap\u0026lt;Poly, BigInteger\u0026gt;。\n因此，他也仍然是最终运算的最小单位，充当最终表达式中的项（Term）。\nPoly则是所有Mono的和，用ArrayList实现。\n接下来是RecursiveFunc类。我将函数翻译作为了预处理操作的一部分，实现了在解析开始之前就解决掉了所有的函数问题。这个类的核心作用就是根据已知信息，直接获得一个从0到5的函数Map。\n接着process类也将被重写，并增添替换操作。\n第三次作业 经历了HW1的无力茫然与HW2的大刀阔斧 站在HW3面前的你， 应当充满了决心！\n代码量 代码行数增加的并不多\n主要内容是新类的添加，更多的函数代入操作以及求导计算\nUML类图 相较于hw2，在Factor上新增了求导因子，在预处理上新增了NormalFunc以及一个数据功能类Func。\n复杂度 类的设计 Derivation类作为一个Factor，需要toPoly()方法，只需要将expr先toPoly，在调用Poly()的derive方法。\nNormalFunc类的设计与RecursiveFunc的思路基本一致，只是少了递推这一步。\n可扩展性 函数的扩展： exp函数，只需对Mono类添加一个Poly属性，用于记录指数。 ln函数，同理，只需记录真数。 变元的扩展： 只需Mono的power变为power1和power2，分别作为两个变元的幂指数 BUG 第一次作业 0 bug\n第二次作业 强测 0 bug 互测 2 bugs 错因是在截止前20min才意识到忘记处理sin(0)与cos(0)，这会对性能产生极大的损害。 而在优化了这一点之后，由于从未对数字0 ^ 0有过定义，sin(0)^0就变为了0 而在时间紧迫的情况下，我也没来得及用评测机进行评测。提交截止之后，评测机很快就跑出了该问题。\n另一处bug是犯了很多次的二重循环初始化错误，修改了之后还是遗漏了一个地方。\n正如教程所说，这两个点都是高行与圈复杂度的类（Mono与Poly）所出现的问题，耦合性强，不易被发现。\n若想降低复杂度，也就是解耦合，就需要做好一些预先的规划，将谁该做什么事分清楚。不过Poly与Mono的耦合度高，个人认为是较难避免的。因为Poly里会用到Mono的同类项判别方法，这个方法中又会涉及会Poly(三角函数内)的equal方法，这一equal方法又会归结于Mono\n或者说，Poly跟Mono的关系，就很有一种Expr与Factor的感觉。\n第三次作业 0 bug\n评测机搭建 这三周以来很有成就感的一件事，就是我终于主动尝试着搭出了自己的评测机！\ncheck.py比对 利用了sympy库中的函数 python库就是神通广大（）\ndata.exe数据生成 核心内容\n我使用的是随机暴力生成的方法\n构建的逻辑就是递归下降咯\nprintExpr-\u0026gt;printTerm-\u0026gt;printFactor\nbat批处理程序运行 学习了一些基本运行语句： java -jar .jar python .py .exe\n利用了一些基础的重定向。\nBUG分析 首先是评测机暴力跑数据，通过简化数据点抓住核心问题数据，再定位到代码的具体漏洞位置。这一招在hw2中就大杀四方，获得了5个不同质的bug。\n其次便是手动构造边界数据，尤其是0,0次幂，1次幂等特殊情况，多加测试。\n遗憾的是，由于代码阅读能力不够强，我常常没有心力去认真观察他人的代码来寻找bug。\n优化 输出符号优化 hw1便涉及到的，存在正项则提前\nsin cos正负号优化 对于因子内部全为负的三角因子，我会直接对该Poly使用negate方法，使其含有正项，从而缩短长度\n这一处理在某种程度上也统一了一些格式，便于同类项的判断\n不足之处在于还是不能用于全面的判断两个Poly是Opposite的，例如1-x与x-1，便不会经过处理，从而后续不会被判定为同类项\n改进： 我们可以采用相加等于0的方法来判断Poly的isOpposite\nsin^ 2+cos^ 2 sin^ 2-cos^ 2 sin^ 4-cos^ 4 为了能够处理嵌套括号内的该类内容，我选择了在每次addPoly()时都加以判断，并且提取了公因式（不过无法处理幂次的公因式，比如sin(x)^ 3+cos(x)^ 2*sin(x)）。\n一处问题：在二倍角过程中，我改变了三角因子的Poly。这一行为决定了我们必须使用深克隆！\n另一处问题：过于频繁与紧急的匹配会导致贪心，例如sin(x)^ 2 - cos(x) ^2 + cos(x) ^2, 便会被我使用二倍角，从而闹出笑话。\n改进：在最后再处理化简工作，至于嵌套，可选择遍历内部嵌套进行化简。\n心得体会 作为第一章，面向对象的思想已经比较清晰地发散开来了。递归下降这一算法，本身就是十分符合面向对象的思维方式，每个类做好自己的算法，问题一定能得到解决。\nhw2是很不错的一次体验，虽然是最辛苦的一周，但是无畏地向前探索，不合适就重构的勇气是很宝贵的。\n搭建评测机也是很奇妙的一次体验。自主学习的收获总是刻骨铭心。\n未来方向 个人认为递归下降的内容如果能在理论课上详细结合代码来讲解运行逻辑，可能hw1就不会显得那么痛苦（）\n但是这种痛苦也是有益的，至少它让我从懵懂的第一周里清醒过来：\n面向对象的挑战，已然开始。\n","date":"2025-03-18T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-oo-u1-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/123_hu6378763551609642095.png","permalink":"https://demiurge-zby.github.io/p/buaa-oo-u1-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","title":"BUAA OO U1 递归下降与表达式解析"},{"content":"exam 不错的exam。考核内容完全来自于指导书与作业，并且足够全面。 这在lab上机中是很好的设计，掌握不那么牢固的可以通过花费一点时间阅读指导书拿到exam这一主要分数，提升掌握水平 而相对熟练的同学则可以更快地解决exam去攻克extra了。\n另外，一定要认真读前言里的要求！本次exam题就需要先bash init.sh才能得到所需文件\n题目有两道：Makefile与Shell\nMakefile Makefile考的仍然是gcc,run和clean三件套\n1 2 3 4 5 6 7 8 9 10 11 .PHONY: clean all: check.o make check gcc -I ./src/include ./src/main.c ./src/output.c -o ./out/main check: check.c gcc -c check.o check.c run: out/main ./out/main clean: rm -rf check.o rm -rf ./out/main 不过这次在gcc上的考点比较新：\n编译不链接 gcc -c 非标准库头文件 gcc -I 头文件目录 此外，还考查了make A任务内调用make B的内容\n也可以考察跨目录make调用\n即 cd 目录 \u0026amp;\u0026amp; make\nShell 本题一共有九问，也就是九个功能， 比较惹人烦的点在于这九个功能要在9个脚本中分别实现\n如果你足够熟悉， 你可以直接 sed -i '1i#!/bin/bash' exam_*.sh 来为每一行开头加上#!/bin/bash\n九个脚本的内容是：\n在指定目录下新建目录 grep指令 mv指令 cp -r指令 循环语句与sed 替换 通配符* 2\u0026raquo; chmod 条件语句 需要注意的一些点：\n双引号，单引号 取决你是否要解析引号内的内容\n对于awk中$1有特殊含义，便需要单引号处理\n而sed中如果需要$1参数，那当然是要用双引号的\n$符号作为尾行，又是参数解析符号，若要从$1到$进行p，如果写成sed -n \u0026lsquo;$1,$p\u0026rsquo;的话，$1不能解析；写成sed -n \u0026ldquo;$1,$p\u0026quot;的话，p又会被解析。 那么我们可以用空格分隔开。即sed -n \u0026ldquo;$1,$ p\u0026rdquo;\n脚本内加减运算的写法，if,for,while,case的写法\nextra 接下来来到万恶的extra 其本身的难度可能也不能直接称之为高，但是我还是认为应该明确地表示充分利用hint的内容\n因为hint中的内容，不仅太多，而且太重要，太必要！\n对于第二问ln -s的超链接写法，这显然是回去看hint的，因为完全没有听说过\n但是第一问不仅hint很晚才更新，另外还伪装成不用hint也能解决的问题，使很多同学花费了很多时间去用man来看已知指令的参数\n其次，后置测试点依赖前置测试点。虽然他确实对于评测是更方便的，但是偏偏在第一问出现hint的缺失，从而影响到整个题目的得分，给人的体验还是不太好的。\ngenCode 第一问的主要任务是： 对于指定目录下的所有.sh文件，将其经过一些简单的sed文件处理后，以原名称(不含.sh).c的新名字存放在新的指定目录。\n其他的都不难，最难的就在于怎么实现获取文件名与文件重命名\n大多数同学都尝试过sed xxxxxx *.sy \u0026gt; *.c 然后意外的发现只生成了一个名为'*.c'的文件\u0026hellip;\u0026hellip;\n笔者找了找mv的man\nmv是笔者知道的唯一的重命名指令\n然后找到了-S, \u0026ndash;suffix=[后缀名]这样的东西。\n当然并没能实现功能。\n后来助教说extra内容更新了。我看了眼题面，感觉没变，以为是第四第五题改了，就没在意。实际上发布的正是第一题的hint,能够实现对一个目录下所有文件都访问，并获取其文件名。\n那么本题的考点就是awk指令 awk -F.并取$1来获得.sy前面的内容\nselectCode 若存在则删除xxx\n考察的其实是rm -f强制执行（若不存在则自动忽视）\nln -s （hint 超链接操作）\ngcc -I -o\nselectData 本小问需要实现将所有的xx_yy.in与xx_yy.out文件根据参数进行复制。(xx与yy都是随机的)\n若参数为all，则全部复制到指定目录 否则，仅复制参数_yy.in与参数_yy.out到指定目录\n这里可以使用case语句\n1 2 3 4 5 6 7 8 #!/bin/bash mkdir dataSet case $1 in all ) cp -r ./data ./dataSet;; * ) cp ./data/$1* ./dataSet;; esac 注意好格式。\n未知 很遗憾，在我做完二三问，并发现有测试点依赖后，就全力研究第一问了。没能获得第四、五问的题目。同学们可以参考其它博客。\n后记 不同于往年，今年的题目难度确实是大。大多数人都extra都喜提0分（或者未提交） 倘若第一问hint能够正常给出，本次lab的体验感应该还是不错的。\n笔者给extra留了一整个小时还攻不下第一问，可见该hint的重要性（）\n现在想起自己实验报告里写OS多温和什么的，，，\nOS的磨难才刚刚开始。\n","date":"2025-03-14T11:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab0-%E4%B8%8A%E6%9C%BA/123_hu15367369478727297293.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab0-%E4%B8%8A%E6%9C%BA/","title":"BUAA OS Lab0 上机"},{"content":"作业实现 预处理 replaceAll()函数 解决空白符与连续正负号\n表达式解析（递归下降） 递归下降的特点是下降和递归。 下降实现了功能的独立性。 而递归是由要解析的表达式的结构决定的。\nLexer的作用 核心作用是处理数字，将连续的数字字符变为一个token单位\n其他保持不变\n提供方法：\n当前token是什么 peek() 去下一个token next() 其实就相当于C语言字符串中的\nstr[i] i++ 只是我们需要的信息没那么多，就不采用先把式子变成token的ArrayList再去解析的方法 而是在解析的时候利用lexer作为移动和识别的工具\nparseExpr Expr是Term的和\n通过加减符号实现Term的分割\n判加减 (用peek()判内容 用next()进入下一token) parseTerm() addTerm() 循环： 判加减 (用peek()判内容 用next()进入下一token) parseTerm() addTerm()\nparseTerm Term是Factor的积 通过乘号实现Factor的分割（其中第一个Factor可有额外正负号）\n判加减 (用peek()判内容 用next()进入下一token) parseFactor() addFactor()\n循环： 判乘号 (用peek()判内容 用next()进入下一token) parseFactor() addFactor()\nparseFactor Factor约等于解析最底层\n分为三类，需要建立接口\n常数因子与幂函数因子可以用 A*x^b统一 表达式因子分为(Expr)与(Expr)^n\n所以Expr类，Mono类A*x^b和Power类(Expr)^n都需要Factor接口，以在解析完成时返回Factor类型的结果\n其中Expr还能下降为A*x^b，(Expr)与(Expr)^n 因此最小单位就是Mono类A*x^b和Power类(Expr)^n\n解析方法：\n先判一下加减 (用peek()判内容 用next()进入下一token)\n判到左括号 (用peek()判内容 用next()进入下一token) parseExpr(); 把右括号跳过 next() 判^ (用peek()判内容 用next()进入下一token) 有^ : （若有正号先next()掉）peek()读取指数 再next() 指数是0 ： return Mono类 1*x^0 否则： return Power类 无^ ：直接return Expr类 判到数字 (用peek()判内容 用next()进入下一token) Mono类 数字*x^0 判到x Mono类 1*x^n 无^时n=1特殊处理 关于正负：传参 我在解析过程中将正负号落实到了Mono类与Power类 这样，Factor之间只是乘，Term之间只是加，相对简单\n落实的方法: 传参 isNeg 初始参数值，即MainClass调用时是parseExpr(false) 改变的规则：\n根据传入参数，在解析方法定义内部变量isNegative，用于传递给下级 遇到负号，isNegative = !isNegative 对于Expr到Term符号的继承，每一项isNegative的初始值都是isNeg 对于Term到Factor符号的继承，只有第一项isNegative的初始值是isNeg，其余初始值为False 特别的，对于Power类型，其Expr由于先被解析，所以正负号已经落实到内部，这时候Power的正负性就应该做出调整： 若符号为正，则无影响 若符号为负，且指数为奇数，则Power类型应当必须为正数，因为负属性已经在Expr中展现了 若符号为负，且指数为偶数，则Expr的负属性不能展现，Power类型需要为负 最终正负就落实到Mono与Power上，这两个类有isNeg属性\n表达式求值 最终结果为多项式，而Mono和Power也可变为多项式。 只需先转化为多项式，再实现多项式的加与乘即可。\nPoly类 只是有一个TreeMap，里面放着键值对\u0026lt;指数，系数\u0026gt; TreeMap的优势在于merge()方法和有序 merge方法在加入一个键值对可以实现合并同类项的作用\nMono的toPoly() 先处理Negate(),直接系数取负 然后直接new一个Poly，让其TreeMap去put(指数，系数)\nPower的toPoly() 需要有Expr的toPoly(),再使用Poly的幂运算，再实施Negate()\nExpr,Term,Factor的toPoly() Expr就是Term的toPoly()的和 Term就是Factor的toPoly()的积 Factor的toPoly()借助接口就是Mono,Expr与Power的toPoly()\nPoly的加，乘，幂 加法直接merge进去 乘法双重循环一项项merge进去（需注意只有一个因子时，另一个因子应变为\u0026lt;0,1\u0026gt;） 幂可用快速幂，也可直接循环乘。同样注意上述问题。\n当然三种运算最后都应去除系数为0的单项式\n结果的输出 由于结果是多项式，输出相对简单。\n需要注意：\n空Tree要输出0 若存在单项式系数为正，应将其提前并省略正号 指数为0的项只输出数字，指数为1的项只输出x，指数为-1的项只输出-x 中间的正项需额外输出+ 评测机实现 DataMaker 使用c程序，同样使用递归下降的方法去生成表达式\nprintExpr() -\u0026gt; printTerm() -\u0026gt; printFactor() -\u0026gt; \u0026hellip; 用rand()随机项数，因子数，正负号，以及因子的种类等等\nCheck 由于Python库的强大，这里使用了Python的sympy库 检测两个表达式化简结果是否相等，实现了对拍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import sympy x = sympy.symbols(\u0026#39;x\u0026#39;) with open(\u0026#39;./outA.txt\u0026#39;,\u0026#39;r\u0026#39;) as fileA: e1 = fileA.read().replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;) expr1 = e1.replace(\u0026#34;^\u0026#34;,\u0026#34;**\u0026#34;) with open(\u0026#39;./outB.txt\u0026#39;,\u0026#39;r\u0026#39;) as fileB: e2 = fileB.read().replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;) expr2 = e2.replace(\u0026#34;^\u0026#34;,\u0026#34;**\u0026#34;) expr1 = sympy.simplify(expr1, ratio=10) expr2 = sympy.simplify(expr2, ratio=10) if (sympy.simplify(expr1 - expr2) == 0) : print (\u0026#34;True\\n\u0026#34;) else : print (\u0026#34;False\u0026#34;) print (\u0026#34;data:\u0026#34;) with open(\u0026#39;./in.txt\u0026#39;,\u0026#39;r\u0026#39;) as filein: data = filein.read() print (data) print (\u0026#34;right:\u0026#34;) print (e1) print (\u0026#34;yours:\u0026#34;) print (e2) print (\u0026#34;\\n\u0026#34;) 运行脚本 Windows系统的bat脚本和OS学习的Linux脚本异曲同工\n主要使用了这些操作\n指令 作用 REM 注释 java -jar 名称.jar 运行jar包 名称.exe 运行.exe文件 python 名称.py 运行python程序 \u0026lt; ，\u0026gt; 实现重定向 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @echo off for /l %%i in (1,1,100) do ( normaldata.exe \u0026gt; in.txt java -jar oo_homework_2025_xxxxxxxx_hw_1.jar \u0026lt; in.txt \u0026gt; outA.txt java -jar 1.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 2.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 3.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 4.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 5.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 6.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 7.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py echo ------------------------------------------------------- ) cmd 如何制作jar包 具体流程可自行搜索。\n文件-\u0026gt;项目结构-\u0026gt;工件-\u0026gt; + -\u0026gt; JAR -\u0026gt; \u0026hellip;\n构建-\u0026gt;构建工件\n","date":"2025-03-03T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-oo-u1-hw1-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/123_hu15596244839450331959.png","permalink":"https://demiurge-zby.github.io/p/buaa-oo-u1-hw1-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","title":"BUAA OO U1 HW1 表达式解析"},{"content":"实验报告 思考题 Thinking 0.1 文本内容如下图：\n刚刚创建文件后，文件处于未跟踪状态，即Untracked。\n文件被git add之后，被建立跟踪并且进入Staged状态。\n当文件被git commit后，进入未修改状态Unmodified，若增加修改，则变为Modified状态。\n因此结果并不一样。因为第一次add之前，文件尚未被跟踪，文件作出修改也仍会处于Untracked状态。\n而在add与commit之后，文件被跟踪，提交过后的修改会被记录为Modified。\nThinking 0.2 add the file对应git add （第一次add文件） stage the file对应git add （已跟踪的文件经过修改后进行的add，添加到暂存区） commit对应git commit (把暂存区里的内容commit)\nThinking 0.3 代码文件print.c被错误删除时，应当使用什么命令将其恢复？\n应当使用git restore print.c\nprint.c仍然在暂存区，只是在工作区被删除，只需将工作区恢复到暂存区状态即可。\n代码文件print.c被错误删除后，执行了git rm print.c命令，此时应当 使用什么命令将其恢复？\n应当先后使用git reset HEAD print.c与git restore print.c\n因为执行了git rm print.c，暂存区已被改动，所以需要先恢复暂存区的内容。\n无关文件hello.txt已经被添加到暂存区时，如何在不删除此文件的前提下 将其移出暂存区？\n应当使用git rm -cached hello.txt\nThinking 0.4 git log结果如下图：\n版本回退后git log结果如下图：\n版本切换的结果：\n可以看出git reset --hard HEAD^执行后，git log结果并不是1-2-3-2，而是直接变为1-2\ngit reset --hard \u0026lt;hash\u0026gt;对于版本的控制也并不改变目录树，而是在原有的目录树上切换结点。\nThinking 0.5 运行结果如下：\n\u0026gt; 的重定向是覆盖，而\u0026gt;\u0026gt;的重定向是追加。\nThinking 0.6 command内容为：\nresult内容为：\n解释说明：\n为了原样输出test，command每一行的内容为： echo \u0026rsquo; Content \u0026rsquo; \u0026raquo; test (第一行是\u0026gt;)\n其中单引号的目的是保证原样输出，不触发文本中的任何$符号与\u0026gt;符号\nresult的内容有两部分， 一是test运行的输出结果会重定向到result， 二是test文件本身也有重定向到result的代码\n思考问题：\n若把echo echo Shell Start的echo Shell Start用反引号引起来 则会将反引号内指令的运算结果变为一个字符串\u0026quot;Shell Start\u0026quot; 最终整条指令结果为Shell Start\n而echo echo Shell Start的结果是echo Shell Start\necho echo $c\u0026gt;file1则同理，加上反引号后指令会输出3 而不加反引号应输出echo $c\u0026gt;file1，结果不同。\n难点分析 Lab0作为大家走向OS的过渡课程，其思维难度不高，重难点在于对各种指令的运用。\n如sed awk grep等方法的运用，单引号、双引号与反引号的灵活使用等等\n实验体会 目前尚未进行上机的限时测试，而日常实验的训练，很像我第一次搭建OO评测机时，一点点探索与学习的过程。\n感性的话不必多说，但是to be honest, OS的lab0相较于CO的P0-P2以及OO的U1，已然是非常温和了。\n","date":"2025-02-27T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-os-lab0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/Ark_hu14773038926689544259.png","permalink":"https://demiurge-zby.github.io/p/buaa-os-lab0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","title":"BUAA OS Lab0 预备知识"},{"content":"技术是中立的吗？为什么？ 技术中立这个观点是一个复杂且具有争议性的话题。 从某种纯粹的工具论角度来看，技术可以被认为是中立的。 技术就像一个空白的容器，本身没有内在的道德或价值取向。 以互联网技术为例，它仅仅是一系列协议、代码和硬件设施的组合。 在其最基础的层面，它只是实现信息传输的工具。 从这个意义上说，技术本身不会主动地产生好或者坏的影响。 再以电为例，它可以驱动医疗设备拯救生命，也可以在被错误使用时导致触电事故致人死亡。 这种中立性在于技术的本质是一种手段，它等待着人类的使用和赋予意义。\n然而，技术进入社会应用领域，具有社会性，便不再是中立的。 首先，技术的研发动因就不是中立的。 技术研发往往受到社会、经济、政治和文化等诸多因素的影响。例如，军事技术的研发通常是基于国家的战略需求和安全考虑，这其中就蕴含着国家利益、地缘政治等非中立因素。而且，研发资金的来源也会对技术的走向产生影响。如果技术研发主要由追求利润最大化的商业公司资助，那么这些技术很可能会朝着有利于商业利益的方向发展，而不是以社会公益为首要目标。\n技术的设计过程不中立。 工程师在进行技术设计时会有意或无意地将自己的价值观念嵌入其中。 人工智能系统的训练数据选择、算法的设计都会受到开发者价值观的影响。 这使得技术产品本身就带有某种价值倾向。\n技术的应用效果不中立。 社交媒体平台的算法推荐系统就是一个很好的例子。这些算法根据用户的浏览历史、点赞、评论等行为来推荐内容。 从技术实现角度看，这是通过复杂的数据分析和机器学习算法完成的， 但在实际应用中，这种推荐系统可能会导致信息茧房的形成。 因为算法会倾向于推送用户感兴趣的内容， 而用户可能会逐渐只接触到符合自己既有观点的信息， 这对社会的多元交流和民主进程可能会产生负面影响。\n技术的传播和普及也不是中立的。 不同的社会群体对技术的接受程度和使用方式是不同的，这可能会加剧社会的不平等。 例如，在数字技术时代，那些能够熟练掌握信息技术的人更容易获取信息、教育资源和工作机会， 而缺乏数字技能的人群则可能被边缘化。 技术往往会强化既有的社会权力结构。掌握先进技术的群体往往能获得更大的社会影响力， 而技术鸿沟则可能加剧社会不平等。 这种数字鸿沟现象表明技术在社会中的应用会受到社会结构和权力关系的影响。\n技术的长期影响也难以被简单地归结为中立。 以核能技术为例，核电站可以提供大量的清洁能源，减少对传统化石燃料的依赖。但是，核废料的处理以及核电站事故的潜在风险（如切尔诺贝利和福岛核事故）给生态环境和人类健康带来了巨大的威胁。这种长期的、复杂的影响使得我们不能简单地将核能技术视为一个中立的工具。\n综上所述，虽然技术在最基本的工具属性层面可以被看作是中立的， 但在研发、应用、传播和长期影响等各个环节， 技术都与社会、经济、政治和文化等因素相互交织，很难再维持完全中立的立场。 监控资本主义是一个不可避免的趋势吗？我们有什么办法改变它？ 监控资本主义目前呈现出一种较为强劲的发展态势，但它并不是不可避免的趋势。 监控资本主义的兴起是多种因素共同作用的结果。 在数字经济时代，数据被视为新的石油。 企业为了追求经济利益，有强烈的动机去收集用户数据。 互联网公司通过提供免费的服务， 如社交媒体平台、搜索引擎等，吸引用户， 然后利用用户数据进行精准广告投放、市场调研等活动来获取利润。 随着技术的不断进步，数据收集的手段越来越多样化和隐蔽化。 例如，通过物联网设备收集用户的生活习惯数据，从智能家居系统到可穿戴设备，这些数据的价值不断被挖掘。\n然而，这种趋势并不是不可避免的。 从社会意识角度来看，公众对数据隐私的关注度在不断提高。 随着一些数据泄露事件的曝光和隐私侵犯问题的凸显，人们开始意识到自己的数据被滥用的风险。 消费者逐渐要求企业对数据的收集和使用更加透明，并加强数据保护。 这种社会意识的觉醒为改变监控资本主义提供了动力。\n在法律层面，政府可以通过加强立法来限制监控资本主义的过度发展。 例如，制定严格的数据保护法规，明确企业在数据收集、存储、使用和共享等环节的责任和义务。 欧盟的《通用数据保护条例》（GDPR）就是一个很好的例子。 它赋予了用户对自己数据的更多控制权，如数据访问权、被遗忘权等， 同时对违规企业处以高额罚款。 这使得企业在收集和处理欧洲用户数据时必须更加谨慎。\n技术手段也可以用来对抗监控资本主义。 隐私增强技术的发展为用户提供了保护自己数据的工具。 例如，加密技术可以确保数据在传输和存储过程中的安全性。 差分隐私技术可以在不泄露个体隐私的情况下进行数据分析。 此外，去中心化的数据存储和管理方案，如区块链技术，也可以减少企业对用户数据的集中控制。\n从企业社会责任角度来看，企业本身也可以进行自我约束。 一些有远见的企业已经意识到，长期的信任关系建立在对用户隐私的尊重上。 通过建立合理的数据治理框架，企业可以在获取商业利益的同时，保护用户的隐私权益。 例如，苹果公司在数据隐私保护方面采取了一系列措施，如端到端加密等，赢得了用户的信任。\n改变监控资本主义还需要加强国际合作。 由于互联网和数据的跨境流动，单个国家的法律和措施可能效果有限。 国际组织和各国政府需要共同制定全球统一的隐私保护标准和数据治理规则，共同打击跨境数据滥用行为。 同时，推动数据伦理的研究和教育，让人们从道德层面认识到监控资本主义的危害，也是改变这一趋势的重要途径。\n学校是否有权使用人脸识别对学生进行考勤？为什么？ 学校是否有权使用人脸识别进行考勤是一个涉及到多方面权益平衡的复杂问题。 学校管理的角度来看，学校有一定的理由使用人脸识别考勤。 学校是一个有组织的教育机构，需要对学生的出勤情况进行有效的管理。\n人脸识别考勤系统可以提高考勤的效率和准确性。 相比于传统的考勤方式，如点名或者刷卡，人脸识别可以在短时间内快速识别大量学生，减少人工考勤的时间和误差。 这有助于学校更好地掌握学生的出勤动态，及时发现学生的异常出勤情况，如旷课、迟到等， 从而可以采取相应的措施，如与家长沟通、进行教育辅导等，保障学生的正常学习秩序。\n在校园安全方面，人脸识别考勤系统也可以发挥一定的作用。 通过对进出校园人员的识别，可以有效防止外来人员未经许可进入校园，保障师生的人身安全和学校的财产安全。 特别是在一些安全形势较为复杂的地区，这种安全保障功能显得尤为重要。\n从学生隐私的角度来看，人脸识别考勤的使用存在诸多争议。 学生的人脸信息属于个人敏感信息，涉及到个人隐私。 学校收集和使用这些信息可能会侵犯学生的隐私权。\n人脸识别技术的准确性虽然在不断提高，但仍然存在一定的误差。 例如，可能会出现误识别的情况，将一个学生错误地识别为另一个学生，这可能会对学生的正常学习生活造成不必要的干扰。\n人脸信息一旦被收集，就存在数据泄露的风险。 学校的信息管理系统可能会受到网络攻击，导致学生人脸信息被盗用。 这些信息如果落入不法分子手中，可能会被用于身份盗窃、诈骗等违法犯罪活动。 而且，学生作为未成年人，其对自己的隐私权益的认知和保护能力相对较弱，学校更应该谨慎对待他们的隐私信息。\n从法律层面来看，目前关于学校使用人脸识别技术的法律规定还不够完善。 在不同的国家和地区，对于个人数据保护和学校管理权限的界定存在差异。 在一些地方，法律要求在收集和使用个人敏感信息时，必须获得学生本人或者其监护人的明确同意。 这意味着学校不能随意使用人脸识别考勤系统，而需要遵循法律程序，尊重学生和家长的意愿。\n为了平衡学校管理和学生隐私保护，学校如果要使用人脸识别考勤系统，应该采取一系列措施。 学校需要向学生和家长充分说明 充分说明人脸识别考勤系统的目的、用途和数据安全保障措施，获得他们的书面同意。\n学校应该建立严格的数据管理制度 确保学生人脸信息的存储安全，如采用加密存储、限制数据访问权限等措施。\n学校要定期对考勤系统进行评估 确保其准确性和安全性，及时处理出现的问题，如误识别和数据泄露风险。\n非必要情境避免使用 如果学校仅仅为了提高管理效率而使用人脸识别技术， 则应考虑是否可以通过其他较为低风险的方法（如二维码签到、指纹识别等）代替。\n什么是自动驾驶的电车难题？自动驾驶系统应该如何应对电车难题？ 自动驾驶的电车难题是一个极具挑战性的伦理困境，它源于经典的哲学“电车难题”。 在自动驾驶场景中，电车难题可以这样描述： 假设一辆自动驾驶汽车在行驶过程中遇到了不可避免的碰撞情况， 例如前方突然出现了一群行人闯红灯，而汽车的制动系统无法及时避免碰撞， 同时车辆旁边是一个坚固的障碍物， 汽车有两个选择，要么直接撞向行人， 要么转向撞向障碍物，而这样可能会对车内乘客造成严重伤害。\n这种情况引发了深刻的伦理和道德争议。\n从功利主义的角度来看，可能会认为应该选择牺牲车内乘客或者少数人的利益来保护多数人的生命安全 也就是撞向障碍物避免撞到更多的行人。 但这种观点忽略了车内乘客的权益，他们购买了汽车服务并且期望汽车能够保障他们的安全。\n优先保护车内乘客也有其合理性 因为汽车是由乘客购买和使用的服务，而且乘客本身并没有过错。\n对于自动驾驶系统如何应对电车难题，目前有多种不同的观点和方案。 设计一种能够避免做出伤害生命决策的自动驾驶系统。 例如，通过改进汽车的传感器和制动技术，尽可能地避免出现电车难题这种极端情况。 当检测到可能出现碰撞风险时，汽车可以提前发出警报，同时采取紧急制动或者避让措施， 如降低车速、转向到相对安全的区域等，以最大程度地减少伤害。 这种方案强调技术改进来避免伦理困境，但是技术的发展可能无法完全消除所有的风险情况。\n按照预先设定的道德和法律规则来应对。 例如，可以通过立法或者行业标准制定出一套统一的决策规则。 比如在遇到上述电车难题场景时，规定自动驾驶汽车应该优先保护多数人的生命安全。 然而，这种方案也面临着巨大的挑战。 首先，道德和法律规则很难达成完全一致的共识。 不同的文化、宗教和社会群体可能对这种生死抉择有不同的看法。 其次，一旦通过立法确定了这样的规则，可能会引发一系列社会问题。 例如消费者对自动驾驶汽车安全性的担忧，导致他们不愿意购买和使用自动驾驶汽车。\n采用随机化策略。 即当遇到电车难题这种不可避免的碰撞情况时，自动驾驶系统随机做出决策，不设定固定的优先保护对象。 这种方法的优点是避免了预先设定规则可能带来的争议，因为它没有对生命的价值进行明确的排序。 但是，随机化策略也很难被社会所接受，因为人们很难接受自己的生命安全或者他人的生命安全是由随机因素决定的。\n可以将决策权交给用户。 在购买自动驾驶汽车时，用户可以根据自己的价值观和意愿选择不同的碰撞应对策略。 然而，这种做法可能会导致混乱的交通规则和不一致的决策， 而且用户可能在没有充分考虑的情况下做出选择，或者在事故发生后改变主意。\n自动驾驶的电车难题是一个复杂的伦理和技术问题，需要综合考虑道德、法律、社会和技术等多个因素来寻找合适的应对方案。\n是否应该禁止或限制性爱机器人的研发、生产与销售？为什么？ 关于是否应该禁止或限制性爱机器人的研发、生产与销售，这是一个充满争议的伦理和社会问题。\n从伦理角度来看，有观点认为应该禁止或限制。 性爱机器人可能会改变人类的情感观念和性观念。 人类的情感和性是建立在人与人之间的互动基础上的，涉及到复杂的心理、生理和社会因素 。性爱机器人的出现可能会导致人们对真实的人际关系产生扭曲的理解。 例如，使用者可能会过度依赖机器人来满足性需求，从而减少对真实人类伴侣的情感投入和沟通。 这可能会对传统的婚姻和家庭观念产生冲击，引发一系列社会问题，如婚姻关系的不稳定、家庭凝聚力的下降等。\n性爱机器人的存在可能会引发道德争议，特别是在涉及到机器人的权利和地位问题上。 如果性爱机器人被设计得过于逼真，人们可能会对其产生类似对待人类的情感。 那么，是否应该给予机器人某种形式的“权利”，如不被虐待的权利等，这是一个尚未有定论的伦理困境。 此外，性爱机器人的研发和使用也可能会导致人类性观念的进一步开放和混乱，使得社会的性道德标准变得模糊不清。\n从社会影响角度看，性爱机器人可能会被用于非法和不道德的用途。 例如，容易成为传播色情内容的工具，尤其是当机器人的形象涉及儿童或被用于模拟非法的性场景时， 这会对社会的公序良俗和未成年人的身心健康造成严重的损害。 而且，大规模的性爱机器人的存在可能会改变社会的性别观念和性别关系。 如果机器人被设计成具有特定的性别特征，可能会强化社会中的性别刻板印象，或者导致对某些性别群体的不公正对待。\n根据主奴辩证法，依赖性爱机器人会形成虚假自由与自我奴役 在主奴辩证法中，主人虽然看似掌握权力，但实际上依赖奴隶的劳动维持其主导地位。这种依赖使得主人的自由是虚假的。 同样地，性爱机器人对使用者提供的“顺从”和“服从”可能让使用者感到掌控一切， 但由于这些互动是单向的、非自主的，使用者的满足感和自我认同可能是浅薄的。 性爱机器人的“服务”并没有通过相互承认的对话建立真实的主体性，因此使用者的自由和主体性也是不完整的。\n此外，人类成为了自己创造的技术的奴隶。这种依赖不仅局限于身体需求，还涉及情感和心理层面。 过度依赖性爱机器人可能削弱个体的情感自主性和社会互动能力，使得人类失去了通过复杂的关系获得自我提升的机会。\n也有观点认为不应该禁止。 从科技发展和商业角度来说，性爱机器人的研发是科技进步的一种体现。 机器人技术的发展可以带来许多创新的应用，性爱机器人只是其中之一。 在合理的监管下，这种研发可以推动机器人技术在材料、人工智能、机械设计等多个领域的进步。 例如，研发更加逼真的触感材料和自然语言处理技术可以用于提高性爱机器人的性能， 而这些技术也可以被应用到医疗康复机器人、服务机器人等其他有益的领域。\n从性健康角度来看 对于一些特殊人群，如性压抑人群或者残疾人群体，性爱机器人可能会提供一种相对安全和私密的性满足方式。 只要能够确保这种使用不会对他人和社会造成伤害，并且符合伦理道德标准， 例如通过严格的身份认证和使用场景限制，那么它也可以被视为一种解决方案。\n为了平衡这些不同的观点和利益，在不禁止的情况下，需要建立严格的监管机制。 对性爱机器人的研发设计进行伦理审查 确保机器人的形象、功能和使用场景不会违反社会道德和法律规定。\n在销售环节，要严格限制购买者的年龄和身份 防止其被用于非法目的。\n加强社会教育，引导人们正确看待性爱机器人 避免其对社会伦理观念和人际关系产生不良影响。\n什么是致命性自主武器？是否应该禁止或限制致命性自主武器的研发和使用？为什么？ 致命性自主武器是指能够在没有人类干预的情况下自主选择和攻击目标的武器系统。 这些武器通常利用先进的传感器、人工智能算法和武器技术来实现自主作战。 例如，一些军事无人机可以通过预先编程的算法和传感器探测系统，在识别目标后自动发射武器进行攻击。\n从伦理道德的角度来看 应该禁止或限制致命性自主武器的研发和使用。\n致命性自主武器的使用可能会导致责任归属的模糊。 当这些武器自主做出攻击决策并造成伤害时，很难确定责任是在于武器的编程者、使用者还是武器系统本身。 这种责任的不明确性违反了基本的道德原则，即人类应该对自己的行为和造成的后果负责。 在传统的战争和军事行动中，人类战士在做出攻击决策时会考虑到道德、法律和伦理因素， 如区分战斗人员和平民、评估攻击的必要性和比例性等。 而致命性自主武器可能无法像人类一样进行复杂的道德判断，从而增加了无辜人员伤亡的风险。\n致命性自主武器可能会降低发动战争的门槛。 如果一个国家可以通过使用致命性自主武器来进行军事行动， 而不需要承担太多的人员伤亡风险， 那么战争可能会变得更加容易被发起。 这会对国际和平与安全秩序造成严重的威胁，引发军备竞赛。 各国为了保持军事优势，可能会竞相研发和部署更先进的致命性自主武器，导致军事紧张局势不断升级。\n从法律层面来看 目前的国际人道法和战争法是基于人类的行为和决策制定的。 这些法律在面对致命性自主武器时存在明显的滞后性。 例如，在区分合法与非法目标、进行攻击的比例性评估等方面， 现有的法律框架很难适用于自主武器系统。 这就需要对法律进行更新和完善，但这是一个复杂且漫长的过程。 在法律尚未完善的情况下，禁止或限制致命性自主武器的研发和使用可以避免出现法律空白和滥用武器的情况。\n从技术风险角度看 致命性自主武器也存在诸多问题。人工智能算法的可靠性和安全性是一个关键问题 。算法可能会出现错误、被黑客攻击或者受到数据偏差的影响。 例如，一个被篡改的算法可能会导致武器系统攻击错误的目标， 或者在不需要攻击的时候发动攻击。 这种技术上的不确定性和风险使得致命性自主武器的使用变得极其危险。\n在一定程度上可以对致命性自主武器进行研究，但需要严格的限制和监管。 支持者认为，这些武器的某些技术，如先进的传感器和目标识别技术，可以用于非致命性的军事防御目的， 如边境监控、反海盗等。但这种观点也面临着巨大的挑战， 因为很难确保这些技术不会被用于致命性自主武器的研发和升级。\n综上所述，考虑到伦理道德、法律、国际安全和技术风险等多方面因素，禁止或限制致命性自主武器的研发和使用是十分必要的。\n什么是算法歧视？形成的原因是什么？如果解决算法歧视问题？ 算法歧视是指算法在决策过程中，由于数据偏差或算法设计等原因，偏向特定群体或不公平地对待某些群体的现象。 例如，在招聘算法中，如果算法是基于过去的招聘数据进行训练， 而过去的招聘数据本身存在对女性或者少数族裔的偏见， 那么这个算法在筛选简历时就可能会倾向于选择男性或者主流族裔的候选人， 从而对女性和少数族裔产生歧视。\n算法歧视形成的原因主要有以下几个方面。 数据偏差。 训练算法的数据往往是从现实世界中收集的， 而现实世界的数据可能本身就存在各种偏见。 例如，在犯罪预测算法中，如果用于训练的数据是基于过去的犯罪记录， 而过去的犯罪记录由于执法过程中的种族偏见等因素， 对某些种族群体的数据记录过多，那么算法在预测时就可能会高估这些群体的犯罪概率。\n设计偏见。 算法的规则和目标设定可能会无意中导致歧视。 例如，一个简单的信用评分算法可能只考虑了收入和资产等因素， 而忽略了一些弱势群体可能由于社会结构原因导致收入较低， 但实际上他们的信用风险并不高。 算法开发者在设计过程中如果没有充分考虑到公平性问题， 就容易产生歧视性的结果。\n反馈循环。 在一些推荐算法中，用户的行为数据会不断反馈到算法中，形成“反馈循环”。 这种反馈循环可能会逐渐放大原本的偏见。\n要解决算法歧视问题，可以从以下几个方面入手。 改进数据质量。 在收集和整理数据时，要确保数据的多样性和代表性，避免使用带有明显偏见的数据。 例如，在招聘算法中，要对过去的招聘数据进行清洗， 去除可能存在的性别、种族等方面的偏见信息， 并且主动收集不同群体的数据来平衡数据集。\n引入算法公平性评估。 在算法开发过程中，引入公平性约束条件。 例如，采用公平机器学习算法，这些算法在优化目标函数时， 除了考虑准确性外，还会考虑公平性指标。 同时，在算法设计阶段，要进行充分的公平性测试， 通过模拟不同场景和不同群体的数据输入， 检查算法是否会产生歧视性的输出。\n引入算法偏差测试。 定期对算法进行审计，评估算法是否存在歧视问题。 算法审计可以由内部的审查团队或者外部的独立机构来进行。 通过对算法的输入输出数据进行分析，检查是否存在对某些群体的不公平对待。 如果发现歧视问题，及时对算法进行调整和优化。\n提高算法的透明度与解释性。 让算法的决策过程更加透明，使得用户和监管者能够理解算法是如何做出决策的。 例如，对于一些影响重大的算法， 如信贷审批和司法量刑算法，要求提供决策的解释， 这样可以帮助发现潜在的歧视因素。\n用户反馈和持续优化。 允许用户标记算法的不公平现象，以便于追踪和优化。 通过收集用户反馈不断更新算法，确保其适应多样化的需求。 实行定期评估和调整，避免算法逐渐偏向某类用户或群体。\n在人工智能和大数据时代，个人隐私还存在吗？如何才能更好地保护隐私？ 在人工智能和大数据时代，个人隐私依然存在，但面临着前所未有的挑战。 现状 随着人工智能和大数据技术的发展，个人数据的收集和处理变得更加广泛和精细。 人工智能依赖于大量的数据，尤其是用户的个人数据、行为数据等，用以训练模型和进行预测分析。 大数据技术使得我们能够从海量的数据中提取出与个人行为和偏好相关的信息， 这些信息一旦泄露或滥用，将对个人隐私构成严重威胁。\n例如，许多社交媒体平台和搜索引擎会通过收集用户的浏览历史、搜索记录、地理位置等数据来推送定制广告。 这些数据的收集和使用往往是在用户未完全意识到的情况下发生的， 造成了隐私泄露的风险。 此外，数据泄露事件频发，许多公司由于保护不当而导致用户数据的大规模泄露，给个人隐私带来了极大风险。\n然而，虽然技术和社会环境的变化让隐私面临压力， 但通过法律保护、技术创新以及公众意识的提高，个人隐私仍然可以得到有效的保护。\n隐私保护 法律法规不断完善来保护个人数据权益。 隐私保护首先要依靠法律。在许多国家和地区，隐私保护法律正在逐步完善。 例如，欧盟的《通用数据保护条例》（GDPR）规定了对个人数据的严格保护， 要求企业必须获得用户同意才能收集其数据，并且允许用户要求删除或更正个人数据。 各国应尽快制定类似法律，加强隐私保护的力度，确保数据收集和使用符合公平和透明的原则。\n隐私保护技术不断发展。 加密技术是保护隐私的关键手段之一。 通过对数据进行加密，即使数据在传输过程中被截取或者在存储过程中被非法访问， 没有解密密钥，数据也无法被读取。 例如，端到端加密技术在即时通讯应用中得到广泛应用，确保只有通讯双方能够读取消息内容。\n差分隐私技术也是一种新兴的隐私保护技术。 它通过在数据集中添加噪声的方式来进行数据分析， 使得在不泄露个体隐私的情况下仍然能够获取有价值的总体数据信息。 例如，在统计某种疾病的发病率时， 通过差分隐私技术可以在不暴露个体是否患病的情况下 得到准确的发病率统计数据。\n个人也需要增强隐私保护意识。 在使用各种数字产品和服务时，要仔细阅读隐私政策， 了解自己的数据是如何被收集、使用和共享的。 并且，要谨慎授予应用程序各种权限，如位置权限、通讯录权限等，只授予必要的权限。\n企业作为数据收集者和使用者，也有责任保护用户隐私。 企业应该建立完善的数据安全管理体系，加强数据安全防护措施，防止数据泄露。 同时，要提高数据处理的透明度，向用户明确说明数据的用途和处理方式。\n加强教育和宣传，提高全社会对隐私保护的重视程度也是非常重要的。 通过开展隐私保护知识培训和宣传活动， 让人们了解隐私的重要性和隐私保护的方法，营造一个良好的隐私保护社会环境。\n作为计算机专业的学生，你如何看待人工智能的未来？ 作为计算机专业的学生，我认为人工智能的未来充满了机遇和挑战。 从机遇方面来看，人工智能将推动各个领域的技术创新和产业升级。 在医疗领域，人工智能可以帮助医生进行疾病诊断。 例如，通过对大量的医学影像（如X光、CT等）进行分析， 人工智能算法能够快速准确地发现病变特征，辅助医生做出更精准的诊断， 提高诊断效率和准确性。同时，人工智能还可以用于药物研发， 通过对药物分子结构和疾病靶点的模拟分析，加速新药的研发过程。\n在交通领域，自动驾驶技术是人工智能的一个重要应用方向。 它有望提高交通效率，减少交通事故。 通过传感器和复杂的算法， 汽车能够感知周围环境并做出智能决策，实现自动行驶。 这不仅可以缓解交通拥堵，还能为人们提供更加舒适和安全的出行体验。\n在教育领域，人工智能可以实现个性化学习。 通过对学生学习数据的分析，如学习进度、知识掌握程度等， 人工智能可以为每个学生量身定制学习计划， 提供针对性的学习内容和辅导，提高学习效果。\n在工业制造领域，人工智能驱动的智能制造可以提高生产效率和产品质量。 机器人可以在人工智能的控制下进行复杂的生产操作， 通过对生产数据的实时监测和分析，及时发现生产过程中的问题并进行调整。\n人工智能的未来也面临着诸多挑战。 算法偏见问题 这可能会导致不公平的决策。 如前面提到的在招聘、信贷等领域， 由于训练数据的偏见或者算法设计的缺陷， 可能会对某些群体产生歧视性的结果。 解决算法偏见问题是人工智能健康发展的关键。\n伦理问题。 例如，人工智能在军事领域的应用可能会引发人道危机， 如致命性自主武器的研发和使用。 在日常生活中，人工智能也会涉及到隐私侵犯、数据滥用等伦理问题。 如何在发展人工智能的同时，遵循伦理道德原则，是需要深入思考的问题。\n失业问题。 随着人工智能技术的发展， 一些重复性、规律性强的工作可能会被人工智能系统和机器人所取代。 例如，一些数据录入员、客服代表等岗位可能会受到影响。 这就需要社会建立完善的职业培训和再就业体系，帮助人们适应新的就业环境。\n作为计算机专业的学生 我们要积极参与到人工智能的研发中，致力于开发更安全、公平、符合伦理的人工智能系统。\n在算法设计阶段，要充分考虑公平性和安全性，避免算法偏见。 作为计算机专业的学生，我们应关注AI伦理问题，从数据采集到算法设计， 都要考虑如何避免偏见、保护隐私、保证公平性，确保AI技术符合道德规范。\n要加强与其他领域的合作，共同制定人工智能的发展规则和伦理准则。 如伦理学、法学等，推动人工智能健康、可持续地发展。\n","date":"2025-01-09T10:30:30+08:00","permalink":"https://demiurge-zby.github.io/p/%E6%B3%95%E5%BE%8B%E7%A7%91%E6%8A%80%E4%B8%8E%E7%A4%BE%E4%BC%9A/","title":"法律、科技与社会"},{"content":" 说在前面 本系列从P6上机结束开始制作，因此靠前的一些P可能记不清楚 本系列主观色彩较强，不过尚有一定准确信息 作者在P6献出首挂，并玉玉了一周（？） 接下来，就以我的吐槽为主了\nPre上机 考三道题，分别为logisim,verilog,MIPS\n原120min延时到180min\nlogisim考查：\n同步复位：不能使用clk和reset的与（clk在上升沿与clk == 1是两个概念！）\n正确的方法：1. 用reset，MUX控制输入数据，再把修正后的数据传给寄存器 2. 不使用MUX，而是将reset取反（再位拓展）后与Data与起来(reset==1时，结果为0\u0026amp;Data=0)，这样来控制输入数据 实质上两种方法都是保证给要写入寄存器的值做一个实时修正 保证只有上升沿那一瞬间，才能决定是否进行复位\n状态机： 已经很久远了，个人认为把斐波那契这种高阶的弄会就好\n加入An传进寄存器1，再传进寄存器2，再传进寄存器3, 那么当寄存器3为An时，寄存器2即为A(n+1)，寄存器1为A(n+2) 这就是logisim里暂时保留数据若干个时钟周期的途径\nverilog和MIPS考得都很水\n建议一定要学好verilog的组合逻辑循环怎么写 或者你能够熟练地打表 让你求32位的和，你就用C写出来一个a[0]+a[1]+\u0026hellip;倒也未尝不可\n1 2 3 4 5 always@（*）使用说明 0.全使用= 1.初始化（所有变量） 2.全是reg型和integer型 3.有用的东西最后再assign到某个wire变量上去 P0上机 三道题，logisim练习\n原120min延时到180min\n是谁国庆前一晚还在上机啊\n但是贴心的助教们出了一次极水极水的题！\n考察内容：善于封装子模块、Mealy(米利)机和Moore(摩尔)机的判别\n大家都是一路AC\n我WA了一次，比较器要设置成Unsigned！！！\nP1上机 三道题，verilog练习\n原120min延时到180min\n一般是一个简单的组合逻辑加两个状态机\n本来以为没有延时，差点以为要挂了，所以第二题做出来就开始摆了\n错因没有什么价值，纯粹打错符号了\n第三题是一个很复杂的状态机 难度堪比cpu_checker(笑)\n最后搭出来WA了几个点，也没弄明白WA在哪\nP2上机 三道题，MIPS练习\n原120min延时到180min\nT1 未给出C代码 题面如下：\n已知b,m,n，在[m,n]中找出一个整数a，使得a%b最小，输出a%b 看起来还唬唬人，但是真从m循环到n不动一点脑子肯定是会TLE的\n这东西他让你输出的是余数，那可就太简单了 要么是0，要么是m%b 如果是0，说明m到n存在b的倍数，那么n/b就不等于m/b 所以其实就是考察div,mfhi,mflo的使用 伪代码如下\n1 2 3 4 5 6 if (m / b != n / b) { printf(\u0026#34;0\u0026#34;); } else { printf(\u0026#34;%d\u0026#34;, m % b); } 有没有\\n我忘了（）\nT2考循环T3考递归 都有C语言代码，静静翻译就好，一般不会有bug 如果有，着重检查你的bgt,blt,beq,bne等等是否写反\n递归就着重两个字“保护” 保护的时间是jal前和jal后（物理意义，不是代码执行顺序） jal前表示进入递归之前做好现场保护 jal后则是退出上一层递归回到jal的PC+4的位置,恢复当时现场\nP3上机 终于来到我们的CPU阶段！ 以及闯关制的开始。\n最后一次使用logisim\n自此开始，课上是否通过基本等价于课下搭的CPU是否有误\n三道题，新指令添加\n原120min延时到150min（这个不同届不一样）\n本次没有明显感受，难度不太高 课下的记忆点更充实些\nP4上机 三道题，新指令添加\n120min 无延时。\n题目也不难，和T3难度相当\n作者没能AK。\n因为有课下bug!!!!!\n但是这个bug太小了。 jr $rs而非jr$31\n玉玉随笔：\n历经了轮轮评测， 也从未想过要在课上debug。 但我看到了完全与题意无关的报错信息， 我意识到了课下着实存在着的bug， 我惊惶，但又或是接受，接受我真的会在P4倒下，会在这条闯关路上走得一坨烂泥。 在课上最终de出了bug，确是万幸。 只是那瞬间，无休止的荒诞涌进一触即破的思绪， 畏惧后怕质疑庆幸猛地迸发开来， 只留呆滞的躯体挪动着不太灵光的鼠标， 看着界面的圆圈转着转着，拉着我去和P4说再见了。 P5上机 120min 无延时。\n课上过一题 = 课下没问题 = P5必通过！\n前两题顺风顺水 第三题做的悠哉悠哉不知不觉只剩10min\n交了一发 10个点过9个 挂了个TLE\n意识到这题卡时间 阻塞条件再细化 但是始终没有落实到寄存器冲突上 再交还是TLE 只剩下2min了 那 就交卷吧\n越是静下来，越是容易意识到问题关键 为什么当时不把那17个寄存器都排除呢？ 阻塞条件一定要细化！！ 只是担心于它的不确定性，怎么不去研究他的变化范围。\n2min很漫长。等了很久，等考试结束， 等未通过的同学都离开考场， 等问答环节来临， 我问助教究竟要优化到什么等级： 答案显然。 对于一定不被写的15个寄存器，不会有转发当然不必阻塞。\nP6上机 —— 1 史上最惊为天人的一集\n真的有人课下没bug课上还能全挂？！！\nT1时序逻辑掺组合逻辑 在乘除模块里求最高位1最低位0结果一直输出xxxx 结果是因为没初始化 一de就是80min\nT2更是荒谬 32位累加没有设置位宽 这么简单的问题在当时混乱的大脑下藏了40min\n后续又做了一堆无用功，漫无目的地构造测试数据，感动自己地打表等等。。\n最终以0题通过幸终。\nP6上机 —— 2 时隔一个月的90min AK\n怀揣着极度的不安与不满，\n因为我真的不能保证我的课下确无问题。\n就这样 踏入了大家都在P7gap的空旷的考场\nT1已经退化成add类指令了。。 只是写入的值换成add结果的最高位1\n最高位1？这我可太熟了（苦笑 这不上周给我绊死的那位嘛 这周周中好好地跟他清算了一波 没想到还能见面，那就再也不见了\nT2一看条件存储，我先跳了\nT3经典跳转类 完成基础功能TLE最后一个点 乘除模块偷跑却又超速一个点 意识到不能暗改乘除 但是我也不知道怎么做\n此时我智慧的大脑居然认为测试点出错了 肯定有死循环 不然我有的点过快了这个点还能过慢？\n然后去做P2了 大致扫一眼：什么条件跳转。。原来是标题欺诈。 再定睛一看：啊？又是最高位1？ 只是把DM写的地址加上了一个与最高位1有关的数\n最麻烦的事大抵也就是DMWr的位扩展 但是还好我提前改成三位了\nT2过关，我开始回去看T3\n诶诶 这个T3一个点TLE 这不就是我的P5吗？？\n我P5的反思居然还派上用场了 我开始去思考我的阻塞\u0026hellip;\u0026hellip; 用不到，不需转发就不阻塞！！ 又写了四行优化阻塞逻辑 交了一发终于AC。\n最后，还是喷一下上周。 课下无bug课上全挂真是神人了。\n另外，如果感觉自己课下没bug还课上全挂的别担心 你的课下可能确无bug 考场上的蠢度永远是自己无法想象的。\nP7上机 —— 1 紧接上文，考场外的蠢度你也无法想象。\n四道强测： 功能强测 异常强测 中断强测 冒险强测\n一道附加指令：Withdraw\n120min\n刚开始交前四题，全挂。\n我有点崩溃，但是看到大家也是一片红，我深深感觉到强测之强。\n（其实很多人都一遍过，只是我没看见）\n直到\u0026hellip;\u0026hellip;zzy 60min交卷 zjy 70min交卷\n我开始怀疑自己是不是真的写的太烂了。\n一直到我看到ALE里面没引入Instr，我终于意识到： 我最新版没提交！！！\n一瞬间，像是通过了一束电流，整个人呆住了。\n急忙地改回代码，中间还改错了一次，漏写了一个接口，让我期待落空了几分钟。。\n不过当我把新版本改好，漫长的排队等待\u0026hellip;\u0026hellip;\n绿了，绿了，红了？绿了？ 还差一个中断异常，有2个点挂了。\n中断区别于异常，我觉得比较易错的是空泡的处理，琢磨了一段时间，我好像意识到自己应当采用两种不同的流水方式。\n但是这时已经8:55了。如果我提交并通过，我将没有机会再去不通过。\n我迟迟没有提交。\n我只顾着懊悔为什么没提交最新版，却没想到其实我可以先把前面一道题弄错，从而能够判断这题能不能过的同时顺利不通过。\n希望能给大家一点启发吧。\nUpdate 12.3\n没想到中测就能测出来这个问题。\n我特意交了一版没修改nop流水方式的，居然挂掉了一个点，和当时中断强测的点略有类似。\n而且修改之后便通过了。\n那可能，就是这样了？\n我好像安定下来了，但又诚惶诚恐。\n跟P6好像啊，一场考试下来还不知道自己课下还有没有问题。\n据说加指令的题也不简单。2h能拿下吗？\n紧张，紧张。\nP7上机 —— 2 在开考前进行了龙芯杯的宣讲。 考试时间7:40-9:40，注意时间把控。\n其实对自己的MIPS还是略带自信的，因为我确实不相信他会加强测试点。\n建议下载压缩包后直接速提交，不要再做解压，或是装进ISE等事项。你要提交的就是源代码。\n否则就会喜提20min的gap，心神不宁地排300余人的队\n强测过了之后，完全不可懈怠！一定要严谨严肃。\n本次题目为： 添加异常WATCH 触发方式有二：IMWATCH与DMWATCH\nPC0添加18号寄存器与19号寄存器（支持正常读写）\n19号寄存器为异常判断使能 18号寄存器高16位是IM敏感值，低16位是DM敏感值\n异常逻辑就是 当前pc与IM敏感值相同时且19号寄存器使能满足要求时触发IMWATCH DM敏感值在sl指令读写地址范围内时且19号寄存器使能满足要求时触发DMWATCH\n几个注意点：\n异常优先级。以往的异常是不会同时出现的，而如今IMWATCH随时可触发，DMWATCH可以与ADEL,ADES同时触发 IMWATCH优先级低于取指异常，高于其他异常。 DMWATCH优先级低于ADES,ADEL（对于同时出现的异常） 范围内。对于DMWATCH注意要匹配的是在范围内，如sw，DM敏感值是四个值中的一个即可。 这里我们可以大胆用ADDR\u0026lt;= watchaddr \u0026lt;=ADDR+3, 他一定字对齐，否则会出现优先级更高的ADES异常。\n乘除槽。IMWATCH可以在任何指令上触发，因此乘除法也可能是异常指令，不能等到他走到M级在检测出来，此时为时已晚，乘除槽停不下来。 因此需要提前判断好IMWATCH异常，将其加入MDALU模块。 阻塞。mtc0 18和19都是危险的，会直接影响WATCH的判断，因此必须阻塞。 这决定了IMWATCH不能在F级判断，因为这样会使D级为mfc0 18,19也需要阻塞，而这会导致死循环，因为我们的阻塞逻辑就是在D级实现的，那么mtc0就被卡在D级不得动弹。\n在D级判断IMWATCH是较为正确的选择。\n作者其实没有一交即过。 让我以为这个测试很强。\n其实是因为写成了CP018号寄存器31:16 == pc[31:16]\u0026hellip;\n应该是CP018号寄存器31:16 == pc[15:0]， 或者{16\u0026rsquo;b0,CP018号寄存器31:16} == pc.\n改完没想到就直接过了。 一瞬间，惊喜而释然。\n说在最后 计组上机就这样圆满结束了。\n在提问环节，助教问我： 你觉得你在计组闯关的收获是什么？\n回首，一路走来实在坎坷。\nPre的茫然 P1的无力 P4的惊愕 P5的懊悔 P6的愚钝 P7的畏惧\n平稳，或是激荡地 每一个Project都有着课上课下的呐喊\n从第一个单周期CPU 到封装流水线CPU可支持中断支持外设支持异常处理支持30余条指令的MIPS微系统 诞辰不久的博客也日渐丰满\n这像是一种高压下的凝聚 引领着我们去稳健处理庞大的项目\n从形象框架到代码实现 从独立执行到高效流水 从单一指令到复杂延时 从固定运行到异常中断\n不同的Project把步骤分离 并予以较强的正确性检查 使得P5不必担心P4部件的实现 P6不必担心P5转发阻塞的实现 P7不必担心P6CPU本身的实现\u0026hellip;\n未来的项目倘若没有这些具象的规划 根本不敢想有多困难。\n当然，感谢每一位同行者的帮助与支持。非常感谢。\nCO上机结束，我也终于可以好好躺下，大脑放得很空很空，吸入又呼出些跳动的空气，悄悄捕捉又一颗充满爱与自由的心。\n","date":"2024-12-10T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-co-%E4%B8%8A%E6%9C%BA/3c7fe802fe677d02b6b3708d9f40249_hu9209242832316334602.png","permalink":"https://demiurge-zby.github.io/p/buaa-co-%E4%B8%8A%E6%9C%BA/","title":"BUAA CO 上机"},{"content":" 说在前面 还得是设计文档。 每次一旦盯着理论看，又想看全又想做细，就会陷入P5当时的茫然 总是想一针见血地写出最有远见卓识的代码，当然会踌躇，更何况还未必能写出来。 但是一步一步走出来，也就走出来了。\n设计文档 在对P7的整体内容有了把握之后，我们可以知道，本次P7主要要完成的任务是：\n更改流水线各级使之可以产生异常 添加 CP0 与 异常处理 添加 Bridge 与两个外设（计时器）交互 ExcCode的产生与流水 根据教程的表格，我们可以得到：\n异常与中断码 助记符与名称 指令与指令类型 描述 0 Int （外部中断） 所有指令 中断请求，来源于计时器与外部中断。 4 AdEL （取指异常） 所有指令 PC 地址未字对齐。 4 AdEL （取指异常） 所有指令 PC 地址超过 0x3000 ~ 0x6ffc。 4 AdEL （取数异常） lw 取数地址未与 4 字节对齐。 4 AdEL （取数异常） lh 取数地址未与 2 字节对齐。 4 AdEL （取数异常） lh, lb 取 Timer 寄存器的值。 4 AdEL （取数异常） load 型指令 计算地址时加法溢出。 4 AdEL （取数异常） load 型指令 取数地址超出 DM、Timer0、Timer1、中断发生器的范围。 5 AdES （存数异常） sw 存数地址未 4 字节对齐。 5 AdES （存数异常） sh 存数地址未 2 字节对齐。 5 AdES （存数异常） sh, sb 存 Timer 寄存器的值。 5 AdES （存数异常） store 型指令 计算地址加法溢出。 5 AdES （存数异常） store 型指令 向计时器的 Count 寄存器存值。 5 AdES （存数异常） store 型指令 存数地址超出 DM、Timer0、Timer1、中断发生器的范围。 8 Syscall （系统调用） syscall 系统调用。 10 RI（未知指令） 未知指令 未知的指令码。 12 Ov（溢出异常） add, addi, sub 算术溢出。 根据教程的要求，我们容易知道，只需分析好每一个部位可能产生的异常，然后随着流水线流水即可。 同一条指令在某一个阶段不会产生多种异常。（这由异常的划分方式确定） 但是一个阶段可能存在多个异常。其处理顺序为先来后到。也就是处理最老的指令，执行到最后面的指令的新错误。\n有人说，你这样做就是只处理最新的错误啊，怎么保证处理了最新的错误还能处理旧的错误呢？\n这是因为处理异常的方法是把句子变成nop，并重新从受害指令下一条开始执行。 这样，未被处理的指令的错误就会重新展现出来，再次被处理。\n我们决定，传入流水线的ExcCode，是要经过一个有优先级的多路选择器的。 为了区分，我们命名为\nExcCode_X(本阶段产生的) 和ExcCode_X_true(实际传入流水线的) 以及ExcCode_X_last(流水线传进来的)\n接下来就来判断异常吧。 我打算根据流水级来进行分类处理。\n注意： Int表示外部中断，更表示此处无异常。因此ExcCode可以大胆赋0，具体是否中断还要看外部信号。\n附一个可能用到的表格：\n条目 地址或地址范围 备注 数据存储器 0x0000_0000∼0x0000_2FFF 指令存储器 0x0000_3000∼0x0000_6FFF PC 初始值 0x0000_3000 异常处理程序入口地址 0x0000_4180 计时器 0 寄存器地址 0x0000_7F00∼0x0000_7F0B 计时器 0 的 3 个寄存器 计时器 1 寄存器地址 0x0000_7F10∼0x0000_7F1B 计时器 1 的 3 个寄存器 中断发生器响应地址 0x0000_7F20∼0x0000_7F23 我们使用以下宏定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 `define Exc_AdEL 5\u0026#39;d4 `define Exc_AdES 5\u0026#39;d5 `define Exc_Syscall 5\u0026#39;d8 `define Exc_RI 5\u0026#39;d10 `define Exc_Ov 5\u0026#39;d12 `define IM_start 32\u0026#39;h3000 `define IM_end 32\u0026#39;h6fff `define DM_start 32\u0026#39;h0000 `define DM_end 32\u0026#39;h2fff `define T0_start 32\u0026#39;h7f00 `define T0_end 32\u0026#39;h7f0b `define T1_start 32\u0026#39;h7f10 `define T1_end 32\u0026#39;h7f1b `define T0_count_start 32\u0026#39;h7f08 `define T0_count_end 32\u0026#39;h7f0b `define T1_count_start 32\u0026#39;h7f18 `define T1_count_end 32\u0026#39;h7f1b `define Int_generator_start 32\u0026#39;h7f20 `define Int_generator_end 32\u0026#39;h7f23 ExcCode_F 我们发现只能发生： AdEL: PC未字对齐或PC超界\n1 2 3 assign ExcCode_F = ((pc_F[1:0] != 2\u0026#39;b0) || pc_F \u0026lt; `IM_start || pc_F \u0026gt; `IM_end) ? `Exc_AdEL : 0; assign ExcCode_F_true = ExcCode_F; ExcCode_D D级的核心工作是译码。\nRI：未知指令 Syscall: 系统调用\nRI与Syscall信号也由Ctrl译码时顺带产生。\n1 2 3 4 5 6 assign RI = !(nop || add || sub || And || Or || slt || sltu || lui || addi || andi || ori || lb || lh || lw || sb || sh || sw || mult || multu || div || divu || mfhi || mflo || mthi || mtlo || beq || bne || jal || jr || mfc0 || mtc0 || eret || syscall); assign Syscall = syscall; 1 2 3 4 5 assign ExcCode_D = (Syscall) ? `Exc_Syscall : (RI) ? `Exc_RI : 0; //此处虽然有优先级，但是两者是不会同时发生的 assign ExcCode_D_true = (ExcCode_D_last) ? ExcCode_D_last : ExcCode_D; //优先级，同一指令按最老的错误来 ExcCode_E AdEL: 计算load地址时加法溢出\nAdES：计算store地址时加法溢出 Ov:add,addi,sub的算数溢出\n这些信号利用ALU模块得出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 wire overflow_add; wire overflow_sub; wire [32:0] ext_num_1; wire [32:0] ext_num_2; wire [32:0] ext_add; wire [32:0] ext_sub; assign ext_num_1 = {num_1[31], num_1}; assign ext_num_2 = {num_2[31], num_2}; assign ext_add = ext_num_1 + ext_num_2; assign ext_sub = ext_num_1 - ext_num_2; assign overflow_add = ext_add[32] ^ ext_add[31]; assign overflow_sub = ext_sub[32] ^ ext_sub[31]; assign Ov = ((add || addi) \u0026amp;\u0026amp; overflow_add) || (sub \u0026amp;\u0026amp; overflow_sub); assign AdEL_E = (DMRd_E) \u0026amp;\u0026amp; overflow_add; assign AdES_E = (DMWr_E) \u0026amp;\u0026amp; overflow_add; 大错特错！大错特错！！！\n1 2 assign Ov = (((ALUOp == `ADD) || (ALUOp == `ADDI)) \u0026amp;\u0026amp; !DMRd_E \u0026amp;\u0026amp; !DMWr_E \u0026amp;\u0026amp; overflow_add) || ((ALUOp == `SUB) \u0026amp;\u0026amp; overflow_sub); de出这个bug真费了不少功夫。 第一次de出来是意识到ALUOp是ADD,未必指令就是ADD, 还有可能是store与load指令！！\n结果还没过。。\n这次很随便一个数据居然de出来了 因为一条ori指令出现了Ov!!!\n这让我感到极为震惊。我就看了看Ov的所有相关信号———— 当我看到add,并发现它是一个32位数时\u0026hellip;\u0026hellip;\n太抽象了！！！！！ add原来是数据信号啊不是控制信号！！！ 控制信号是ALUOp！！！！！\nUpdate 12.1: 这也太抽象了！！！ 感谢COKiller!!! 没想到能在这里de三次。。\n第一次是因为sw犯了Ov 第二次是因为ori犯了Ov 第三次是因为div犯了Ov!!!!!!!\n天打五雷轰。\nmultu,divu乃至于mfc0，mfhi都在ALUOp对应ADD！！！\n所以我老实了。 我直接把Instr传到E级，由Instr指导is_ADD。\n1 2 3 4 assign is_ADD = (Instr_E[31:26] == 6\u0026#39;b000000) \u0026amp;\u0026amp; (Instr_E[5:0] == 6\u0026#39;b100000); assign Ov = ((is_ADD || (ALUOp == `ADDI)) \u0026amp;\u0026amp; overflow_add) || ((ALUOp == `SUB) \u0026amp;\u0026amp; overflow_sub); 这样应该就没有问题了罢。。\n1 2 3 4 5 assign ExcCode_E = (AdEL_E) ? `Exc_AdEL : (AdES_E) ? `Exc_AdES : (Ov) ? `Exc_Ov : 0; assign ExcCode_E_true = (ExcCode_E_last) ? ExcCode_E_last : ExcCode_E; ExcCode_M AdEL:\nlw,lh字对齐 lh,lb取Timer 超范围 AdES:\nsw,sh字对齐 sh,sb写Timer 所有store写Count寄存器 超范围 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 assign AdEL_M = (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMRd_M == `LW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); assign AdES_M = (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMWr_M == `SW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_count_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_count_end) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end)) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end)) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end)) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); assign ExcCode_M = (AdEL_M) ? `Exc_AdEL : (AdES_M) ? `Exc_AdES : 0; assign ExcCode_M_true = (ExcCode_M_last) ? ExcCode_M_last : ExcCode_M; 好嘞笑死了，已经被自己蠢死了\n应当改为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 assign AdEL_M = (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMRd_M == `LW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); assign AdES_M = (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMWr_M == `SW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_count_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_count_end) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); 不同的异常类型确实应该或起来，但是地址越界是一种异常！！ 必须同时满足在所有区域之外！内部表述应使用与\nW级不产生异常。 至此，我们貌似写完了所有异常。\nCP0及异常处理 我们一般将CP0放进M级。 这意味着指令异常在M级进行处理。\n这形成了单周期CPU的封装： 一般认为M级指令为正在执行的指令。 一般认为PC_M即为宏观PC。 一般认为W级处的指令是已完成的指令。 一般认为F,D,E级的指令都是未开始执行的指令。\n一旦有这样单周期的认知，那么 出现异常就是指M级指令出现异常; 受害PC即为M级PC。 或者说，任何指令在某一流水级产生的异常， 都要等待该指令进入M级才可被处理。\nCP0基础信息 课程组给出的接口表格：\n端口 方向 位数 解释 clk I 1 时钟信号 reset I 1 复位信号 en I 1 写使能信号 CP0Addr I 5 寄存器地址 CP0In I 32 CP0 CP0Out O 32 CP0 VPC I 32 受害PC BDIn I 1 是否是延迟槽指令 ExcCodeIn I 5 记录异常类型 HWInt I 6 输入中断信号 EXLClr I 1 用来复位 EXL EPCOut O 32 EPC 的值 Req O 1 进入处理程序请求 课程组给出的关键寄存器信息：\n寄存器 编号 功能 SR 12 配置异常的功能 Cause 13 记录异常发生的原因和情况 EPC 14 记录异常处理结束后需要返回的PC 课程组给出的关键功能域：\n寄存器 功能域 位域 解释 SR（State Register） IM（Interrupt Mask） 15:10 分别对应六个外部中断，相应位置1表示允许中断，置0表示禁止中断。这是一个被动的功能，只能通过mtc0这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。 SR（State Register） EXL（Exception Level） 1 任何异常发生时置1，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。 SR（State Register） IE（Interrupt Enable） 0 全局中断使能，该位置1表示允许中断，置0表示禁止中断。 Cause BD（Branch Delay） 31 当该位置1时，EPC指向当前指令的前一条指令（一定为跳转），否则指向当前指令。 Cause IP（Interrupt Pending） 15:10 6位待决的中断位，分别对应6个外部中断，相应位置1表示有中断，置0表示无中断。每个周期将会被修改一次，修改的内容来自计时器和外部中断。 Cause ExcCode 6:2 异常编码，记录当前发生的是什么异常。 EPC - - 记录异常处理结束后需要返回的PC。 对于关键域，我们使用宏定义以方便书写：\n1 2 3 4 5 6 `define IM SR[15:10] `define EXL SR[1] `define IE SR[0] `define BD Cause[31] `define IP Cause[15:10] `define ExcCode Cause[6:2] 对于CP0，它的主要功能即为 存储异常中断的相关信息，表征异常中断的开始与结束， 引导转向异常中断模块处理与退回原指令。\n判断异常中断的发生 1 2 3 4 5 6 7 wire Exc_req; wire Int_req; assign Exc_req = (ExcCodeIn != 5\u0026#39;b0) \u0026amp;\u0026amp; (`EXL == 1\u0026#39;b0); //我们不太确定EXL为1时能否触发异常。但是其实我是把EXL==1当成全局异常判断使能看待的 assign Int_req = (|(HWInt \u0026amp; `IM)) \u0026amp;\u0026amp; `IE \u0026amp;\u0026amp; (`EXL == 1\u0026#39;b0); assign req = Exc_req || Int_req; 这里比较巧妙的是 (|(HWInt \u0026amp; `IM)) 这一语句\n巧妙使用了按位与，先得到各个信号是否中断且中断是否被允许 然后再把这6位或起来（不或也可以）\n当然最后不能忘了全局使能与EXL限制\n存储异常中断的相关信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 always @(posedge clk) begin if (reset) begin SR \u0026lt;= 0; Cause \u0026lt;= 0; EPC \u0026lt;= 0; end else begin `IP \u0026lt;= HWInt; if (req) begin `EXL \u0026lt;= 1\u0026#39;b1; EPC \u0026lt;= (BDIn) ? (VPC - 32\u0026#39;d4) : VPC; `ExcCode \u0026lt;= (Int_req) ? 5\u0026#39;b0 : ExcCodeIn; `BD \u0026lt;= BDIn; end if (EXLCLr) begin `EXL \u0026lt;= 1\u0026#39;b0; end end end `ExcCode \u0026lt;= (Int_req) ? 5\u0026rsquo;b0 : ExcCodeIn; 这句话是表明优先级的，Int与Exc的区别，在CP0中就是靠Cause寄存器来展现。 如果同时发生Int与Exc，如何保证Int优先？ 只需一个三目运算符，先判断中断。\nEPC \u0026lt;= (BDIn) ? (VPC - 32\u0026rsquo;d4) : VPC;\n这句话体现了BDIn的功能。 如果这句话是延迟槽语句，那么你应当保证跳转指令正常进行。如果你只重新执行延迟槽，跳转指令就不能实现。 那么此时我们就不采用直接重新执行受害指令的方法，而是采用执行受害指令前一句的分支跳转。\n但是为什么可以选择执行受害指令上一句？ 这样的做法无疑是执行了两遍这一指令。\n但是正因为它是跳转指令，它并没有累加效应。 就连唯一有写功能的jal也只会写他对应的那一个值。\n那就有人说，你这不是钻空子吗？万一添加个新跳转指令，让你给$ra写当前$ra的值加4，这不就完了吗？\n新指令在W级，延迟槽在M级判出问题（或中断）。这样的话你完全来得及让第一次的写入无效，只需把W级写使能修改一下，把BDIn和req引出去，并说明这个时候不能写入。\n诶诶，那又有人问了，你这么写不就说明你的写使能是可能最后突然改变的，那你之前要是执行过转发怎么办？\n这就不得不说咱们的单周期思想了。在异常中断面前，M级以前的指令都相当于没有执行。转发给你啥都无所谓。\n那就又有人问了，M级本身要是被转发了怎么办？\n害，M级如果发生异常中断了，那就也需要重新执行，也相当于未执行指令。\n好，一段小思考结束了。\n写入关键寄存器 这一操作也应在CP0中完成 其实也只是添加了如下内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /*always @(posedge clk) begin if (reset) begin SR \u0026lt;= 0; Cause \u0026lt;= 0; EPC \u0026lt;= 0; end else begin `IP \u0026lt;= HWInt; if (req) begin `EXL \u0026lt;= 1\u0026#39;b1; EPC \u0026lt;= (BDIn) ? (VPC - 32\u0026#39;d4) : VPC; `ExcCode \u0026lt;= (Int_req) ? 5\u0026#39;b0 : ExcCodeIn; `BD \u0026lt;= BDIn; end if (EXLCLr) begin `EXL \u0026lt;= 1\u0026#39;b0; end*/ if (en \u0026amp;\u0026amp; !req) begin //执行mtc0时发生中断，则不予写入 case (CP0Addr) 5\u0026#39;d12 : begin SR \u0026lt;= CP0In; end 5\u0026#39;d14 : begin EPC \u0026lt;= CP0In; end default: begin end endcase end/* end end*/ 但是具体en，CP0Addr，CP0In怎么得到，那就是CP0外部的事了。\n在这里我还是打算直接写好。因为这确实是一块很小的，而且与下一部分关系不大的内容。\n核心就是添加mtc0,mfc0指令，放进流水线等等。\n这个和mfhi,mthi的逻辑几乎完全相同。\n先分析mtc0吧，只需要在M级给CP0的en接口接上Mtc0_M 写的地址是rd_M 写的内容是MemData_M\n注意控制信号Tuse_rt = 2\nmfc0要注意RFWr置1，Tnew = 2 写的地址是rt 写的内容是RegData\n1 2 assign RegData = Mfc0_W ? CP0Out_W : WdSel_W ? MemReadData_W : ALUData_W; 可以发现CP0Addr始终为rd,所以直接让该端口接rd_M。\n整体来说是这个样子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CP0 Cp0( .clk(clk), .reset(reset), .en(Mtc0_M), .CP0Addr(rd_M), .CP0In(MemData_M), .VPC(pc_M), .BDIn(PCSel_W), // 如果上一句是跳转，那么这一句是延迟槽 .ExcCodeIn(ExcCode_M_true), .HWInt(HWInt), .EXLCLr(EXLClr), .CP0Out(CP0Out_M), .EPCOut(EPC), .req(req) ); CPU进行异常处理 语句跳转 遇到异常时进入Exception Handler 0x00004180 在异常处理程序结束时会执行指令eret回到EPC\n语句清空 利用CP0生成的req信号对所有流水线寄存器进行清空。 （因为CP0在M级，那么此时W级的操作在本时钟周期已完成，由于同步复位，清空寄存器只会影响下一周期的内容，这样下一周期所有指令都已完成，不受干扰。）\n（注意精确异常，认真阅读教程中关于乘除槽精确异常的讲述。 ）\n这里有很重要的一点在于eret没有延迟槽。因此执行完eret后，下一条指令应当是EPC。\neret在D级，此时eret的下一条指令（物理层面）在F级\n我们需要F级的指令是EPC而非eret的下一条指令\n以下内容看乐子就行\n我们采用一种奇妙的做法：\n当eret在F级时，我们直接进行检测该指令是否是eret。\n如果是，那么NPC为EPC。\n1 2 3 4 5 6 wire Eret_F; assign Eret_F = (Instr_F == 32\u0026#39;d01000010000000000000000000011000); assign _npc = Eret_F ? EPC : PCSel_D ? npc : (pc_F + 32\u0026#39;d4); 解释一下之前的定义： _npc为真正的NPC PCSel_D是判断D级是否为跳转指令 npc是跳转指令算出来的npc\n这里要注意EPC它并不是一个定值，他可能被mtc0改变！！ 因此有一套转发与阻塞逻辑： 我现在需要一个正确的pc\n1 2 3 4 assign _EPC = (Mtc0_D \u0026amp;\u0026amp; rd_D == 5\u0026#39;d14) ? V2_D : (Mtc0_E \u0026amp;\u0026amp; rd_E == 5\u0026#39;d14) ? V2_E_Data : (Mtc0_M \u0026amp;\u0026amp; rd_M == 5\u0026#39;d14) ? CP0In : EPC; 这样的转发足够吗？ 不够！必须阻塞！！\nmtc0不被阻塞的前提是mtc0认为自己能在写CP0之前拿到对的值 所以他在没有到达CP0的时候的值都有可能不对\nEPC的值是在mtc0到达W级的时候被传送到F级供eret使用\n在mtc0在M级的时候，它的CP0In肯定也是对的，可以转发。\n在mtc0在D,E级的时候，都可以考虑阻塞。\n1 2 3 4 5 6 7 /*assign stall = start_busy || (busy \u0026amp;\u0026amp; MDALUOp_D) ||*/ ((Eret_F \u0026amp;\u0026amp; Mtc0_D \u0026amp;\u0026amp; rd_D == 5\u0026#39;d14)) || ((Eret_F \u0026amp;\u0026amp; Mtc0_E \u0026amp;\u0026amp; rd_E == 5\u0026#39;d14)) ||/* ((A1 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_E)) || ((A1 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_M)) || ((A2 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_E)) || ((A2 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_M));*/ 我们看似用的是D级的阻塞，但这样也能起到阻塞F级eret的作用\n这一段的写法过于创新。我们不得不有把这种设计毁掉的打算。\nUpdate 12.1: 我很抱歉。在没有de出真正的bug之前，我选择把这一种方法全部删去。采用了大家普遍使用的D级执行。\n当然，在修改之后当时并没能解决任何问题。\n这里要注意一点： eret严格意义上在M级才能视为被执行。 因此EXLClr需要在Eret信号传到M级时才置1。\n至于eret的清空延迟槽，就不再多说了，需要注意它的BD应为0。 在阻塞上我也是正常全力阻塞，转发也不想写了。。\n逻辑就是eret在D级，mtc0在E,M级且要写的内容是EPC时直接大胆阻塞。\n对于异常跳转，监测标志为req req置1时，pc需变为0x00004180\n1 2 3 4 5 6 7 8 9 10 11 /*always @(posedge clk) begin if (reset) begin PCreg \u0026lt;= 32\u0026#39;h00003000; end*/ else if (req) begin PCreg \u0026lt;= 32\u0026#39;h00004180; end/* else if (En_pc) begin PCreg \u0026lt;= npc; end end*/ req优先级需注意，低于reset，位于第二高的地位。\n紧接着，我们解决req对寄存器的清空。\n本来很简单的一件事情，由于阻塞而变得复杂。 阻塞，产生了空泡，但这个空泡不应是全空的。\n这个空泡应当是上一条指令生命的延续。\n尤其是PC信息与Bd信息。 对于阻塞型清空，应保持不变。\n如D_E流水线寄存器中：\n1 2 3 pc_E \u0026lt;= reset ? 32\u0026#39;h00003000 : req ? 32\u0026#39;h0000_4180 : pc_D; PCSel_E \u0026lt;= (reset || req) ? 0 : PCSel_D; 真的是这样吗？？\nUpdate 12.2 上机debug\n空泡要存的信息究竟是谁？\n是被阻塞指令的pc和跳转指令的PCSel\n因此\n1 2 3 4 pc_E \u0026lt;= reset ? 32\u0026#39;h00003000 : req ? 32\u0026#39;h00004180 : pc_D; ExcCode_E_last \u0026lt;= 0; PCSel_E \u0026lt;= (reset || req) ? 0 : PCSel_E; 两种继承方式！ PCSel直接继承，pc流水继承。\n其次我已做了改动，eret不再是PCSel指令了。\n为什么要这么做呢？\neret他要起到修正PCSel的作用这确实，但是他还有很多自己的特别作用！\n你不能对它进行额外的流水处理！\n你总不能让一句nop拥有eret性质吧，我们EXLClr可是跟eret很有关系的。\n外设及其交互 其实整体来说，外设的作用就只有信息存储与中断产生。\n中断信号的导入 中断信号相对简单，只需要传递给HWInt接口。\nTimer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。\n1 2 wire [5:0] HWInt; assign HWInt = {3\u0026#39;b0, interrupt, IRQ_1, IRQ_0}; 系统桥与信息存储 我们在此构建一个新模块Bridge\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 module BRIDGE( input wire [31:0] addr, input wire [3 :0] byteen, input wire [31:0] Rd_T0, input wire [31:0] Rd_T1, input wire [31:0] Rd_DM, output wire [31:0] Rd, output wire [3:0] m_data_byteen, output wire [3:0] m_int_byteen, output wire hit_T0, output wire hit_T1 ); wire hit_DM; wire hit_Int; assign hit_T0 = (byteen == 4\u0026#39;b1111) \u0026amp;\u0026amp; (addr \u0026lt;= `T0_end) \u0026amp;\u0026amp; (addr \u0026gt;= `T0_start); assign hit_T1 = (byteen == 4\u0026#39;b1111) \u0026amp;\u0026amp; (addr \u0026lt;= `T1_end) \u0026amp;\u0026amp; (addr \u0026gt;= `T1_start); assign hit_DM = (addr \u0026lt;= `DM_end) \u0026amp;\u0026amp; (addr \u0026gt;= `DM_start); assign hit_Int = (addr \u0026lt;= `Int_generator_end) \u0026amp;\u0026amp; (addr \u0026gt;= `Int_generator_start); assign m_data_byteen = (hit_DM) ? byteen : 0; assign m_int_byteen = (hit_Int) ? byteen : 0; assign Rd = (hit_T0) ? Rd_T0 : (hit_T1) ? Rd_T1 : (hit_DM) ? Rd_DM : 0; endmodule 我们可以看出，它无非是\n根据addr和byteen得出新的字节使能信号 对各方面的读取进行选择，得出真正的读入内容 这样，我们就可以顺利搭建顶层模块：\n无非是两个Timer，还有一些信息处理与传输嘛，最后还是给CPU使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 wire hit_T0; wire hit_T1; wire [31:0] Rd; BRIDGE bridge( .addr(addr), .byteen(byteen), .Rd_T0(Rd_T0), .Rd_T1(Rd_T1), .Rd_DM(m_data_rdata), .Rd(Rd), .m_data_byteen(m_data_byteen), .m_int_byteen(m_int_byteen), .hit_T0(hit_T0), .hit_T1(hit_T1) ); wire IRQ_0; wire [31:0] Rd_T0; TC Timer_0( .clk(clk), .reset(reset), .Addr(addr[31:2]), .WE(hit_T0), .Din(m_data_wdata), .Dout(Rd_T0), .IRQ(IRQ_0) ); wire IRQ_1; wire [31:0] Rd_T1; TC Timer_1( .clk(clk), .reset(reset), .Addr(addr[31:2]), .WE(hit_T1), .Din(m_data_wdata), .Dout(Rd_T1), .IRQ(IRQ_1) ); endmodule 注意一下TC传的地址是[31:2]\n连完顶层模块，P7好像就，结束了？\n通过ISE把语法错误搞完，然后\u0026hellip;\n陷入无尽的debug之中了。\n测试文档 P6既然过了，P7的无异常情况基本是不需要考虑的。\n基本处理模式 测试首先从简单的异常开始，比如简单的Ov\n认真观察波形图，分析一下进入异常处理程序后各寄存器的情况，以及是怎么跳转回去的，跳转回去各寄存器的情况又如何。\n此时的异常处理程序还比较简单，比如可以只有4条语句：\n取EPC，EPC+4，存EPC，eret\n(这个还能顺便测测阻塞)\n1 2 3 4 5 6 .ktext 0x4180 mfc0\t$k0, $14 addu\t$k0, $k0, 4 mtc0\t$k0, $14 eret 99999999 (一条无效指令，测一测延迟槽清空) 防止漏判 构造出所有引发异常的组合。\n你只需要对着你那个表格，一种种地敲，一种种检验。\n关键是看好ExcCode，这个最简单，但也往往是大量错误出现的地方。\n防止误判 这个是比较难发现的，在使用COKiller之前，我碰运气确实找到了一些样例误判，但是用了COKiller我才发现div触发Ov没有被我发现。\n我的建议就是多用评测机，多测点数据，认真看代码。\n其他细节谬误 这些我觉得可以对着各种学长博客所强调的点先检查是否实现，再写测试程序来看写的是否正确。\n例如空泡的信息继承，乘除槽的执行与否等等。\n思考题 请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？\n鼠标和键盘等都属于外设，外设与CPU的时钟频率可谓是天差地别。中间必须要有一个接口，实现两者之间的信息交流。\n这个接口往往有硬件的控制信号，更有软件的处理程序，能够使这些信号变为CPU接受的形式。\n请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）\n因为我们的异常处理程序是统一放在这里的，你要执行异常处理程序就是要到达这个pc。\n不过用户自己实现处理异常中断应该也不会有大的问题，毕竟我们自己搭CPU测试的时候不就是自己写处理中断的程序嘛，写得很烂就是了。。\n但是0x4180本身位置的控制一定是经过慎重考虑的，有其空间分配的优越性。\n为何与外设通信需要 Bridge？\n高内聚，低耦合。\n外设可以添加，但是CPU不应为之改变。 这时候，系统桥就能起到分析处理双方信息的作用。\n当我们添加新外设，只需改动Bridge来控制要读谁，要写谁的问题。\n请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并针对每一种模式绘制状态移图。\n整个流程两种模式十分类似，差别在于是否具有周期性。\n对于IDLE，ctrl[0]为0转为状态LOAD，并把IRQ置0，接下来，无条件进入计时阶段，如果中途ctrl[0]为1就终止，进入IDLE，否则就计数完成时进入INT，发送中断。\n到了INT阶段， if(`ctrl[2:1] == 2\u0026rsquo;b00)，那么就一直中断，进入IDLE继续循环。 否则，IRQ置0，即只中断这一个周期，然后进入IDLE重新循环。\n不过共同之处在于，ctrl[0]对中断的产生都有明显的控制作用。\n倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？\n会发生EPC为0的问题。这个问题在设计文档已经提到过，还是那句话：\n空泡应当是上一条指令生命的延续。\n我们处理的核心问题是EPC，所以说空泡要着重继承与之有关的PC值与Bd值。\n空泡要存的信息究竟是谁？\n是被阻塞指令的pc和跳转指令的PCSel\n为什么 jalr 指令为什么不能写成 jalr $31,$31？\n这也是我的设计文档中所提到的一个问题。\nBd为1而是用重复执行跳转指令的方法确实有潜在问题，正如jalr $31, $31的情况：\n这是一个有累加效应的写指令。两次执行jalr的写效果是不同的。\n解决方案文中也有讨论到： 异常中断在延迟槽发生，那么就屏蔽req时的写GRF，让此时W级的写指令无效。\n下一次回到这句话的时候才是真正执行。\n倘若延迟槽又出现问题，那就再让此时W级写使能无效即可。\n","date":"2024-11-26T20:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-co-p7-mips%E5%BE%AE%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/destruction321_hu5083056439175028234.jpg","permalink":"https://demiurge-zby.github.io/p/buaa-co-p7-mips%E5%BE%AE%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/","title":"BUAA CO P7 MIPS微系统搭建"},{"content":" 说在前面 能通过P5实在是很好的一件事。 在我第一道题直接AC确定课下无bug，在我很快做出前两道题确定自己能通过后，我真的如释重负。 题目并不难，在课下提交截止前找出bug并修复真的是我能通过P5的重要原因。 反思前两题，还可以做得更快。思路清晰，才能更精准更利索。\n上次也说到了，咱们的P6要实现30条指令了！\n具体地说： add, sub, and, or, slt, sltu, lui, addi, andi, ori, lb, lh, lw, sb, sh, sw, mult, multu, div, divu, mfhi, mflo, mthi, mtlo, beq, bne, j, jal, jr, nop\n接下来，我们就开始吧！\n设计文档 本次P6搭建，我还是选择采用边搭建边写设计文档的方法。\n通过记录设计文档来记录我的每一步更改进度，对于P6这种考验严谨性的工程是较有益的。\nP6的主要任务，是在一个相对完善的架构上去增添大量的同类型新指令和少量的特殊指令。\nadd, sub, and, or, slt, sltu, lui,\naddi, andi, ori,\nlb, lh, lw, sb, sh, sw,\nmult, multu, div, divu, mfhi, mflo, mthi, mtlo,\nbeq, bne, j, jal, jr,\nnop\n比较新鲜的指令有set型，字节访存，还有最特别的乘除模块指令！\n我的搭建逻辑是最后处理乘除模块，先搭简单的，或者说白了，先搭非乘除模块（）\n顶层模块的改装 由于P6修改了IM和DM模块，在外部接入指令存储器与数据存储器，并在外部实现写入内容的输出\n对于这些新的接口，\n1 2 3 4 5 6 7 8 9 10 11 input [31:0] i_inst_rdata, input [31:0] m_data_rdata, output [31:0] i_inst_addr, output [31:0] m_data_addr, output [31:0] m_data_wdata, output [3 :0] m_data_byteen, output [31:0] m_inst_addr, output w_grf_we, output [4:0] w_grf_addr, output [31:0] w_grf_wdata, output [31:0] w_inst_addr 为了较少地改动我们的原版CPU，我们采用 assign 顶层输出信号 = 部件输入信号 assign 部件输出信号 = 顶层输入信号 的方式进行书写。\n相当于：本来传给IM,DM部件的信号现在要作为顶层输出信号传给外部IM,DM、 而本来从IM和DM部件得到的数据现在要由外部IM,DM通过顶层输入信号进行赋值。\n其中只有m_data_byteen这一信号是我们从未出现过的，它涉及到了lh,lb,sh,sb四条新指令。\nDM的写 不难设计一个STORE模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 `timescale 1ns / 1ps `define SW 2\u0026#39;b01 `define SH 2\u0026#39;b10 `define SB 2\u0026#39;b11 `default_nettype none module STORE( input wire [1:0] DMWr_M, input wire [31:0] MemAddr_M, output wire [3:0] byteen ); wire half; wire [1:0] by_te; assign half = MemAddr_M[1]; assign by_te = MemAddr_M[1:0]; assign byteen = { ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b1))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b11))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b1))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b10))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b0))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b01))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b0))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b00)))}; endmodule 在顶层,我们可以直接将m_data_byteen与byteen接口相连 也可以新建信号以提高可扩展性\nDM不需要读使能，它始终会读出该地址存储的值，只是后续再通过WdSel来判断你用不用这个信号罢了 而且DM的写使能也很方便实现： |byteen ,将它的各位或起来就可以作为写使能，即存在1就要写。 byteen本身又是控制信号，即哪是1哪被写。\nDM的写就基本完成了 （毕竟功能本身已经由testbench全权负责了）\n! 这样的执行逻辑与MARS是不同的！经过和学长的交流，m_data_wdata跟MemData显然应当是不同的。\n在此加入对MemData做处理的语句，也不难写\n1 2 3 4 5 assign m_data_wdata = (DMWr_M == `LW) ? MemData_M : (DMWr_M == `LH) ? {MemData_M[15:0], MemData_M[15:0]} : (DMWr_M == `LB) ? {MemData_M[7:0], MemData_M[7:0], MemData_M[7:0], MemData_M[7:0]} : 32\u0026#39;b0; DM的读 前文也说到，DM一直会读，但是lw,lh,lb就需要你来处理了。 根据读出的整个字和控制信号，我们可以实现把MemReadData变成正确的值。 相应地，我们需要通过一个模块将m_data_rdata变为MemRead 再将MemRead赋值给MemReadData（同样是为了可扩展性）\n这个模块也很好写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 `timescale 1ns / 1ps `define LW 2\u0026#39;b01 `define LH 2\u0026#39;b10 `define LB 2\u0026#39;b11 `default_nettype none module LOAD( input wire [1:0] DMRd_M, input wire [31:0] m_data_rdata, input wire [31:0] MemAddr_M, output wire [31:0] MemRead ); wire half; wire [1:0] by_te; assign half = MemAddr_M[1]; assign by_te = MemAddr_M[1:0]; assign MemRead = (DMRd_M == `LW) ? m_data_rdata : (DMRd_M == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b1) ? {{16{m_data_rdata[31]}}, m_data_rdata[31:16]} : (DMRd_M == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b0) ? {{16{m_data_rdata[15]}}, m_data_rdata[15:0]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b11) ? {{24{m_data_rdata[31]}}, m_data_rdata[31:24]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b10) ? {{24{m_data_rdata[23]}}, m_data_rdata[23:16]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b01) ? {{24{m_data_rdata[15]}}, m_data_rdata[15:8]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b00) ? {{24{m_data_rdata[7]}}, m_data_rdata[7:0]} : 32\u0026#39;b0; endmodule IM 这个就不用说了，两句话的事\n1 2 assign i_inst_addr = pc_F; assign Instr_F = i_inst_rdata; sh,sb,lh,lb 做事做到底，就把他们直接都写完吧\n书写逻辑： 1.CTRL各项控制信号添加 (和lw，sw完全对应一致) 2.CTRL中Tuse,Tnew (和lw，sw完全对应一致) 3.具体实现（已完成）\n简单的E级ALU写数指令 这类指令也很简单，在此也只有两类： add型: add, sub, and, or ori型：addi, andi, ori （在此add型再添加：slt, sltu 原因在下一小节\n读两个数 算一个数 也就是add型指令 把它归为同一类的原因，主要是控制信号过于相似： 相同调控（置相同的数）的信号有：WrSel, RFWr, Tuse_rs, Tuse_rt, Tnew_D 特异性的信号是ALUOp,用宏定义增强可读性\n书写时要额外注意slt和sltu\n1 2 3 assign slt = ($signed(num_1) \u0026lt; $signed(num_2)) ? $signed(1) : $signed(0); // 1和0是有符号数。但我还是保险起见 assign sltu = (num_1 \u0026lt; num_2) ? 32\u0026#39;b1 : 32\u0026#39;b0; // 32\u0026#39;b1和32\u0026#39;b0都是无符号数 读一个数 拿一个立即数 算一个数 也就是ori型指令 其实和上一类很像，不过区别在于： num_2是IMM_32而非V2 写的寄存器是rt而非rd 相同调控（置相同的数）的信号有：RFWr, ImmSel, Tuse_rs, Tuse_rt, Tnew_D ！特异性： ADDI是符号扩展 ,ORI,ANDI是零扩展\nD级算数指令 真的要在D级算数？ 这是我之前从未触及的一个点。在此，为提高效率，我将冒险进行优化： 这类指令有slt, sltu, lui, jal 把它们前移至D级改变了两件事：Tnew降低、Tuse降低 我之前并没有写过E-D转发，使得lui和jal的Tnew均为1 经过优化，他们的Tnew可以变成0，从而避免后续指令被阻塞 但他们也有风险：风险就是Tuse降低使得他们本身的操之过急可能会使自己被阻塞\n事实上，lui和jal是直接对立即数操作，因此并没有Tuse的风险问题。 而slt和sltu则有风险。\n因此我将slt和sltu放回了简单的E级ALU写数指令。\nlui 和 jal 的 E-\u0026gt;D转发 接下来先说说我对lui和jal的改进吧。 首先，jal的转发十分简单，只要当A1(A2)等于31且Link_E时把pc+8传过去而已。 jal在后面把这个值选择赋给了ALUData_E_True,即\n1 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : ALUData_E; 那么相应地，lui的转发也可以很简单。 真正要写入寄存器的lui的值当然还是ALU算出来的，相当于节省了把这个值选择赋给ALUData_E_True的过程。 lui未曾有的，是他的独特信号，即Lui lui要转发的值，就是{IMM32_E[15:0], 16\u0026rsquo;b0} 由于后续由ALU承包，Lui信号只需要坚持到E-\u0026gt;D转发就够了 可知我们需要改动CTRL，D_E这两个子模块。\n那么咱们的成效就要显露出来了： 那就是减少阻塞！Tnew降为0！\n在CTRL中更改Tnew信号后，这一段路，也算是走完了。\n跳转指令 增添的新指令是bne 已经可以称得上和beq完全一致了吧\u0026hellip;\n主要差别只在于zero和!zero 相同调控（置相同的数）的信号有：PCSel, Tuse_rs, Tuse_rt, (Tnew都不存在)\n不过bne和beq要区分，所以还是需要有控制信号传出来。\n主要就是NPC引入新接口bne,参与了npc的计算罢了\n1 ((beq \u0026amp;\u0026amp; zero) || (bne \u0026amp;\u0026amp; !zero)) ? br_pc : pc_D + 32\u0026#39;d8; 接下来，剩下的8个乘除模块指令，就要从零建起了。\n乘除模块 乘除模块共8条指令 mult, multu, div, divu, mfhi, mflo, mthi, mtlo\nMDALU模块 我们可以构建模块MDALU 接口如下所示：\n名称 位宽 方向 clk 1 I reset 1 I MDALUOp 4 I num_1 32 I num_2 32 I start_busy 1 O busy 1 O HI 32 O LO 32 O clk和reset的功能就不多说了，要清空所有寄存器 start_busy:得知指令为 mult,multu,div,divu，引发运算，阻塞与busy （在start_busy的时候就要为下一周期阻塞了，再不阻塞E级就要进来新指令了）\nMDALUOp:控制信号\n1 2 3 4 5 6 7 8 assign MDALUOp = mult ? `MULT : multu ? `MULTU : div ? `DIV : divu ? `DIVU : mfhi ? `MFHI : mflo ? `MFLO : mthi ? `MTHI : mtlo ? `MTLO : `NONE; busy：这个可以说是最重要的一个点。 在busy状态下，我们要进行阻塞，Pc、F_D级不动，D_E级清空，E级及以后顺延运算。 问题的关键在于： 如何控制busy时间？\n以乘法为例： 每个时钟上升沿，start_busy信号为1时，给cnt归0，给busy赋1，算出LO，HI要被赋的值（现在再不算，等会阻塞的时候E级都清空了） (由于非阻塞赋值，在下一时钟上升沿cnt = 0, busy = 1)\nbusy为1时，\n若cnt == 4，busy和cnt清零，并对regHI，regLO赋值 (由于非阻塞赋值，第五个时钟周期开始时cnt刚被赋值为4， 那么下一个时钟上升沿是busy和cnt都清零，regHI和regLO被赋值， assign语句的即时性使得HI与LO直接出值) 否则cnt++ 指令的控制信号 这八条指令除了MDALUOp以外，也有其对应的控制信号要处理。\nmult,multu,div,divu是完全同质的指令。 特点是读GRF，直接写HI,LO，不写GRF和DM 可以归纳其控制信号RFWr = DMWr = DMRd = 0; ImmSel = 0;运算数都是寄存器\nTuse_rs = Tuse_rt = 3\u0026rsquo;b1;\n乘除法的Tnew不必担心： 得出结果就直接塞到寄存器里了 新指令一旦进来，就说明我的regHI和regLO已经写好了 转发都不用，更别说阻塞了\n再说了，乘除法不差你这一点阻塞，本身阻塞的也够多了（）\nmfhi,mflo是一个访存指令。 要读HI,LO，写GRF 这考虑的就要多了。\n首先，它写GRF，就决定了它需要去转发： 指令的Tnew = 1,可进行M-\u0026gt;D,M-\u0026gt;E的转发。 我们当然可以直接把它加入ALUData_E_true(像当初pc+8那样)\n其次，写要写到哪：rd 那么WrSel要置1\n另外，写当然需要写使能：RFWr = 1\nmthi,mtlo要对HI和LO进行写 要读GRF 写HI,LO\n那么其实这和第一类指令很相似 不写GRF和DM，控制信号RFWr = DMWr = DMRd = 0; ImmSel = 0;运算数都是寄存器 特点是Tuse_rs = 3\u0026rsquo;b1; 但是不需要读GRF[rt]\n同样类似地，它的值也是即拿即写 不需要转发与阻塞\n指令在模块内的书写 前四条已经较详细地描述过了 但在实际书写上，还是存在一定问题： 1. 在阻塞之后，什么值都丢了，那么你就必须有自己预先存好的Op，预先存好的计算结果，才能使得你这个周期还能按着原来的指令的轨迹去走。 但是，op你应该怎么存？ 这至少需要一个时钟周期去存它，那么如果你只根据Op判断，你就已经丢失了一个时钟周期。不仅如此，对于一个周期就能完成的mf,ml指令而言，这更是荒唐。 因此，我目前的写法是不仅对Op写case语句，还对MDALUOp写case语句。 那么，Op的控制也应更加严格，即执行完语句后，应把Op置为`NONE。 （注意：default的情况不要对Op处理！因为default可能是还没来得及赋值的Op,这下好了，同一上升沿两次赋值）\n符号乘法要怎么写？ 鉴于曾经在这里WA过一发，我在此直接给出写法：\n1 {tempHI, tempLO} \u0026lt;= $signed(num_1) * $signed(num_2); 就这么简单。不要担心位宽不一致。它会自动扩展。\nmf指令是一个读HI，LO指令，而我们的HI与LO本就一直在输出。 只需要MDALUOp的控制信号管理一下ALUData_E_true的选择即可。\nmt指令为写HI，LO指令，直接在case语句里面写寄存器就行。 ！！这里要注意，我们写HI，LO寄存器其实是在下一时钟周期才完成的 因此有人会担心，如果下一条指令就要读HI，LO会不会出错误？ 答案是不会。因为我们的assign一直在输出，HI,LO被写之后拿出来的数肯定是对的。\n曾经又在这里WA过一发：mt指令读的都是rs!!!\n模块在顶层的书写 作为少有的要改动顶层模块的设计 首先要注意先前所提到的 mf指令涉及到的写寄存器与转发的问题，都需要靠ALUData_E_true来解决\n1 2 3 4 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : (MDALUOp_E == `MFHI) ? HI : (MDALUOp_E == `MFLO) ? LO : ALUData_E; 当然还有模块本身的接口及其信息传递\n另外要注意的就是阻塞： 阻塞实际上也就是多或上了两个信号start_busy和busy信号 并非如此！ 阻塞应该或上start_busy信号清空E级倒没错（防止ALUOp不变回0引发两个case语句都被执行） 但是busy信号应当与MDALUOp_E与起来再或 因为乘除的结果放进HI，LO里是不影响其他指令的进行的，只有遇到与HI,LO相关的语句，我们才有阻塞的必要。 通过这样优化，大大降低了阻塞率。\n那么接下来的，就是大量指令引发的巨量测试。\n测试文档 单个指令的测试 对于新加入的指令本身，我们需要进行一次较为彻底的测试。\n一是功能本身的基础是否实现，二是一些特殊情况需要验证。\n首先是lh,lb,sh,sb指令： 侧重对符号扩展的测试\n对于add, sub, and, or, slt, sltu, lui, addi, andi, ori 要注意addi的符号扩展是否做到\n对于bne就正常测试成功or失败跳转即可\n对于乘除法模块则也要注意符号问题\n这一层次的测试基本上是用于debug的，因为只涉及自身功能，不涉及冒险，课下的弱测强度基本足够了。\n当然还是建议自行做足测试的。\n指令之间的冲突处理 利用思考题处的表格自行构造样例，再结合评测机进行测试。\n我决定写多个小型测试，对各种转发与阻塞的情况编写特别代码来检测结果。在此不便展示。\n思考题 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？\n因为乘除法部件的运算逻辑与读写数据都与ALU截然不同。 首先，乘除法的高强度阻塞与特别的时序逻辑决定了他不能和组合逻辑直接混用。\n乘除法模块中计算指令就不说了，mf指令是组合逻辑assign，mt指令是写寄存器的时序逻辑。这和原ALU是不太兼容的。\n其次，HI，LO寄存器也只有MDALU能用到，和ALU混用，就提高了内部耦合度，显得混乱。\n这么做，把计算分为ALU和MDALU，最后再进行选择，其实相当于是形成了一个更大的ALU，含有原ALU和MDALU。因此，单独的乘除法部件更好地做到了“高内聚，低耦合”。\n最大的好处：先前没有理解好乘除法的阻塞，事实上，只要乘除法运算过程中没有与乘除类有关的指令，就不需要阻塞。那咱们的效率可谓是大大提升了。\n独立的HI,LO： 首先，HI,LO有其自身特殊性，不能被直接读，只能靠mf指令读。 其次，把HI，LO放在E区，与其他寄存器分离开来，能够实现即出即写，避免了读写冲突。\n真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。\n经过资料查阅，在真实的流水线CPU中，32位乘法是分部分计算的，一个周期可以32位对8位数的乘法（？），然后4个周期能算完。 除法据说是用试商法，一次试4位，8个周期做完除法。\n请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？\nstart可以引发busy，而start和busy都能导致阻塞。 通过计数器控制阻塞周期数，在最后一周期，清空busy,cnt，并完成寄存器赋值。 由于阻塞清空了E寄存器，我将MDALUOp和运算结果进行了及时存储。当然，在最后一周期，这些存储的信号也要清空。\n请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）\n清晰性： 提前将DMWr和addr共同作用的结果算出来，清晰明了地表达了究竟要写哪些字节，对每个字节执行独立的赋值。\n统一性： sw,sh,sb都能用同样的按字节赋值的逻辑来执行。 不过需要被写数据要进行一些预处理：\n1 2 3 4 5 assign m_data_wdata = (DMWr_M == `LW) ? MemData_M : (DMWr_M == `LH) ? {MemData_M[15:0], MemData_M[15:0]} : (DMWr_M == `LB) ? {MemData_M[7:0], MemData_M[7:0], MemData_M[7:0], MemData_M[7:0]} : 32\u0026#39;b0; 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？\n写入DM的确实只写了一个字节 但从DM获取的是一整个字，要经过后续处理\n执行lw和sw时当然还是按字读写更快 但是执行对半字与字节的操作时，按字节读写效率更高\n为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？\n抽象： 我对指令进行了归类，如设计文档所示。并按类地添加和处理指令 最显著的作用如DMRd,DMWr,ALUOp,MDALUOp等等，单个多位信号传入流水线寄存器，相较于多个单位信号是更方便的。\n规范： 对于同一类指令，可以对其先归为一类，再统一为控制信号赋值 （其实也没简单太多，比如addi这种符号扩展，还要单独写）\n帮助： 在译码和处理数据冲突的时候也就是在CTRL内，按类调整控制信号与T信号，省时省力\n在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？\n新的冲突只有数据冒险。处理方法也别无二致。\n阻塞： 我在修改CTRL的时候，已经为各个指令赋好了Tuse_rs,Tuse_rt,Tnew，阻塞正常进行\n转发：\n新添的所有指令中，需要的位点没有改变：V1_D,V2_D,num_1,num_2（此处忽略lh,lb.sh,sb） 新添的所有指令中，写寄存器的内容：大多都还是原来的路径，除了M级有新数据：即来自LO,HI的新数据。（要知道乘除运算指令本身是不写GRF的） 对于这个的处理前文也有提及：\n1 2 3 4 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : (MDALUOp_E == `MFHI) ? HI : (MDALUOp_E == `MFLO) ? LO : ALUData_E; 对于这个改动的测试样例：\n1 2 3 4 5 6 7 8 9 10 11 ... mult $s1, $s2 mfhi $t0 ## 写$t0 add $t1, $t0, $t0 ## 读$t0，M-\u0026gt;E需转发，写$t1 mtlo $t1 ## 读$t1，M-\u0026gt;E需转发 mflo $t2 ## 写$t2 add $t3 $t2 $t2 ## 读$t2，M-\u0026gt;E需转发，写$t3 mthi $t3 ## 读$t3，M-\u0026gt;E需转发 mfhi $t4 ## 写$t4 sw $t4 0($0) ## 读$t4，M-\u0026gt;E需转发 lw $t5 0($0) ## 写$t5 这个样例过多测试了M-\u0026gt;E转发，下面补充一个M-\u0026gt;D转发\n1 2 3 4 5 6 mtlo $t5 ## 读$t5 mflo $t6 ## 写$t6 label: or $t6 $t6 $0 ## 表示正在死循环 bne $0 $t6 label ## M-\u0026gt;D转发 nop 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。\n我采用了手动构造法。 通过建立策略矩阵，按照T的关系来进行构造 具体分类方式如下图所示：\n这两张图还需添加关于lui和mf指令的测试，单独对这两个指令构造测试也是可行的。\n","date":"2024-11-14T14:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-co-p6-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA2/Der_Richter_hu1678884075292437805.jpg","permalink":"https://demiurge-zby.github.io/p/buaa-co-p6-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA2/","title":"BUAA CO P6 流水线CPU搭建（2）"},{"content":" 说在前面 这周真的太忙了。 不说流水线和数竞这两块大骨头，硬控两小时的党课，硬控两小时的挑战杯志愿者，硬控一小时的组会，硬控五小时的毛概PPT\u0026hellip;\n虽说这周还买了曲包摘了星\n但是流水线CPU真难写。 读者可以看看我写设计文档心境的变化。\n（提交截止前2h突然发现bug。。5点半硬控到7点去上党课）\n为什么说这是流水线的（1）呢？ 因为目前还只有10条指令。流水线（2）是P6，30条指令的事了。\n那么，请君观之。\n设计文档 流水线的设计与单周期的区别主要是两点：\n流水线寄存器的插入 冒险的处理 这两点说起来轻轻松松，但实操起来实在繁杂。\n在漫无目的地发愣了很久之后，我决心要先写出一篇设计文档，把思路理清了再去书写。\n发愣的核心原因在于总感觉自己处理不好寄存器要放什么，谁应该在哪个区（浅显的思考当然不能处理好）\n有的时候更是连第一步没想好就忙着转发阻塞什么的\n哪怕后续转发的时候再优化，现在把需求理清，车间划好，才能想下一步迈进。\n流水线寄存器 要将原来的单周期分割为五个小阶段，具体是什么样呢？\n哪些阶段有什么部件？又要干些什么？\nF pc出值给IM\nIM出指令\npc+4得更新到pc\n这里已经涉及到pc的问题了，我不得不现在想清楚延迟槽。\n所有不是pc+4的npc，都是经过跳转的；所有要跳转的，都要用延迟槽\n所有用延迟槽的，都要先执行pc+4，因为跳转结果在第二周期才得出来（哪怕你提前得出来了你也得等延迟槽！！）\n所以跳转结果是在下一个周期才赋值，是一种特殊的赋值！\npc应当默认使用pc+4，除非有NPC算出的东西进来\n这需要一个控制信号，并且应当是任何跳转语句都能引发，我称之为not_pc_4\n这个信号作用于PC，所以还是称它为PCSel吧 PCSel为1的条件就是所有跳转语句\n这个信号在什么时候产生呢？ 肯定已经到D阶段了\nbeq在F阶段，此时PCSel仍为0 （因为跳转语句不在延迟槽，这一句不是延迟槽，则上一句不是跳转，则PCSel为0）\nbeq在D阶段，延迟槽语句在F阶段 这时候PCSel为1\n因此下一个pc将是跳转的结果，没有问题！\nPCSel产生即使用，不经过流水线（虽然他其实能够在F阶段就拿出来，但是拿出来也要流水到下一周期才能用。此外译码一般都放在D级）\n顺便谈到zero\nzero经过提前到D级后，也是即拿即用，不需要经过流水线\npc，Instr都给 F_D\nF_D拿到指令\nF_D 存储PC和Instr,实现流水。\n一个流水线寄存器是要干什么？\n暂存信息（时钟、复位信号与其他信息） 从寄存器出信息 搞明白这一点，后面的流水线寄存器都大同小异了。\nD 好，接下来看一条指令在D阶段要干些什么\nD阶段最核心莫过于GRF\n但是其他内容也都同等重要\n首先是先前提到过的 NPC和CMP\n单独搞一个CMP出来据说是为了解决P6大量branch语句\n这个阶段要给imm_16变成IMM_32, imm_16已经没用了吗？要把它加入流水吗？\n为了可扩展性，要不要把他一直存着呢？\n但到时候哪怕用imm_16，直接从IMM_32里面取就行了。完全没必要存。\nimm_26是j型指令用的，存着也没用，毕竟即拿即用，得赶快给PC送过去呢！\n好的，那这个阶段把imm_16也解决掉了\n剩下最后一个，就是GRF了！\n读什么？根据rs,rt读呗。\n这个阶段又不写。所以rd目前也没什么用。\n是不是要注意GRF的A3选择的时候是rd_W,rt_W这些？写的时候那个pc也得是pc_W？关于W阶段啥东西都应该是W？\n那就是W阶段的事。看似是一个部件，不同的功能要分开考虑。不能想着GRF在D级，就一口气把GRF接口都连好。 现在只考虑D级！\nD_E 存储很多很多东西 还有用的控制信号（EXT，J，Jr当场使用了） 还有用的数据（imm_16和imm_26都没用了） 当然还有pc\n多存点，说不定会有用的。\nE 好嘞，该读的信息都读了，该处理的信息也处理了\n下面就是执行操作了\n关键的内容还是ALU\n而ALU的核心就是各个东西都是E\n（这个模块异常的简单？）\nE_M 还是一个基本问题，后面需要什么\n要传递一脉相承的信号，也要传递新生成的数据\npc是当然的 后面有Mem取数和Write回写 需要Mem写的地址，写的内容，GRF写的地址，写的内容 还有他们的读写使能\n别忘了还要传递ALUData信息\nM 整体和单周期也基本没有区别，只有这一个模块在工作而已。\nM_W 添加MemReadData_M MemData_M和Mem_Addr_M也带上吧\nW 回到GRF\n该用W的都用上W即可\n意外地快。 不处理冒险的数据通路搭好了？？\n冒险处理 我自己也没想到已经走到了这一步。 这一基础性的工作就这样被我搁置了这么久。\n你也能够发现，上面的无非是添加接口，新建流水级的体力活。 接下来才是头脑风暴的核心。\n转发和阻塞！！！\n转发 首先要构建好转发的所有路径 转发的核心矛盾，是读了还没写的东西 （一定要注意0号寄存器！写进去了也还是0，因此不能转发）\n我在这里直接考虑所有路径\n指令 F D E M W add,sub 取指令 取rs,rt 算数 得到数据进行转发rd 写数rd ori,lui 取指令,扩展imm 取rs 算数 得到数据转发rt 写数rt lw 取指令，扩展imm 取base，rt 算数 寻址取数 得到数据转发rt，写数rt sw 取指令，扩展imm 取base，rt 算数 寻址存数 无 j 取指令，扩展imm 算出NPC延迟槽后用 无 无 无 jal 取指令，扩展imm 算出NPC延迟槽后用，算出PC_8 可转发（但没人需要） 可转发 可转发，写数$31 jr 取指令 读rs并给NPC 无 无 无 举个例子add 例如我们add读寄存器值的时候可能数据还没出来，但是真正要用到的时候其实在ALU 因此使用时间在E级。\n在此诠释Tnew的定义：最早的可转发时间。也就是正确数据已产出，且存在转发通路。\n我在此分如下几类指令：\nR型读2求1型 rs与rt要读，正常转发 Tuse_rs = 1（ALU的时候有就行） Tuse_rt = 1（ALU的时候有就行） Tnew 初始（即相对于E）= 1 (M才能开转) RegAddr 现场算\nI型拿1读1求1型 rs 要读，正常转发 Tuse_rs = 1（ALU的时候有就行） Tuse_rt = inf imm正常传，传到了num_2,因此rt的值在E级要额外存为V2_E_Data\nTnew 初始 = 1 (M才能开转)\n读寄存器跳转型 说白了就是jr（） Tuse_rs = 0 !!! Tuse_rt = inf 所有跳转的特点都在于其必须在D级得出跳转结果。 而jr就必须从V1_D拿到完全正确的值 因此E-\u0026gt;D的转发是有益的 （但从E开始的转发需要是在D级就得出结果的指令（不经过ALU）） 符合条件的并不多。 我暂时采用阻塞。\n直接跳转型 j不必多说 Tuse_rs = inf Tuse_rt = inf\nRFWr = 0\n条件跳转型 beq。关键在于br和zero两个指令。 其中zero同样要保证在D级算对！必须拿到对的值。 拿不到？我也先采用阻塞。\nTuse_rs = 0 Tuse_rt = 0 RFWr = 0\nLink型 典例jal Tnew = 0 !!!!!(不过我还是把它当做Tnew = 1来用) Tuse_rs = inf Tuse_rt = inf\nE级就能用。因此E-\u0026gt;D这条转发路径是有益的。我目前先用了阻塞。 写$ra太慢了！必须转发！ 该怎么转？能在M和W转。（E也能转） 一定要注意：一旦选择转它，你要拿他去覆盖转的值！！\n1 2 wire [31:0] ALUData_E_true; assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : ALUData_E; 这个ALUData_E_true直接传进流水线E_M和M_W， 即如果本指令为Link型，你就只能读到这一个$31数！\n条件跳转Link型 最关键的便是不跳转，就不Link！ 比如beqal，其link信号应为beqal\u0026amp;\u0026amp;zero(传Link信号的时候就控制好)\nL型 rs rt 正常获取转发 Tuse_rs = 1 Tuse_rt = inf(看题意新指令会不会特殊条件使用rt) imm正常扩展\nALU算的值会在M级被转发！！ 但是在W级正确的值还会被转发过去。\n准确来说，阻塞逻辑就是为了保证你要用的时候一定能拿到正确的值，无论这中间发生过什么。\n因为你的Tnew就是正确数据生成时间，Tuse就是使用时间。\n如果传过去被使用的是错误数据，那就说明正确数据还没被生成，也就是说这条指令是满足阻塞条件的。所以根本不会出现这种情况。\nTnew = 2 最慢！！！（一直到M级取出来，W级才能用）\nS型 Tuse_rs = 1, 在E级需要算对数rs， Tuse_rt = 2，在M级需要有正确的寄存器值rt RFWr = 0 Tnew = 0，不对寄存器进行写\n转发路径共四条：\n转发方向 数据 判断 M-\u0026gt;D 传ALUData_M(经过pc+4和ALUData的选择) RegAddr_M跟A1A2比 W-\u0026gt;D 传RegData(经过MemReadData_W和ALUData_W的选择) RegAdde_W跟A1A2比 M-\u0026gt;E 传ALUData_M(经过pc+4和ALUData的选择) RegAddr_M跟rs_E rt_E比 W-\u0026gt;E 传RegData(经过MemReadData_W和ALUData_W的选择) RegAddr_W跟rs_E rt_E比 为什么没有到M的转发？ 因为M级使用即Tuse = 2,而Tnew没有大于2的（Tnew = 3即W级才产出数据。这显然是荒谬的？）\n事实上，W-\u0026gt;M 是必要的！！ 要知道，Tnew从来不是产出时间，而是最早转发时间！ 如果你写了Tnew=2，那你就表明了自己能在W级转发数据，怎么能不写W级转发通路呢？ 咱们在编写Tnew的时候，一定要和我们能实现的转发通路一一对应。 只有在你做到能转则转的情况下，你才能说Tnew是正确数据的最早生成时间。 否则，你的效率会更低，且你需要修改你的Tnew表。 为什么没有E-\u0026gt;D的转发？ E-\u0026gt;D 即 Tnew = 0 且 Tuse = 0，满足需求只有jal（lui也可以。但是我已经把他塞进ALU了） 但是我还没写。 因此Tnew = 1，要阻塞。\n从这里也能看出来Tnew和转发通路的关系\n阻塞 我们采用把阻塞控制在D阶段完成的方法。 Tuse:在D级的时候，读寄存器的最晚周期与D级的差 Tnew_X:X周期的指令要写的内容能够转发出去的最早周期与E级的差 （在周期A算出来，则可以在周期A+1转发）\n我们需要考虑D与E关系，D与M关系 为什么不考虑D与W关系？？ 因为Tnew_W一定为0了（谁家指令在W级还没算出来数（笑））\n对于两个阻塞的关系，我们采用暴力地或起来 一条通道可能不通就阻塞。\n这可能确实有点暴力，但我也确实没什么精力去优化描述，以更好地处理例如 lw $31, 0($0) jal label add $t0, $31, $31 这样的情况。这种情况原则上jal转发优先级更高，他还更快，所以如果他有正确的值且寄存器匹配且不为0且T关系等等就可以不管lw的感受。 我没管那么多。\n阻塞只需满足:\n确实发生读写冲突且来不及转发（Tuse \u0026lt; Tnew） 我们先分为rs冲突与rt冲突\n1 assign stall = stall_rs || stall_rt; 然后以rs为例：\nstall_rs = stall_rs_DE || stall_rs_DM\n以stall_rs_DE为例：\n确实发生读写冲突： (rs_D（即A1）== RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026rsquo;b0) 且 \u0026amp;\u0026amp; 来不及转发： (Tuse_rs \u0026lt; Tnew_E)\n所以\n1 2 3 4 stall = ((A1 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_E)) || ((A1 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_M)) || ((A2 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_E)) || ((A2 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_M)); 接下来，只需对 Tuse 和 Tnew_X 下定义：\n功能还在CTRL中实现: 因为我要用指令来描绘 Tnew 和 Tuse_rs 和 Tuse_rt\n指令 Tnew Tuse_rs Tuse_rt add 1 1 1 sub 1 1 1 ori 1 1 5 lui 1(个人原因) 5 5 beq 无(0) 0 0 jr 无(0) 0 5 jal 1(不转发导致的) 5 5 lw 2 1 无(5) sw 无(0) 1 2 Tuse 直接生成 Tnew_X 初值生成，递减操作\n递减操作的实现： 放进流水线嘛，过个周期减一下\n测试文档 刚搭完流水线寄存器，出来一堆compile bug 或多或少的少加控制信号，打错字什么的。。 然后运行了充斥着nop的代码，没什么问题。\n然后就向Hazard进军了！\nHazard测试的编写很有针对性。 前提是你要针对好所有的代码情况，事先分析好Tnew,Tuse关系 才能模拟出所有的冒险。 所有的转发，所有的阻塞，都要到位。\n思考题 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。\nbeq提前使得其Tuse降为0，这无疑提高了阻塞率。 当这条指令前面是Tnew = 1的add,sub,ori等等均阻塞\n用原来的方法，虽有可能损失更大，但是也存在很多无损失的情况。提前分支判断则是较为稳定的损失。\n举例：\n1 2 add $16 $16 $16 beq $16 $0 label 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？\n正因题意所说，因为延迟槽的存在，jal语句后的那条指令是已被执行的，跳转回来时当然要跨过延迟槽这句话\n我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？\n功能部件本就耗时，如果再加上转发逻辑，二者必定是顺序关系，导致时钟周期长度增长，频率上限降低，效率也就低了。 但是如果在下一周期，转发操作和下一周期的操作是独立并行的，不影响执行速度。\n我们为什么要使用 GPR 内部转发？该如何实现？\nGRF内部转发本质上是W到D的转发，只是W和D用了同一个部件 有同学使用了negedge的办法进行W，这样posedge读的时候就一定已经被新值写入。\n我采用了传统转发。无非转发的值是RegData_W,参与判断的是RegAddr_W罢了。\n我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？\n需求者严格意义上有很多，不过他们是可以合并的。 所有需要使用或传递的部件，都是需求者。 但是我们可以先进行转发，再把结果给需求者们。 总体来说，需求者可以是CMP的两个数，ALU的两个数，D_E和E_M流水线寄存器。\n需求者还有M级 sw时RD2的值！！！！！需要换上最新数据！！！\n供给者我们都安排到流水线寄存器的输出。 M级的数据可以是ALUData,Pc+8 W级的数据可以是MemReadData,ALUData,Pc+8\n前文也提到了，E到D的转发尚未考虑。\n因此，共有M-\u0026gt;D，M-\u0026gt;E，W-\u0026gt;D，W-\u0026gt;E，W-\u0026gt;M五种。 （以及E-\u0026gt;D）（6种）\n!!刚de出的bug!!!还有W-\u0026gt;M转发！！！！\n再总结一下所有被转发：\nRD1\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V1_D\u0026mdash;\u0026gt;V1_E\u0026ndash;ME,WE转发\u0026ndash;\u0026gt;num_1\u0026mdash;\u0026gt;运算\nRD2\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V2_D\u0026mdash;\u0026gt;V2_E\u0026ndash;ME,WE转发\u0026ndash;\u0026gt;V2_E_Data\u0026mdash;\u0026gt;V2_M_Data\u0026ndash;WM转发\u0026ndash;\u0026gt;MemData_M\u0026mdash;\u0026gt;被写入\nRD2\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V2_D\u0026mdash;\u0026gt;V2_E\u0026ndash;ME,WE转发、选择\u0026ndash;\u0026gt;num_2\u0026mdash;\u0026gt;运算\n总结一下所有转发：\nM级为ALUData,Pc+8经过选择变为ALUData_true的转发 W级为MemReadData,ALUData,Pc+8经过选择变为RegData的转发\n转发地址为RegAddr已各自计算\n在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。\n这一问题在前文已有谈论。 总结起来，关键还是处理好Tnew,Tuse,读谁，写谁这四个问题 （其中，读谁，写谁都是需要控制信号的） 以及最核心，最有不确定性的“处理”这一部分\n确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。\n我使用的是对控制信号找相关指令的方式。 先由opcode和funct得出结果，再得出指令；接下来由指令得到控制信号。 优势是简洁，不足是容易漏写，错写。 加指令时一定要分析好所有相关信号，再书写。\n","date":"2024-11-10T22:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-co-p5-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA1/292fa3e8c7e86664cbaefef9ddc7893_hu11389104909499974286.jpg","permalink":"https://demiurge-zby.github.io/p/buaa-co-p5-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA1/","title":"BUAA CO P5 流水线CPU搭建（1）"},{"content":"作业最终的架构设计 经过轮轮迭代，面向对象先导课程也终于走向了尾声。\n关于类 本次迭代任务中，共有24个类被创建：\n他们分别是：\nMainClass: 程序入口，实现数据读入操作和大量核心方法。 Adventurer: 核心操作对象，内含有关Bottle，Equipment，Frag，Employ类的相关容器 Bottle：内设三个子类，HpBottle，AtkBottle，DefBottle Equipment：内设三个子类，Axe，Blade，Sword Frag：表达碎片的相关属性与方法 Employ：表达雇佣关系相关属性与方法 Guard，Treasure及其Factory：秘境探险操作中的新对象 具体属性就不详细说了\n关于容器 在容器上的考虑，值得一提的便是CarriedEquipment。它使用了以name为索引的HashMap，这一方法十分契合题设要求。可惜的是，在处处以id为核心标识的情境，使用以name为索引的方法不可避免地要处理好在carry操作之外的重名问题。\n那便是deleteEquipment()方法在第三次迭代强测中带来的惨痛教训\n关于迭代 迭代式开发的课程，着实是令我耳目一新的。\n第一次迭代 OMG，it\u0026rsquo;s LLM! 从第一次迭代时拙劣地模仿IDEA的LLM，到现在理解较为成熟地模仿LLM，大家每个人的进步都是肉眼可见的。\n第二次迭代\n添加了carry指令。当时没有想太多，直接为装备添加了isCarried属性（谁能想到后面装备还能援助给别人呢（） deleteCommodity()让我开始考虑将Bottle和Equipment结合起来，但其差异仍将大于其共性。 第三次迭代 这次迭代是让我最印象深刻的一次迭代，痛失40分（苦笑 核心要点主要是： 容器重构，carry，frag，fight\n删掉了所有find函数，用上了高效简洁的HashMap carry方法重写，建立了专属容器以存放Carried的物品。关于carriedEquipment以name为索引的潜在问题前面已经提到了。 frag的处理。就忽略id属性这一问题，我认为是合理的。frag的最核心属性就应该是name和count，以同名frag作为一个对象基本单元，在获取数量，消耗数量等操作上都是合理的。不过把id忽略掉这种行为本身，对于整个项目来说，可能还是有一定隐患的。 fight较为简单。强测错因是getAtk()误写成getCe()。 第四次迭代 迭代任务确实一次比一次重\n雇佣关系：建立Employ类，对于一个雇佣关系对象本身管理它的各项属性。这种思想让我缓了很久，万物皆为对象！曾经室友写了一个Fight类，让我懵懂地理解了一下什么是过程对象，如今自己写的时候又更明白何为关系对象。把一场战斗（函数(函数其实也是关系，关系就是有序对)）当作一个对象，它有它的属性，有它的方法；把雇佣关系（有序偶对）作为对象，同样有自己的属性与方法。 递归攻击：倒是一个很容易克服的难点。 秘境探险：更多的是一种思想认知的改变，在具体实现上让我对接口有了新的认识。不同的类可以借助接口同一调用不同内容的方法，确实便利了很多 中测de了半天bug原来错在getComprehensiveCe()也是没谁了（）\n使用JUnit的心得体会 覆盖率是一项任务 起初，我确实没有意识到JUnit的功能。能在运行中构造样例运行出来的结果，为什么还要搞那么复杂去专门去测？我对各个方法进行了无意义的测试，完成了基础任务。\n覆盖率赋予每一行代码意义 自第三次迭代作业开始，加入了分支覆盖率的要求。在我开始思考覆盖率的意义之时，我方才意识到，单元测试之所以是单元测试，便在于它使得代码中各种细微的地方都能被顾及得到。同样，覆盖率也能够帮助我写出更完善的测试代码。\n单元测试，但不仅仅是单元 在单元测试中，我们不仅要编写对于单个方法的测试，更需要对较大的方法进行测试，在大方法中测试小方法相互作用关系的正确性。单元测试中的单元不仅是指最小单元，更是单元之间组合形成的层次化结构单元。\n测试数据构造需要技巧 无论何时，以debug为目的的测试终究是要找到bug。因此要尽力去构造bug相关的测试点，构造较极端的情况进行分析，而不是为了达到覆盖率要求而进行大量的无意义测试。\n学习OOpre的心得体会 以方法为核心的逻辑 在学习C语言的时候，我曾畅想，如果各项基本操作都能靠函数实现，而函数的实现也依靠其他函数，人脑只需负责顶层逻辑，那些条条框框的小方法被封装起来等着用该多好\u0026hellip;\n在OOpre的课程中可谓是函数方法用的最多的一集，有大量好用的被封装好的方法，我只负责对方法进行封装，构造新的方法，再调用方法\u0026hellip; 因此，在debug时，C语言和OOpre两门课带给我的感受是很不一样的。前面是对于方法具体实现细枝末节的深深考究，而OOpre的思路总是流畅贯通，哪里有问题它可以根据逻辑分析直接推理出漏洞\n以对象为主体的视角 这一点，是我在第四次迭代中深刻体悟到的，万物皆为对象。前文已有讲述。\n课程建议 希望可以像CO一样提前有一定的基础知识学习期，提供资料自学容器，子类，接口等内容的基础知识，解决课上刚学会的知识总是不能快速理解运用的问题。\n","date":"2024-11-01T13:30:00+08:00","image":"https://demiurge-zby.github.io/p/buaa-oopre-%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/d477300c36f0221527b9816c97bed3b_hu13817389781556842652.jpg","permalink":"https://demiurge-zby.github.io/p/buaa-oopre-%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/","title":"BUAA OOpre 结课总结"},{"content":" 设计文档 前情提要 本次搭建需要实现的指令有\nadd,sum,ori,lui sw,lw beq jal,jr nop 在此基础之上，本人额外添加了lh,lb,sh,sb,j指令。\nverilog的基本构建思路源始于logisim，Tunnel化的logisim电路为verilog代码的编写提供了很大的便利和可扩展性。\nverilog的编写仍然从数据通路基础部件和控制器两方面来书写，不过额外的是，在mips.v中应当实现所有的基础接线操作。\n或者说，mips.v是最独特的一环。\n一切源代码仅供参考，千万不要抄袭！！\n数据通路的构建 PC PC作为CPU中的时序电路核心器件，其功能实现也较为简单，只有同步复位操作和npc赋值操作。\n直接由logisim文件分析PC模块的接口\n名称 位宽 方向 npc 32 I clk 1 I reset 1 I pc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 `default_nettype none module PC( input wire [31:0] npc, input wire clk, input wire reset, output wire [31:0] pc ); reg [31:0] PCreg; always @(posedge clk) begin if (reset) begin PCreg \u0026lt;= 32\u0026#39;h00003000; end else begin PCreg \u0026lt;= npc; end end assign pc = PCreg; endmodule NPC NPC与P3不同，加入了jal，jr指令，使得其增加了两种全新跳转方式：\n26位立即数经位拼接得到直接地址 32为GRF数据得到直接地址 再加上原来的pc+4与pc+4+sign_ext(imm)\n共有四种跳转逻辑，需要较多的控制信号\nbr 和 zero 控制 相对寻址跳转 j 控制imm_26绝对寻址跳转\njr 控制$ra绝对寻址跳转\n接口信息如下：\n名称 位宽 方向 pc 32 I imm_16 16 I imm_26 26 I reg_ra 32 I br 1 I zero 1 I j 1 I jr 1 I pc_4 32 O npc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 `default_nettype none module NPC( input wire br, input wire zero, input wire [15:0] imm_16, input wire [25:0] imm_26, input wire [31:0] pc, input wire [31:0] reg_ra, input wire j, input wire jr, output wire [31:0] pc_4, output wire [31:0] npc ); wire [31:0] j_pc; wire [31:0] br_pc; assign pc_4 = pc + 32\u0026#39;d4; assign j_pc = {pc[31:28],imm_26,{2{1\u0026#39;b0}}}; assign br_pc = pc_4 + {{15{imm_16[15]}},imm_16[14:0],{2{1\u0026#39;b0}}}; assign npc = (jr) ? reg_ra : (j) ? j_pc : (br \u0026amp;\u0026amp; zero) ? br_pc : pc_4; endmodule IM IM作为需要读取指令的单位，需要调用readmemh\n为了保证读取的正确顺序，定义寄存器堆时使用[0:4095]\n也可以添加参数控制readmemh读取到的起始位置与终止位置\n由于该指令寄存器堆应当存储4096*32bit\n然而起始位置却是0x00003000 因此可以先对pc减去0x00003000\n再取[13:2]作为指令寄存器堆的读取地址\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I Instruction 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 `default_nettype none module IM( input wire [31:0] pc, input wire reset, input wire clk, output wire [31:0] Instruction ); wire [31:0] address; reg [31:0] InstrMemory [0:4095]; always @(posedge clk) begin if(reset) begin $readmemh(\u0026#34;code.txt\u0026#34;, InstrMemory); end end assign address = pc - 32\u0026#39;h00003000; assign Instruction = InstrMemory[address[13:2]]; endmodule EXT 注意位拼接操作的写法！！不能少打大括号\n位拼接“0”时，一定要控制有多少个0\n例如16个“0”,应使用{16{1\u0026rsquo;b0}}或{16\u0026rsquo;b0}\n名称 位宽 方向 EXTOp 1 I imm_16 16 I IMM_32 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `default_nettype none module EXT( input wire EXTOp, input wire [15:0] imm_16, output wire [31:0] IMM_32 ); wire [31:0] signed_IMM; wire [31:0] unsigned_IMM; assign signed_IMM = {{16{imm_16[15]}},imm_16}; assign unsigned_IMM = {{16{1\u0026#39;b0}},imm_16}; assign IMM_32 = EXTOp ? signed_IMM : unsigned_IMM; endmodule GRF GRF的最特殊性在于其0号寄存器\n值不能被改变 始终值为0 在此有两种处理方案\n初始时为所有寄存器赋0\n之后不对0号寄存器进行写入 读0号寄存器时始终输出0 由于个人偏好，希望各个寄存器中的值保持正确，本人采用了第一种写法\n根据题目要求，需要输出寄存器被写时的各项参数，需要将pc传入其中\n接口如下所示：\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I WE 1 I A1 5 I A2 5 I A3 5 I WD 32 I RD1 32 O RD2 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 `default_nettype none module GRF( input wire [31:0] pc, input wire [4:0] A1, input wire [4:0] A2, input wire [4:0] A3, input wire [31:0] WD, input wire reset, input wire clk, input wire WE, output wire [31:0] RD1, output wire [31:0] RD2 ); reg [31:0] grf [31:0]; integer i; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 32;i = i + 1) begin grf[i] \u0026lt;= 32\u0026#39;b0; end end else begin if(WE \u0026amp;\u0026amp; A3) begin grf[A3] \u0026lt;= WD; $display(\u0026#34;@%h: $%d \u0026lt;= %h\u0026#34;, pc, A3, WD); end end end assign RD1 = grf[A1]; assign RD2 = grf[A2]; endmodule ALU 实现基本与logisim同理，但是操作更为简单\n注意使用`define以增强代码可读性\n名称 位宽 方向 ALUOp 2 I num_1 32 I num_2 32 I zero 1 O out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 `default_nettype none `define ADD 2\u0026#39;b00 `define SUB 2\u0026#39;b01 `define ORI 2\u0026#39;b10 `define LUI 2\u0026#39;b11 module ALU( input wire [1:0] ALUOp, input wire [31:0] num_1, input wire [31:0] num_2, output wire zero, output wire [31:0] out ); wire [31:0] add; wire [31:0] sub; wire [31:0] ori; wire [31:0] lui; assign add = num_1 + num_2; assign sub = num_1 - num_2; assign ori = num_1 | num_2; assign lui = {num_2[15:0],{16{1\u0026#39;b0}}}; assign zero = (num_1 == num_2) ? 1\u0026#39;b1 : 1\u0026#39;b0; assign out = (ALUOp == `ADD) ? add : (ALUOp == `SUB) ? sub : (ALUOp == `ORI) ? ori : lui; endmodule DM 仅对于lw和sw而言，DM本应是极为简单的。\n但是正因为sh,sb的特殊性，我尝试了对其功能的描述\nsh,sb指令的核心问题，在于我们不能直接做到针对一个字部分内容的修改\n因为我们的寄存器都是以32bit为单位的 因此我们要先把它所在寄存器的值取出来，进行位拼接操作得到该寄存器应存入的新数，再存入DM之中\n由于添加了指令，我的WE与RE信号都进行了调整\n控制信号取值 含义 00 以w为单位 01 以h为单位 10 以b为单位 11 不予使能 同样地，为了输出中间参数，pc需要被引入。\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 我还添加了word,half,by_te等中间变量，便于我后续的描述\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 `default_nettype none `define SW 2\u0026#39;b00 `define SH 2\u0026#39;b01 `define SB 2\u0026#39;b10 `define LW 2\u0026#39;b00 `define LH 2\u0026#39;b01 `define LB 2\u0026#39;b10 module DM( input wire [31:0] pc, input wire [31:0] data, input wire [31:0] addr, input wire [1:0] WE, input wire [1:0] RE, input wire clk, input wire reset, output wire [31:0] out ); reg [31:0] DataMemory [0:3071]; integer i; wire [11:0] word; wire half; wire [1:0] by_te; assign word = addr[13:2]; assign by_te = addr[1:0]; assign half = addr[1]; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 3072; i = i + 1) begin DataMemory[i] \u0026lt;= 32\u0026#39;b0; end end else begin case (WE) `SW: begin DataMemory[word] \u0026lt;= data; $display(\u0026#34;@%h: *%h \u0026lt;= %h\u0026#34;, pc, addr, data); end `SH: begin case (half) 1\u0026#39;b1: begin DataMemory[word] \u0026lt;= {data[15:0], DataMemory[word][15:0]}; end 1\u0026#39;b0: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[15:0]}; end default: begin end endcase end `SB: begin case (by_te) 2\u0026#39;b11: begin DataMemory[word] \u0026lt;= {data[7:0], DataMemory[word][23:0]}; end 2\u0026#39;b10: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:24], data[7:0], DataMemory[word][15:0]}; end 2\u0026#39;b01: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[7:0], DataMemory[word][7:0]}; end 2\u0026#39;b00: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:8], data[7:0]}; end default: begin end endcase end default: begin end endcase end end assign out = (RE == `LW) ? DataMemory[word] : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b1) ? {{16{DataMemory[word][31]}},DataMemory[word][31:16]} : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b0) ? {{16{DataMemory[word][15]}}, DataMemory[word][15:0]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b11) ? {{24{DataMemory[word][31]}}, DataMemory[word][31:24]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b10) ? {{24{DataMemory[word][23]}}, DataMemory[word][23:16]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b01) ? {{24{DataMemory[word][15]}}, DataMemory[word][15:8]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b00) ? {{24{DataMemory[word][7]}}, DataMemory[word][7:0]} : 32\u0026#39;b0; endmodule 控制器的编写 在搭建数据通路的过程中，控制信号的要求也已经浮出水面。\n关键还是由IM到指令，由指令到控制信号的过程\n不过加入了其他操作，使得DMWr,DMRd发生了一定的改变 以及额外添加的Link,J,Jr等控制信号\n相较于P3的BSel,此处本人将其更名为ImmSel,强调其解决的是立即数与寄存器谁参与ALU运算的问题\n名称 位宽 方向 opcode 6 I funct 6 I Br 1 O EXTOp 1 O RFWr 1 O DMWr 2 O DMRd 2 O ALUOp 2 O WrSel 1 O WdSel 1 O ImmSel 1 O Link 1 O J 1 O Jr 1 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 `default_nettype none module CTRL( input wire [5:0] opcode, input wire [5:0] funct, output wire Br, output wire EXTOp, output wire RFWr, output wire [1:0] DMWr, output wire [1:0] DMRd, output wire [1:0] ALUOp, output wire WrSel, output wire WdSel, output wire ImmSel, output wire Link, output wire J, output wire Jr ); wire add; wire sub; wire ori; wire lui; wire sw; wire sh; wire sb; wire lw; wire lh; wire lb; wire beq; wire j; wire jal; wire jr; wire R; assign R = (opcode == 6\u0026#39;b000000); assign add = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100000); assign sub = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100010); assign jr = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b001000); assign j = (opcode == 6\u0026#39;b000010); assign jal = (opcode == 6\u0026#39;b000011); assign ori = (opcode == 6\u0026#39;b001101); assign lui = (opcode == 6\u0026#39;b001111); assign sw = (opcode == 6\u0026#39;b101011); assign sh = (opcode == 6\u0026#39;b101001); assign sb = (opcode == 6\u0026#39;b101000); assign lw = (opcode == 6\u0026#39;b100011); assign lh = (opcode == 6\u0026#39;b100001); assign lb = (opcode == 6\u0026#39;b100000); assign beq = (opcode == 6\u0026#39;b000100); assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign ImmSel = ori || lui || sw || sh || sb || lw || lh || lb; assign EXTOp = sw || sh || sb || lw || lh || lb; assign ALUOp = sub ? 2\u0026#39;b01 : ori ? 2\u0026#39;b10 : lui ? 2\u0026#39;b11 : 2\u0026#39;b00; assign RFWr = add || sub || ori || lui || lw || lb || lh || jal; assign DMRd = lw ? 2\u0026#39;b00 : lh ? 2\u0026#39;b01 : lb ? 2\u0026#39;b10 : 2\u0026#39;b11; assign DMWr = sw ? 2\u0026#39;b00 : sh ? 2\u0026#39;b01 : sb ? 2\u0026#39;b10 : 2\u0026#39;b11; endmodule mips.v 前面说了那么多，其实都是相对独立的结构 那么接下来，才是verilog描述的独特之处 才能更深刻地展示verilog的抽象功能\n接口十分简单，毕竟真正来自外部的信号只有clk和reset\n名称 位宽 方向 clk 1 I reset 1 I 1 2 3 4 5 `default_nettype none module mips( input wire clk, input wire reset ); 接线逻辑 在我书写这一板块的过程中，我曾选用了将所有的wire先定义好，再全部统一赋值，再逐个接接口的方法\n结果这样导致的问题（或者说我曾经出现的bug） 就是你不能确定你需要的信号都得到了定义与赋值\n因此，我秉承了P3的基本思路，对各个部件的外部接线进行分析。\n分析方法：\n先定义所有需要的输出信号 输入信号分为 直接与其他某部件的输出信号直接相连 由其他部件的输出信号相互作用（计算or选择）得到 为这些相互作用进行assign处理 基础信号 名义上如此，其实这是在模拟我没有模块化的Splitter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 基础信号定义 wire [5:0] opcode; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [4:0] shamt; wire [5:0] funct; assign opcode = Instr[31:26]; assign rs = Instr[25:21]; assign rt = Instr[20:16]; assign rd = Instr[15:11]; assign shamt = Instr[10:6]; assign funct = Instr[5:0]; wire [15:0] imm_16; wire [25:0] imm_26; assign imm_16 = Instr[15:0]; assign imm_26 = Instr[25:0]; CTRL 定义大量控制信号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //控制信号定义 wire Br; wire EXTOp; wire RegWrite; wire [1:0] DMWr; wire [1:0] DMRd; wire [1:0] ALUOp; wire WrSel; wire WdSel; wire ImmSel; wire Link; wire J; wire Jr; CTRL Ctrl( .opcode(opcode), .funct(funct), .Br(Br), .EXTOp(EXTOp), .RFWr(RegWrite), .DMWr(DMWr), .DMRd(DMRd), .ALUOp(ALUOp), .WrSel(WrSel), .WdSel(WdSel), .ImmSel(ImmSel), .Link(Link), .J(J), .Jr(Jr) ); PC 定义输出信号pc\n1 2 3 4 5 6 7 8 // PC 输出信号 wire [31:0] pc; PC Pc( .npc(npc), .clk(clk), .reset(reset), .pc(pc) ); IM 定义输出信号Instr\n1 2 3 4 5 6 7 8 9 10 // IM输出信号 wire [31:0] Instr; IM Im( .pc(pc), .Instruction(Instr), .clk(clk), .reset(reset) ); EXT 定义输出信号IMM_32\n1 2 3 4 5 6 7 8 // EXT输出信号 wire [31:0] IMM_32; EXT Ext( .EXTOp(EXTOp), .imm_16(imm_16), .IMM_32(IMM_32) ); NPC 定义输出信号npc和pc_4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // NPC输出信号 wire [31:0] npc; wire [31:0] pc_4; NPC Npc( .br(Br), .zero(zero), .imm_16(imm_16), .imm_26(imm_26), .pc(pc), .reg_ra(RD1), .j(J), .jr(Jr), .pc_4(pc_4), .npc(npc) ); GRF 定义输出信号RD1,RD2 定义输入信号，并给出其assign语句实现赋值 要知道，输入信号一定要从其他部件的输出信号或者外部的clk 与reset中得到 如果盲目定义输入信号，却不予有意义的赋值，就会产生xxxzzz等问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // GRF 输入信号·中间变量 wire [31:0] LinkPC; wire [4:0] A1; wire [4:0] A2; wire [4:0] RegAddr; wire [31:0] RegData; // GRF 中间变量的赋值 assign LinkPC = pc_4; assign A1 = rs; assign A2 = rt; assign RegAddr = Link ? 5\u0026#39;b11111 : WrSel ? rd : rt; assign RegData = Link ? LinkPC : WdSel ? MemReadData : ALUData; // GRF 输出信号 wire [31:0] RD1; wire [31:0] RD2; GRF Grf( .clk(clk), .reset(reset), .WE(RegWrite), .pc(pc), .A1(A1), .A2(A2), .A3(RegAddr), .WD(RegData), .RD1(RD1), .RD2(RD2) ); ALU 输出信号zero和ALUData\n定义输入信号num_1，num_2并给出assign\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ALU 输入信号·中间变量 wire [31:0] num_1; wire [31:0] num_2; // ALU 中间变量的赋值 assign num_1 = RD1; assign num_2 = ImmSel ? IMM_32 : RD2; // ALU 输出信号 wire zero; wire [31:0] ALUData; ALU Alu( .ALUOp(ALUOp), .num_1(num_1), .num_2(num_2), .zero(zero), .out(ALUData) ); DM 这两个输入变量的赋值是否没有意义？\nMemAddr一定是ALUData?\nMemData一定是RD2?\n可能确实如此。 但是这样的命名使得整体逻辑更为清晰，也增强了可扩展性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // DM 输入信号·中间变量 wire [31:0] MemAddr; wire [31:0] MemData; // DM 中间变量的赋值 assign MemAddr = ALUData; assign MemData = RD2; // DM 输出信号 wire [31:0] MemReadData; DM Dm( .pc(pc), .data(MemData), .addr(MemAddr), .WE(DMWr), .RE(DMRd), .clk(clk), .reset(reset), .out(MemReadData) ); endmodule 测试文档 我仍然采用了对拍的方法，并自行构造了一定数据。\n对于新增指令，我着重加强了对jr,jal的测试\n以下是一组测试数据，重点观察$ra取值的改变是否正常\n1 2 3 4 5 6 7 8 9 0c000c06 // jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f301c //ori $ra, $0, 0x0000301c //label: 03e00008 //jr $ra 03fff820 //add $ra, $ra, $ra 可知$ra会在pc+4和0不断跳转\n直到变为0x0000301c后跳转到add语句变为0x00006038\n下面是我的输出结果，与MIPS结果一致\n1 2 3 4 5 6 7 @00003000: $31 \u0026lt;= 00003004 @00003004: $31 \u0026lt;= 00000000 @00003008: $31 \u0026lt;= 0000300c @0000300c: $31 \u0026lt;= 00000000 @00003010: $31 \u0026lt;= 00003014 @00003014: $31 \u0026lt;= 0000301c @0000301c: $31 \u0026lt;= 00006038 思考题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ?\naddr信号来自于ALU的计算，即GRF[base]+sign_ext(offset) 其中addr[11:2]意为取ALU计算结果从第2位开始的12位数字作为address。 其原因在于对于lw指令，第0位和第1位均为0，自第2位起开始计数才是以32bit为单位，才能与DM寄存器堆的寄存器编号相对应。\n思考两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。\n控制信号每种取值所对应的指令： 举例：\n1 2 3 4 5 6 7 assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign EXTOp = sw || sh || sb || lw || lh || lb; 每条指令对应的控制信号取值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 always@(*) begin case (Operation) `ADD : begin Br = 1\u0026#39;b0; Jr = 1\u0026#39;b0; Link = 1\u0026#39;b0; J = 1\u0026#39;b0; WrSel = 1\u0026#39;b1; ... end ... default : begin end end 分析优劣： 由指令确定其控制信号： 优点：考虑全面，不会有漏掉的指令，对每个指令也不会有漏掉的控制信号 上机新增指令时直接对其分析，一个也不会漏 缺点：代码重复冗长 产生新的控制信号时还需要对每个指令都加句话\n对控制信号归纳其生效指令： 优点：本质上是上一种方法的总结归纳，代码量少 缺点：自行归纳时某些控制信号可能会忘记考虑一些指令\nPS：解决方法：对新指令在演草纸上进行所有控制信号枚举，之后再进行归纳，用于代码书写\n在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。\n同步复位：clk优先（还必须得是上升沿） 异步复位：reset优先\nC 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。\n1 2 if temp32 ≠ temp31 then SignalException(IntegerOverflow) 这是add和addu、addi和addiu的唯一区别 u的本意即为不考虑输出 那在忽略输出的前提下自然就等价了。\n","date":"2024-10-31T14:15:30+08:00","image":"https://demiurge-zby.github.io/p/buaa-co-p4-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/292fa3e8c7e86664cbaefef9ddc7893_hu9110516496620476980.jpg","permalink":"https://demiurge-zby.github.io/p/buaa-co-p4-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/","title":"BUAA CO P4 单周期CPU的verilog搭建"},{"content":"序列输入之数据特征分析 数据类型 不作介绍 关系 顺序关系 依次赋值 层次关系（赋值的所属对象） 1 2 3 4 5 6 7 8 Scanner scanner = new Scanner(System.in); int i; int n = scanner.nextInt(); for(i = 0; i \u0026lt; n; i++){ id = scanner.nextInt(); name = scanner.next();// id 与 name之间为顺序关系 // 不同组之间形成不同层次 } 结构 硬编码式的解析处理 较为简单，确定的输入方式 缺点：兼容性灵活性差 使用正则表达式的解析处理 可对应一个有穷自动机解析 默认使用贪婪匹配\n\u0026ldquo;.\u0026rdquo; 任意\n\u0026ldquo;*\u0026rdquo; 同一项内容任意项\n\u0026ldquo;+\u0026rdquo; 同一内容一项或多项\n\u0026ldquo;?\u0026rdquo; 同一内容零项或一项\n非贪婪匹配\n```java Pattern = new Pattern.compile(\u0026quot;(\\\\w+?)((good)*)\u0026quot;); // 添加 \\w+? 实现非贪婪 // 注意 \\\\ 编译问题 ``` 弊端：可读性差，技巧性高\n递归下降式解析处理 递归 借助递归进行解析 下降 从顶层到底层 按层解析 文法 终结符 取值不可变的符号，单个字符层级上的元素 非终结符 取值可变，以\u0026lt;\u0026gt;表示 定义规则 L -\u0026gt; R\n定义非终结符的取值方式\n1 2 3 4 5 \u0026lt;Var\u0026gt; -\u0026gt; \u0026lt;digit\u0026gt; | \u0026lt;Const\u0026gt; \u0026lt;Var\u0026gt; //递归下降 无限循环 \u0026lt;Const\u0026gt; -\u0026gt; \u0026lt;op\u0026gt; | \u0026lt;digit\u0026gt; \u0026lt;op\u0026gt; \u0026lt;digit\u0026gt; -\u0026gt; \u0026#39;0\u0026#39;|\u0026#39;1\u0026#39;|\u0026#39;2\u0026#39;|\u0026#39;3\u0026#39;|\u0026#39;4\u0026#39;|\u0026#39;5\u0026#39;|\u0026#39;6\u0026#39;|\u0026#39;7\u0026#39;|\u0026#39;8\u0026#39;|\u0026#39;9\u0026#39; \u0026lt;op\u0026gt; -\u0026gt; \u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;|\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39; // \u0026#39;+\u0026#39;为终结符，\u0026lt;op\u0026gt;,\u0026lt;Const\u0026gt;为非终结符 词法分析：定义Token 1 2 3 4 5 public class Token{ private String name; private Type type; // ... } //实现了一种抽象 语法分析：建立抽象语法树 根据文法所定义的关系\n1 2 3 4 5 public class Var{ private Arraylist\u0026lt;digit\u0026gt;; private Arraylist\u0026lt;op\u0026gt;; // ... } // 在表达树的方面降了一层 由表达式到项，由项到因子\n每一个非终结符都对应一棵局部语法树\n唉唉 只是课上跟着写还是太草率了\n不如PPT\n","date":"2024-10-24T15:30:00+08:00","image":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/15c277c39924c01bcd89e8f7b84de46_hu6067831623915793491.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/","title":"oopre课堂随笔-序列输入"},{"content":" 设计文档 Key Point: 数据通路，控制器及其连接\n要实现的核心指令介绍 add,sub,lui,ori,lw,sw,beq,nop\n数据通路的建立 名称 功能 简写 程序计数器 输出当前指令所在地址 PC 下指令地址 计算下一指令所在地址并传递给PC NPC 寄存器堆 32 个 32 位寄存器 GRF 指令存储器 存储所有的指令 IM 数据存储器 充当内存存储数据 DM 扩展单元 进行位扩展运算 EXT 算术逻辑单元 进行各项基本运算 ALU 下面先对各数据通路进行分析，并在此过程中得到对控制器的需求\n(在每个数据通路中都只考虑自己需要什么！\n输出的东西如何被使用是其他数据通路考虑的事情！！)\nPC 一个 32 位寄存器即可\n输出引脚：输出当前指令所在地址，提供给IM用于取指令\n输入引脚：由NPC算出的下一条指令地址\n作为整个设备中最核心的时序逻辑，在PC层面其本质应为Moore机\n在下一周期上升沿才可输出下一PC\n在输出PC以后，其他数据通路都基本呈现组合逻辑的形态，即时性进行输出内容的改变，即Mealy机\n（ROM和GRF的写入操作还是要等下一上升沿的，但是关于其写入的各项信息都是即时性得到的）\n当然，最后输出PC值的时候要再加上 3000\n若用PC初始化3000的方法，在复位后PC还是会输出 0\nNPC 下一指令的地址可能是PC+4\n对于beq跳转 也可能是PC+4+sign_ext(imm_16 || 00)\n对于j, jal跳转 还可能是PC[31:28] || imm_26 || 00\n输入引脚：输入当前PC值，imm_16, imm_26\n选择信号：br, zero, j\n这里区分br和zero是有原因的。\n详见zero产出地：ALU\n输出引脚：下一条指令PC值\n！！经后续分析，对于XXXAndLink指令，PC+4是被需要的，那就直接从NPC输出\nNPC外部的连接也比较直白\n具体分析：\n控制信号的使用：\n只有br和zero同时为1时才是成功beq跳转 鉴别出j，jal等才使用imm_26直接地址跳转 Tips: 由于jal指令为本人后续添加，因此选择了新增了MUX而不是改变原MUX\n计算过程实现：简单的加法，移位，位扩展，位拼接运算\n要注意位扩展一定是sign_ext，因此完全可以直接使用bit_sign_extender\nIM 采用了4096*32bit的ROM 地址长度选项只需12位\n！！ROM的地址以字为单位，因此PC要右移2位才能传给ROM\n右移之后还需bit_extender到12位\n（一定要先右移再extend，因为实质上就是取PC[13:2]）\n其余的没什么内容了\nSplitter 把这个东西单独拿出来写只是图个方便（）\nSplitter内部的构造就只是一些小splitter\nEXT EXT也是一个相对好说的部件\n根据EXTOp进行不同形式的位扩展\n（缺点（？）是只能用于16bit -\u0026gt; 32bit）\nEXTOp 含义 0 无符号扩展 1 符号扩展 EXTOp具体怎么得到就是Ctrl要考虑的了\n外部构造：\n内部结构：\n好的我刚刚意识到bit_extender本来就可以输入EXTOp\n但是我的EXT更好看（？）那就不改了\nGRF GRF相对来说就复杂多了\n内部结构在P0课下已经搭好了，但其正确性仍需后续测试\n在此仅略加展示：\n而其外部结构也大有文章\n指令 使用数据 add,sub 读rs,rt写ALU到rd ori 读rs写ALU到rt lui 写ALU到rt lw 读rs（即base）求ALU写MemReadData到rt sw 读rs（即base）求ALU但不写Grf beq 读rs,rd求ALU（做减法判zero）但不写Grf jal 不读但写PC+4到$31 因此构造相应的控制信号与多路选择器即可\nWrsel 含义 0 写到rt 1 写到rd Wdsel 含义 0 写ALU的结果 1 写MemReadData 后续添加的jal指令我又使用了控制信号Link\nLink 含义 0 按上述两个选择器行事 1 写PC+4到$31 当然，除此之外还有最重要的写使能信号\n整体外部结构如下图所示：\nALU 首先明确ALU要解决的问题：\n加法，减法，或，左移16位共4种运算\n显然ALUOp需要4种，即需要两位信号\nALUOp 使用指令 00 add，加法 01 sub，beq，减法 10 ori，或运算 11 lui，左移16位 不过，我并没有直接分四种器件进行操作\n采用了gxp老师课上提到的方法：\n加法和减法可使用同一加法器！！\na - b = a + ~b + 1\n而两个数相加再加1正是加法器已经提供的功能！\n最上方的接口即为进位接口\n！但是复用器件的代价就是更多的选择信号\n减法不仅仅要选择进位信号，还要选择参与运算的数\n对于整个ALU还需要区分进行了什么运算\n我们分为如下三个\n使用指令 M1 M1含义 Cin Cin含义 M2 M2含义 加法 0 使用b 0 进位为0 00 加减 减法 1 使用~b 1 进位为1 00 加减 或运算 X X X X 01 或运算 左移16位 X X X X 10 左移 如何根据ALUOp写出这些控制信号也一目了然：\n只需把上面两个表合起来，让ALUOp直接对应控制信号\n用Combinational Analysis给我们写出来就行了\n最终内部结构如下：\n在此解释前文NPC中zero与br都需存在的原因：\nbeq也是对rs,rt的值做减法，但关键在于结果值为0时输出zero信号为1\n因此zero信号也是会被sub甚至add干扰的\n所以在zero==1时必须有br==1才有效\n另一方向显然，br==1时判跳转有效当然离不开zero==1的判定\n关于其外部连接，关键只是两个控制信号：\n我们把GRF处使用的表格稍有侧重点地修改\n指令 使用数据 add,sub rs,rt算ALU（加减） ori rs，imm算ALU（或运算） lui imm算ALU（移位） lw,sw rs，imm算ALU（加法） beq rs,rd算ALU（做减法判zero） 将rs替换成RD1，将rt,rd按照对应法则替换到RD2\n可得到更清晰的表格\n指令 使用数据 add,sub RD1,RD2算ALU（加减） ori RD1，imm算ALU（或运算） lui imm算ALU（移位） lw,sw RD1，imm算ALU（加法） beq RD1,RD2算ALU（做减法判zero） 即可发现控制信号除了ALUOp之外，还有操作数2的选择\n操作数2可选择RD2或imm\n因此构造相应的控制信号与多路选择器即可\nBsel 含义 0 RD2 1 imm 这里的imm都是imm_16经过EXT的结果\n事已至此，可以顺便EXTOp也考虑清楚\n准确来说，只有ori需要无符号（EXTOp == 0）\nEXTOp 指令 0 ori 1 lw,sw X 其他 beq的sign_ext已经在NPC里面确认了\nEXTOp对于beq指令没有意义\n外部连接如下图所示：\nDM 我们采用了3072*32bit的RAM 地址长度选项只需9位\nDM和GRF逻辑类似\n但是由于我们直接使用RAM\n在一些内容的表达上需要按照RAM行事\nRAM 应使用双端口模式，即设置 RAM 的 Data Interface 属性为 Separate load and store ports RAM的ld也需要特别激活，因此需要一个lw信号来控制它 str信号就是普通的写使能信号 clr信号为异步复位信号 和ROM类似，RAM的地址也以字为单位，因此PC要右移2位才能传入 右移之后还需bit_extender到9位 （一定要先右移再extend，因为实质上就是取PC[10:2]）\nDM的A接口是地址，由ALU算出\n要存入的信息则是GRF从rt读出来的RD2\n连接比较简单\n控制器的搭建 在数据通路的苦苦搭建之中，其实控制信号已经都有了自己的定义\n我们发现，这些定义一般都依赖于指令\n那么控制器就可以建起这个桥梁：\n通过opcode和funct得到指令\n再由指令得出控制信号\n由外部信号到指令 得到指令的过程我使用了比较器，因此构建过程非常简单\n由指令到控制信号 由指令到控制信号那可就更简单了\n除了 ALUOp（）\n我们使用OR阵列\n哪条指令需要这个信号，我们就给它或到这个控制信号上\n这种拉线式的写法还是很方便的\nALUOp就只能拜托我们亲爱的Combinational Analysis啦\nCTRL在整个main电路中的书写还是比较简单的\n我把他设计成了一个很富有信息量的样子（）\n搭电路的过程中一些小惬意的时光就是在修改电路外观~\n测试文档 那么至此，我们的基础版CPU算是实现了基本自洽\n接下来，就需要有大量的边界与随机指令去测试它了！\n我首先测试了课程组给出的附件，并翻译为MIPS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 .text ori\t$28, $0, 0 ori\t$29, $0, 0 ori\t$1, $0, 0x3456 add\t$1, $1, $1 lw\t$1, 4($0) sw\t$1, 4($0) lui\t$2, 0x7878 sub\t$3, $2, $1 lui\t$5, 0x1234 ori\t$4, $0, 5 nop sw\t$5, -1($4) lw\t$3, -1($4) beq\t$3, $5, _1 beq\t$0, $0, _13 _1: ori\t$7, $3, 0x404 beq\t$7, $3, _11 nop lui\t$8, 0x7777 ori\t$8, $8, -1 sub\t$0, $0, $8 ori\t0, $0, 0x1100 add\t$10, $7, $6 ori\t$8, $0, 0 ori\t$9, $0, 1 ori\t$10, $0, 1 _minus2: add\t$8, $8, $10 beq\t$8, $9, _minus2 _13: _11: _minus1: beq\t$0, $0, _minus1 # dead continue 寄存器数据及跳转测试 // 本测试的不足之处在于支持了MARS不支持的错误运算 //如最大正数加1，最小负数减1，-1减最小负数等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //记得写v2.0 raw 3c00ffff // 测试`$0` //下面是对低16位赋值 3c01ffff 3c028000 00000000 //nop测试 3c047fff 3c058000 //下面是对低16位赋值 3421ffff // `$1` = -1 34420000 // `$2` = 最小负数 34630001 // `$3` = 1 3484ffff // `$4` = 最大正数 34a50001 // `$5` = 最小负数 + 1 //sw与lw的简单测试 ac64ffff //在0处存 `$4` 测试offset为负 bc200001 //把0处的值给`$0` 测试`$0` 8c040000 //把0处的值给`$4` 测试offset为0 00253020 // `$6` = `$5` + `$1` 10460002 //等于最小负数 跳2句 //跳-8句跳回形成死循环 00643820 //最大正数加一 10e20000 //等于最小负数 跳0句 00a34022 //最小负数+1减一 11020000 //等于最小负数 跳0句 01034822 //最小负数减一 11240000 //等于最大正数 跳0句 00225022 //-1减最小负数 1144fff8 //等于最大正数 跳-8句 检验方法 在保证sw无问题的前提下\n将所有的敏感变量都及时存储\nbe like:\n1 2 3 4 5 6 .macro save(%data) #不保存$t0,$t1 sw %data, 0($t0) # 不能用addi ori $t1, $0, 4 add $t0, $t0, $t1 .end_macro 之后只需要直接比对MARS和DM的存储区即可\n","date":"2024-10-23T12:30:15+08:00","image":"https://demiurge-zby.github.io/p/buaa-co-p3-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/88e20704208d17e1fd4372ecfb993c3_hu1946466944430747746.jpg","permalink":"https://demiurge-zby.github.io/p/buaa-co-p3-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/","title":"BUAA CO P3 单周期CPU的logisim搭建"},{"content":"Welcome!! I feel so excited and interested to create my first blog!\nI plan to name my blog \u0026lsquo;Demiurge\u0026rsquo; just because this song is really astonishing and touching\u0026hellip;\n(By the way, the illustration is also fantastic)\nI am suddenly awared that 我可以说中文\n那么，今后请多多指教！\n","date":"2024-09-24T00:37:20+08:00","image":"https://demiurge-zby.github.io/p/demiurgefirstblog/demiurge_hu5188072458766260427.png","permalink":"https://demiurge-zby.github.io/p/demiurgefirstblog/","title":"DemiurgeFirstBlog"}]