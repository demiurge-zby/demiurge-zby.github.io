[{"content":"序列输入之数据特征分析 数据类型 不作介绍 关系 顺序关系 依次赋值 层次关系（赋值的所属对象） 1 2 3 4 5 6 7 8 Scanner scanner = new Scanner(System.in); int i; int n = scanner.nextInt(); for(i = 0; i \u0026lt; n; i++){ id = scanner.nextInt(); name = scanner.next();// id 与 name之间为顺序关系 // 不同组之间形成不同层次 } 结构 硬编码式的解析处理 较为简单，确定的输入方式 缺点：兼容性灵活性差 使用正则表达式的解析处理 可对应一个有穷自动机解析 默认使用贪婪匹配\n\u0026ldquo;.\u0026rdquo; 任意\n\u0026ldquo;*\u0026rdquo; 同一项内容任意项\n\u0026ldquo;+\u0026rdquo; 同一内容一项或多项\n\u0026ldquo;?\u0026rdquo; 同一内容零项或一项\n非贪婪匹配\n```java Pattern = new Pattern.compile(\u0026quot;(\\\\w+?)((good)*)\u0026quot;); // 添加 \\w+? 实现非贪婪 // 注意 \\\\ 编译问题 ``` 弊端：可读性差，技巧性高\n递归下降式解析处理 递归 借助递归进行解析 下降 从顶层到底层 按层解析 文法 终结符 取值不可变的符号，单个字符层级上的元素 非终结符 取值可变，以\u0026lt;\u0026gt;表示 定义规则 L -\u0026gt; R\n定义非终结符的取值方式\n1 2 3 4 5 \u0026lt;Var\u0026gt; -\u0026gt; \u0026lt;digit\u0026gt; | \u0026lt;Const\u0026gt; \u0026lt;Var\u0026gt; //递归下降 无限循环 \u0026lt;Const\u0026gt; -\u0026gt; \u0026lt;op\u0026gt; | \u0026lt;digit\u0026gt; \u0026lt;op\u0026gt; \u0026lt;digit\u0026gt; -\u0026gt; \u0026#39;0\u0026#39;|\u0026#39;1\u0026#39;|\u0026#39;2\u0026#39;|\u0026#39;3\u0026#39;|\u0026#39;4\u0026#39;|\u0026#39;5\u0026#39;|\u0026#39;6\u0026#39;|\u0026#39;7\u0026#39;|\u0026#39;8\u0026#39;|\u0026#39;9\u0026#39; \u0026lt;op\u0026gt; -\u0026gt; \u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;|\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39; // \u0026#39;+\u0026#39;为终结符，\u0026lt;op\u0026gt;,\u0026lt;Const\u0026gt;为非终结符 词法分析：定义Token 1 2 3 4 5 public class Token{ private String name; private Type type; // ... } //实现了一种抽象 语法分析：建立抽象语法树 根据文法所定义的关系\n1 2 3 4 5 public class Var{ private Arraylist\u0026lt;digit\u0026gt;; private Arraylist\u0026lt;op\u0026gt;; // ... } // 在表达树的方面降了一层 由表达式到项，由项到因子\n每一个非终结符都对应一棵局部语法树\n","date":"2024-10-24T15:30:00+08:00","image":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/15c277c39924c01bcd89e8f7b84de46_hu6067831623915793491.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/","title":"oopre课堂随笔-序列输入"},{"content":" 设计文档 Key Point: 数据通路，控制器及其连接\n要实现的核心指令介绍 add,sub,lui,ori,lw,sw,beq,nop\n数据通路的建立 名称 功能 简写 程序计数器 输出当前指令所在地址 PC 下指令地址 计算下一指令所在地址并传递给PC NPC 寄存器堆 32 个 32 位寄存器 GRF 指令存储器 存储所有的指令 IM 数据存储器 充当内存存储数据 DM 扩展单元 进行位扩展运算 EXT 算术逻辑单元 进行各项基本运算 ALU 下面先对各数据通路进行分析，并在此过程中得到对控制器的需求\n(在每个数据通路中都只考虑自己需要什么！\n输出的东西如何被使用是其他数据通路考虑的事情！！)\nPC 一个 32 位寄存器即可\n输出引脚：输出当前指令所在地址，提供给IM用于取指令\n输入引脚：由NPC算出的下一条指令地址\n作为整个设备中最核心的时序逻辑，在PC层面其本质应为Moore机\n在下一周期上升沿才可输出下一PC\n在输出PC以后，其他数据通路都基本呈现组合逻辑的形态，即时性进行输出内容的改变，即Mealy机\n（ROM和GRF的写入操作还是要等下一上升沿的，但是关于其写入的各项信息都是即时性得到的）\n当然，最后输出PC值的时候要再加上 3000\n若用PC初始化3000的方法，在复位后PC还是会输出 0\nNPC 下一指令的地址可能是PC+4\n对于beq跳转 也可能是PC+4+sign_ext(imm_16 || 00)\n对于j, jal跳转 还可能是PC[31:28] || imm_26 || 00\n输入引脚：输入当前PC值，imm_16, imm_26\n选择信号：br, zero, j\n这里区分br和zero是有原因的。\n详见zero产出地：ALU\n输出引脚：下一条指令PC值\n！！经后续分析，对于XXXAndLink指令，PC+4是被需要的，那就直接从NPC输出\nNPC外部的连接也比较直白\n具体分析：\n控制信号的使用：\n只有br和zero同时为1时才是成功beq跳转 鉴别出j，jal等才使用imm_26直接地址跳转 Tips: 由于jal指令为本人后续添加，因此选择了新增了MUX而不是改变原MUX\n计算过程实现：简单的加法，移位，位扩展，位拼接运算\n要注意位扩展一定是sign_ext，因此完全可以直接使用bit_sign_extender\nIM 采用了4096*32bit的ROM 地址长度选项只需12位\n！！ROM的地址以字为单位，因此PC要右移2位才能传给ROM\n右移之后还需bit_extender到12位\n（一定要先右移再extend，因为实质上就是取PC[13:2]）\n其余的没什么内容了\nSplitter 把这个东西单独拿出来写只是图个方便（）\nSplitter内部的构造就只是一些小splitter\nEXT EXT也是一个相对好说的部件\n根据EXTOp进行不同形式的位扩展\n（缺点（？）是只能用于16bit -\u0026gt; 32bit）\nEXTOp 含义 0 无符号扩展 1 符号扩展 EXTOp具体怎么得到就是Ctrl要考虑的了\n外部构造：\n内部结构：\n好的我刚刚意识到bit_extender本来就可以输入EXTOp\n但是我的EXT更好看（？）那就不改了\nGRF GRF相对来说就复杂多了\n内部结构在P0课下已经搭好了，但其正确性仍需后续测试\n在此仅略加展示：\n而其外部结构也大有文章\n指令 使用数据 add,sub 读rs,rt写ALU到rd ori 读rs写ALU到rt lui 写ALU到rt lw 读rs（即base）求ALU写MemReadData到rt sw 读rs（即base）求ALU但不写Grf beq 读rs,rd求ALU（做减法判zero）但不写Grf jal 不读但写PC+4到$31 因此构造相应的控制信号与多路选择器即可\nWrsel 含义 0 写到rt 1 写到rd Wdsel 含义 0 写ALU的结果 1 写MemReadData 后续添加的jal指令我又使用了控制信号Link\nLink 含义 0 按上述两个选择器行事 1 写PC+4到$31 当然，除此之外还有最重要的写使能信号\n整体外部结构如下图所示：\nALU 首先明确ALU要解决的问题：\n加法，减法，或，左移16位共4种运算\n显然ALUOp需要4种，即需要两位信号\nALUOp 使用指令 00 add，加法 01 sub，beq，减法 10 ori，或运算 11 lui，左移16位 不过，我并没有直接分四种器件进行操作\n采用了gxp老师课上提到的方法：\n加法和减法可使用同一加法器！！\na - b = a + ~b + 1\n而两个数相加再加1正是加法器已经提供的功能！\n最上方的接口即为进位接口\n！但是复用器件的代价就是更多的选择信号\n减法不仅仅要选择进位信号，还要选择参与运算的数\n对于整个ALU还需要区分进行了什么运算\n我们分为如下三个\n使用指令 M1 M1含义 Cin Cin含义 M2 M2含义 加法 0 使用b 0 进位为0 00 加减 减法 1 使用~b 1 进位为1 00 加减 或运算 X X X X 01 或运算 左移16位 X X X X 10 左移 如何根据ALUOp写出这些控制信号也一目了然：\n只需把上面两个表合起来，让ALUOp直接对应控制信号\n用Combinational Analysis给我们写出来就行了\n最终内部结构如下：\n在此解释前文NPC中zero与br都需存在的原因：\nbeq也是对rs,rt的值做减法，但关键在于结果值为0时输出zero信号为1\n因此zero信号也是会被sub甚至add干扰的\n所以在zero==1时必须有br==1才有效\n另一方向显然，br==1时判跳转有效当然离不开zero==1的判定\n关于其外部连接，关键只是两个控制信号：\n我们把GRF处使用的表格稍有侧重点地修改\n指令 使用数据 add,sub rs,rt算ALU（加减） ori rs，imm算ALU（或运算） lui imm算ALU（移位） lw,sw rs，imm算ALU（加法） beq rs,rd算ALU（做减法判zero） 将rs替换成RD1，将rt,rd按照对应法则替换到RD2\n可得到更清晰的表格\n指令 使用数据 add,sub RD1,RD2算ALU（加减） ori RD1，imm算ALU（或运算） lui imm算ALU（移位） lw,sw RD1，imm算ALU（加法） beq RD1,RD2算ALU（做减法判zero） 即可发现控制信号除了ALUOp之外，还有操作数2的选择\n操作数2可选择RD2或imm\n因此构造相应的控制信号与多路选择器即可\nBsel 含义 0 RD2 1 imm 这里的imm都是imm_16经过EXT的结果\n事已至此，可以顺便EXTOp也考虑清楚\n准确来说，只有ori需要无符号（EXTOp == 0）\nEXTOp 指令 0 ori 1 lw,sw X 其他 beq的sign_ext已经在NPC里面确认了\nEXTOp对于beq指令没有意义\n外部连接如下图所示：\nDM 我们采用了3072*32bit的RAM 地址长度选项只需9位\nDM和GRF逻辑类似\n但是由于我们直接使用RAM\n在一些内容的表达上需要按照RAM行事\nRAM 应使用双端口模式，即设置 RAM 的 Data Interface 属性为 Separate load and store ports RAM的ld也需要特别激活，因此需要一个lw信号来控制它 str信号就是普通的写使能信号 clr信号为异步复位信号 和ROM类似，RAM的地址也以字为单位，因此PC要右移2位才能传入 右移之后还需bit_extender到9位 （一定要先右移再extend，因为实质上就是取PC[10:2]）\nDM的A接口是地址，由ALU算出\n要存入的信息则是GRF从rt读出来的RD2\n连接比较简单\n控制器的搭建 在数据通路的苦苦搭建之中，其实控制信号已经都有了自己的定义\n我们发现，这些定义一般都依赖于指令\n那么控制器就可以建起这个桥梁：\n通过opcode和funct得到指令\n再由指令得出控制信号\n由外部信号到指令 得到指令的过程我使用了比较器，因此构建过程非常简单\n由指令到控制信号 由指令到控制信号那可就更简单了\n除了 ALUOp（）\n我们使用OR阵列\n哪条指令需要这个信号，我们就给它或到这个控制信号上\n这种拉线式的写法还是很方便的\nALUOp就只能拜托我们亲爱的Combinational Analysis啦\nCTRL在整个main电路中的书写还是比较简单的\n我把他设计成了一个很富有信息量的样子（）\n搭电路的过程中一些小惬意的时光就是在修改电路外观~\n测试文档 那么至此，我们的基础版CPU算是实现了基本自洽\n接下来，就需要有大量的边界与随机指令去测试它了！\n我首先测试了课程组给出的附件，并翻译为MIPS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 .text ori\t$28, $0, 0 ori\t$29, $0, 0 ori\t$1, $0, 0x3456 add\t$1, $1, $1 lw\t$1, 4($0) sw\t$1, 4($0) lui\t$2, 0x7878 sub\t$3, $2, $1 lui\t$5, 0x1234 ori\t$4, $0, 5 nop sw\t$5, -1($4) lw\t$3, -1($4) beq\t$3, $5, _1 beq\t$0, $0, _13 _1: ori\t$7, $3, 0x404 beq\t$7, $3, _11 nop lui\t$8, 0x7777 ori\t$8, $8, -1 sub\t$0, $0, $8 ori\t0, $0, 0x1100 add\t$10, $7, $6 ori\t$8, $0, 0 ori\t$9, $0, 1 ori\t$10, $0, 1 _minus2: add\t$8, $8, $10 beq\t$8, $9, _minus2 _13: _11: _minus1: beq\t$0, $0, _minus1 # dead continue 寄存器数据及跳转测试 // 本测试的不足之处在于支持了MARS不支持的错误运算 //如最大正数加1，最小负数减1，-1减最小负数等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //记得写v2.0 raw 3c00ffff // 测试`$0` //下面是对低16位赋值 3c01ffff 3c028000 00000000 //nop测试 3c047fff 3c058000 //下面是对低16位赋值 3421ffff // `$1` = -1 34420000 // `$2` = 最小负数 34630001 // `$3` = 1 3484ffff // `$4` = 最大正数 34a50001 // `$5` = 最小负数 + 1 //sw与lw的简单测试 ac64ffff //在0处存 `$4` 测试offset为负 bc200001 //把0处的值给`$0` 测试`$0` 8c040000 //把0处的值给`$4` 测试offset为0 00253020 // `$6` = `$5` + `$1` 10460002 //等于最小负数 跳2句 //跳-8句跳回形成死循环 00643820 //最大正数加一 10e20000 //等于最小负数 跳0句 00a34022 //最小负数+1减一 11020000 //等于最小负数 跳0句 01034822 //最小负数减一 11240000 //等于最大正数 跳0句 00225022 //-1减最小负数 1144fff8 //等于最大正数 跳-8句 检验方法 在保证sw无问题的前提下\n将所有的敏感变量都及时存储\nbe like:\n1 2 3 4 5 6 .macro save(%data) #不保存$t0,$t1 sw %data, 0($t0) # 不能用addi ori $t1, $0, 4 add $t0, $t0, $t1 .end_macro 之后只需要直接比对MARS和DM的存储区即可\n","date":"2024-10-23T12:30:15+08:00","image":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/88e20704208d17e1fd4372ecfb993c3_hu1946466944430747746.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/","title":"单周期CPU的logisim搭建"},{"content":"输入指令处理 switch case 与 各方法封装 1 基本可用 但展开复杂 练习一些markdown操作（）\n1\n1 2 3 a b c d e f CommandUtil 提供command方法 // cmd\n♫ Manager类管理Arraylist commandUtil ♫ cmdUtil = cmdUtilArray.get(operator - 1);✓\ncmdUtil.command(\u0026hellip;);✓\n逻辑性错误 数据流 引用（对象 or 方法） 运算（边界条件！） 控制流 差一 意外分支 综合性 输入输出 拷贝 String 引用错误 访问空指针 报错java.lang.NullPointerException\n（注意逻辑短路先后顺序避免报错） 越界异常 类型转换错误 报错java.lang.ClassCastException （可转化情况： 类型相同 有抽象层次关系 ","date":"2024-09-26T21:30:15+08:00","image":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86/","title":"oopre课堂随笔-指令处理"},{"content":"Welcome!! I feel so excited and interested to create my first blog!\nI plan to name my blog \u0026lsquo;Demiurge\u0026rsquo; just because this song is really astonishing and touching\u0026hellip;\n(By the way, the illustration is also fantastic)\nI am suddenly awared that 我可以直接说汉语啊喂（\n那么，今后请多多指教！\n","date":"2024-09-24T00:37:20+08:00","image":"https://demiurge-zby.github.io/p/demiurgefirstblog/demiurge_hu5188072458766260427.png","permalink":"https://demiurge-zby.github.io/p/demiurgefirstblog/","title":"DemiurgeFirstBlog"}]