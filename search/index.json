[{"content":" 设计文档 前情提要 本次搭建需要实现的指令有\nadd,sum,ori,lui sw,lw beq jal,jr nop 在此基础之上，本人额外添加了lh,lb,sh,sb,j指令。\nverilog的基本构建思路源始于logisim，Tunnel化的logisim电路为verilog代码的编写提供了很大的便利和可扩展性。\nverilog的编写仍然从数据通路基础部件和控制器两方面来书写，不过额外的是，在mips.v中应当实现所有的基础接线操作。\n或者说，mips.v是最独特的一环。\n一切源代码仅供参考，千万不要抄袭！！\n数据通路的构建 PC PC作为CPU中的时序电路核心器件，其功能实现也较为简单，只有同步复位操作和npc赋值操作。\n直接由logisim文件分析PC模块的接口\n名称 位宽 方向 npc 32 I clk 1 I reset 1 I pc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 `default_nettype none module PC( input wire [31:0] npc, input wire clk, input wire reset, output wire [31:0] pc ); reg [31:0] PCreg; always @(posedge clk) begin if (reset) begin PCreg \u0026lt;= 32\u0026#39;h00003000; end else begin PCreg \u0026lt;= npc; end end assign pc = PCreg; endmodule NPC NPC与P3不同，加入了jal，jr指令，使得其增加了两种全新跳转方式：\n26位立即数经位拼接得到直接地址 32为GRF数据得到直接地址 再加上原来的pc+4与pc+4+sign_ext(imm)\n共有四种跳转逻辑，需要较多的控制信号\nbr 和 zero 控制 相对寻址跳转 j 控制imm_26绝对寻址跳转\njr 控制$ra绝对寻址跳转\n接口信息如下：\n名称 位宽 方向 pc 32 I imm_16 16 I imm_26 26 I reg_ra 32 I br 1 I zero 1 I j 1 I jr 1 I pc_4 32 O npc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 `default_nettype none module NPC( input wire br, input wire zero, input wire [15:0] imm_16, input wire [25:0] imm_26, input wire [31:0] pc, input wire [31:0] reg_ra, input wire j, input wire jr, output wire [31:0] pc_4, output wire [31:0] npc ); wire [31:0] j_pc; wire [31:0] br_pc; assign pc_4 = pc + 32\u0026#39;d4; assign j_pc = {pc[31:28],imm_26,{2{1\u0026#39;b0}}}; assign br_pc = pc_4 + {{15{imm_16[15]}},imm_16[14:0],{2{1\u0026#39;b0}}}; assign npc = (jr) ? reg_ra : (j) ? j_pc : (br \u0026amp;\u0026amp; zero) ? br_pc : pc_4; endmodule IM IM作为需要读取指令的单位，需要调用readmemh\n为了保证读取的正确顺序，定义寄存器堆时使用[0:4095]\n也可以添加参数控制readmemh读取到的起始位置与终止位置\n由于该指令寄存器堆应当存储4096*32bit\n然而起始位置却是0x00003000 因此可以先对pc减去0x00003000\n再取[13:2]作为指令寄存器堆的读取地址\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I Instruction 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 `default_nettype none module IM( input wire [31:0] pc, input wire reset, input wire clk, output wire [31:0] Instruction ); wire [31:0] address; reg [31:0] InstrMemory [0:4095]; always @(posedge clk) begin if(reset) begin $readmemh(\u0026#34;code.txt\u0026#34;, InstrMemory); end end assign address = pc - 32\u0026#39;h00003000; assign Instruction = InstrMemory[address[13:2]]; endmodule EXT 注意位拼接操作的写法！！不能少打大括号\n位拼接“0”时，一定要控制有多少个0\n例如16个“0”,应使用{16{1\u0026rsquo;b0}}或{16\u0026rsquo;b0}\n名称 位宽 方向 EXTOp 1 I imm_16 16 I IMM_32 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `default_nettype none module EXT( input wire EXTOp, input wire [15:0] imm_16, output wire [31:0] IMM_32 ); wire [31:0] signed_IMM; wire [31:0] unsigned_IMM; assign signed_IMM = {{16{imm_16[15]}},imm_16}; assign unsigned_IMM = {{16{1\u0026#39;b0}},imm_16}; assign IMM_32 = EXTOp ? signed_IMM : unsigned_IMM; endmodule GRF GRF的最特殊性在于其0号寄存器\n值不能被改变 始终值为0 在此有两种处理方案\n初始时为所有寄存器赋0\n之后不对0号寄存器进行写入 读0号寄存器时始终输出0 由于个人偏好，希望各个寄存器中的值保持正确，本人采用了第一种写法\n根据题目要求，需要输出寄存器被写时的各项参数，需要将pc传入其中\n接口如下所示：\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I WE 1 I A1 5 I A2 5 I A3 5 I WD 32 I RD1 32 O RD2 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 `default_nettype none module GRF( input wire [31:0] pc, input wire [4:0] A1, input wire [4:0] A2, input wire [4:0] A3, input wire [31:0] WD, input wire reset, input wire clk, input wire WE, output wire [31:0] RD1, output wire [31:0] RD2 ); reg [31:0] grf [31:0]; integer i; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 32;i = i + 1) begin grf[i] \u0026lt;= 32\u0026#39;b0; end end else begin if(WE \u0026amp;\u0026amp; A3) begin grf[A3] \u0026lt;= WD; $display(\u0026#34;@%h: $%d \u0026lt;= %h\u0026#34;, pc, A3, WD); end end end assign RD1 = grf[A1]; assign RD2 = grf[A2]; endmodule ALU 实现基本与logisim同理，但是操作更为简单\n注意使用`define以增强代码可读性\n名称 位宽 方向 ALUOp 2 I num_1 32 I num_2 32 I zero 1 O out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 `default_nettype none `define ADD 2\u0026#39;b00 `define SUB 2\u0026#39;b01 `define ORI 2\u0026#39;b10 `define LUI 2\u0026#39;b11 module ALU( input wire [1:0] ALUOp, input wire [31:0] num_1, input wire [31:0] num_2, output wire zero, output wire [31:0] out ); wire [31:0] add; wire [31:0] sub; wire [31:0] ori; wire [31:0] lui; assign add = num_1 + num_2; assign sub = num_1 - num_2; assign ori = num_1 | num_2; assign lui = {num_2[15:0],{16{1\u0026#39;b0}}}; assign zero = (num_1 == num_2) ? 1\u0026#39;b1 : 1\u0026#39;b0; assign out = (ALUOp == `ADD) ? add : (ALUOp == `SUB) ? sub : (ALUOp == `ORI) ? ori : lui; endmodule DM 仅对于lw和sw而言，DM本应是极为简单的。\n但是正因为sh,sb的特殊性，我尝试了对其功能的描述\nsh,sb指令的核心问题，在于我们不能直接做到针对一个字部分内容的修改\n因为我们的寄存器都是以32bit为单位的 因此我们要先把它所在寄存器的值取出来，进行位拼接操作得到该寄存器应存入的新数，再存入DM之中\n由于添加了指令，我的WE与RE信号都进行了调整\n控制信号取值 含义 00 以w为单位 01 以h为单位 10 以b为单位 11 不予使能 同样地，为了输出中间参数，pc需要被引入。\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 我还添加了word,half,by_te等中间变量，便于我后续的描述\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 `default_nettype none `define SW 2\u0026#39;b00 `define SH 2\u0026#39;b01 `define SB 2\u0026#39;b10 `define LW 2\u0026#39;b00 `define LH 2\u0026#39;b01 `define LB 2\u0026#39;b10 module DM( input wire [31:0] pc, input wire [31:0] data, input wire [31:0] addr, input wire [1:0] WE, input wire [1:0] RE, input wire clk, input wire reset, output wire [31:0] out ); reg [31:0] DataMemory [0:3071]; integer i; wire [11:0] word; wire half; wire [1:0] by_te; assign word = addr[13:2]; assign by_te = addr[1:0]; assign half = addr[1]; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 3072; i = i + 1) begin DataMemory[i] \u0026lt;= 32\u0026#39;b0; end end else begin case (WE) `SW: begin DataMemory[word] \u0026lt;= data; $display(\u0026#34;@%h: *%h \u0026lt;= %h\u0026#34;, pc, addr, data); end `SH: begin case (half) 1\u0026#39;b1: begin DataMemory[word] \u0026lt;= {data[15:0], DataMemory[word][15:0]}; end 1\u0026#39;b0: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[15:0]}; end default: begin end endcase end `SB: begin case (by_te) 2\u0026#39;b11: begin DataMemory[word] \u0026lt;= {data[7:0], DataMemory[word][23:0]}; end 2\u0026#39;b10: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:24], data[7:0], DataMemory[word][15:0]}; end 2\u0026#39;b01: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[7:0], DataMemory[word][7:0]}; end 2\u0026#39;b00: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:8], data[7:0]}; end default: begin end endcase end default: begin end endcase end end assign out = (RE == `LW) ? DataMemory[word] : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b1) ? {{16{DataMemory[word][31]}},DataMemory[word][31:16]} : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b0) ? {{16{DataMemory[word][15]}}, DataMemory[word][15:0]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b11) ? {{24{DataMemory[word][31]}}, DataMemory[word][31:24]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b10) ? {{24{DataMemory[word][23]}}, DataMemory[word][23:16]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b01) ? {{24{DataMemory[word][15]}}, DataMemory[word][15:8]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b00) ? {{24{DataMemory[word][7]}}, DataMemory[word][7:0]} : 32\u0026#39;b0; endmodule 控制器的编写 在搭建数据通路的过程中，控制信号的要求也已经浮出水面。\n关键还是由IM到指令，由指令到控制信号的过程\n不过加入了其他操作，使得DMWr,DMRd发生了一定的改变 以及额外添加的Link,J,Jr等控制信号\n相较于P3的BSel,此处本人将其更名为ImmSel,强调其解决的是立即数与寄存器谁参与ALU运算的问题\n名称 位宽 方向 opcode 6 I funct 6 I Br 1 O EXTOp 1 O RFWr 1 O DMWr 2 O DMRd 2 O ALUOp 2 O WrSel 1 O WdSel 1 O ImmSel 1 O Link 1 O J 1 O Jr 1 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 `default_nettype none module CTRL( input wire [5:0] opcode, input wire [5:0] funct, output wire Br, output wire EXTOp, output wire RFWr, output wire [1:0] DMWr, output wire [1:0] DMRd, output wire [1:0] ALUOp, output wire WrSel, output wire WdSel, output wire ImmSel, output wire Link, output wire J, output wire Jr ); wire add; wire sub; wire ori; wire lui; wire sw; wire sh; wire sb; wire lw; wire lh; wire lb; wire beq; wire j; wire jal; wire jr; wire R; assign R = (opcode == 6\u0026#39;b000000); assign add = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100000); assign sub = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100010); assign jr = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b001000); assign j = (opcode == 6\u0026#39;b000010); assign jal = (opcode == 6\u0026#39;b000011); assign ori = (opcode == 6\u0026#39;b001101); assign lui = (opcode == 6\u0026#39;b001111); assign sw = (opcode == 6\u0026#39;b101011); assign sh = (opcode == 6\u0026#39;b101001); assign sb = (opcode == 6\u0026#39;b101000); assign lw = (opcode == 6\u0026#39;b100011); assign lh = (opcode == 6\u0026#39;b100001); assign lb = (opcode == 6\u0026#39;b100000); assign beq = (opcode == 6\u0026#39;b000100); assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign ImmSel = ori || lui || sw || sh || sb || lw || lh || lb; assign EXTOp = sw || sh || sb || lw || lh || lb; assign ALUOp = sub ? 2\u0026#39;b01 : ori ? 2\u0026#39;b10 : lui ? 2\u0026#39;b11 : 2\u0026#39;b00; assign RFWr = add || sub || ori || lui || lw || lb || lh || jal; assign DMRd = lw ? 2\u0026#39;b00 : lh ? 2\u0026#39;b01 : lb ? 2\u0026#39;b10 : 2\u0026#39;b11; assign DMWr = sw ? 2\u0026#39;b00 : sh ? 2\u0026#39;b01 : sb ? 2\u0026#39;b10 : 2\u0026#39;b11; endmodule mips.v 前面说了那么多，其实都是相对独立的结构 那么接下来，才是verilog描述的独特之处 才能更深刻地展示verilog的抽象功能\n接口十分简单，毕竟真正来自外部的信号只有clk和reset\n名称 位宽 方向 clk 1 I reset 1 I 1 2 3 4 5 `default_nettype none module mips( input wire clk, input wire reset ); 接线逻辑 在我书写这一板块的过程中，我曾选用了将所有的wire先定义好，再全部统一赋值，再逐个接接口的方法\n结果这样导致的问题（或者说我曾经出现的bug） 就是你不能确定你需要的信号都得到了定义与赋值\n因此，我秉承了P3的基本思路，对各个部件的外部接线进行分析。\n分析方法：\n先定义所有需要的输出信号 输入信号分为 直接与其他某部件的输出信号直接相连 由其他部件的输出信号相互作用（计算or选择）得到 为这些相互作用进行assign处理 基础信号 名义上如此，其实这是在模拟我没有模块化的Splitter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 基础信号定义 wire [5:0] opcode; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [4:0] shamt; wire [5:0] funct; assign opcode = Instr[31:26]; assign rs = Instr[25:21]; assign rt = Instr[20:16]; assign rd = Instr[15:11]; assign shamt = Instr[10:6]; assign funct = Instr[5:0]; wire [15:0] imm_16; wire [25:0] imm_26; assign imm_16 = Instr[15:0]; assign imm_26 = Instr[25:0]; CTRL 定义大量控制信号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //控制信号定义 wire Br; wire EXTOp; wire RegWrite; wire [1:0] DMWr; wire [1:0] DMRd; wire [1:0] ALUOp; wire WrSel; wire WdSel; wire ImmSel; wire Link; wire J; wire Jr; CTRL Ctrl( .opcode(opcode), .funct(funct), .Br(Br), .EXTOp(EXTOp), .RFWr(RegWrite), .DMWr(DMWr), .DMRd(DMRd), .ALUOp(ALUOp), .WrSel(WrSel), .WdSel(WdSel), .ImmSel(ImmSel), .Link(Link), .J(J), .Jr(Jr) ); PC 定义输出信号pc\n1 2 3 4 5 6 7 8 // PC 输出信号 wire [31:0] pc; PC Pc( .npc(npc), .clk(clk), .reset(reset), .pc(pc) ); IM 定义输出信号Instr\n1 2 3 4 5 6 7 8 9 10 // IM输出信号 wire [31:0] Instr; IM Im( .pc(pc), .Instruction(Instr), .clk(clk), .reset(reset) ); EXT 定义输出信号IMM_32\n1 2 3 4 5 6 7 8 // EXT输出信号 wire [31:0] IMM_32; EXT Ext( .EXTOp(EXTOp), .imm_16(imm_16), .IMM_32(IMM_32) ); NPC 定义输出信号npc和pc_4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // NPC输出信号 wire [31:0] npc; wire [31:0] pc_4; NPC Npc( .br(Br), .zero(zero), .imm_16(imm_16), .imm_26(imm_26), .pc(pc), .reg_ra(RD2), .j(J), .jr(Jr), .pc_4(pc_4), .npc(npc) ); GRF 定义输出信号RD1,RD2 定义输入信号，并给出其assign语句实现赋值 要知道，输入信号一定要从其他部件的输出信号或者外部的clk 与reset中得到 如果盲目定义输入信号，却不予有意义的赋值，就会产生xxxzzz等问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // GRF 输入信号·中间变量 wire [31:0] LinkPC; wire [4:0] A1; wire [4:0] A2; wire [4:0] RegAddr; wire [31:0] RegData; // GRF 中间变量的赋值 assign LinkPC = pc_4; assign A1 = rs; assign A2 = Jr ? 5\u0026#39;b11111 : rt; assign RegAddr = Link ? 5\u0026#39;b11111 : WrSel ? rd : rt; assign RegData = Link ? LinkPC : WdSel ? MemReadData : ALUData; // GRF 输出信号 wire [31:0] RD1; wire [31:0] RD2; GRF Grf( .clk(clk), .reset(reset), .WE(RegWrite), .pc(pc), .A1(A1), .A2(A2), .A3(RegAddr), .WD(RegData), .RD1(RD1), .RD2(RD2) ); ALU 输出信号zero和ALUData\n定义输入信号num_1，num_2并给出assign\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ALU 输入信号·中间变量 wire [31:0] num_1; wire [31:0] num_2; // ALU 中间变量的赋值 assign num_1 = RD1; assign num_2 = ImmSel ? IMM_32 : RD2; // ALU 输出信号 wire zero; wire [31:0] ALUData; ALU Alu( .ALUOp(ALUOp), .num_1(num_1), .num_2(num_2), .zero(zero), .out(ALUData) ); DM 这两个输入变量的赋值是否没有意义？\nMemAddr一定是ALUData?\nMemData一定是RD2?\n可能确实如此。 但是这样的命名使得整体逻辑更为清晰，也增强了可扩展性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // DM 输入信号·中间变量 wire [31:0] MemAddr; wire [31:0] MemData; // DM 中间变量的赋值 assign MemAddr = ALUData; assign MemData = RD2; // DM 输出信号 wire [31:0] MemReadData; DM Dm( .pc(pc), .data(MemData), .addr(MemAddr), .WE(DMWr), .RE(DMRd), .clk(clk), .reset(reset), .out(MemReadData) ); endmodule 测试文档 我仍然采用了对拍的方法，并自行构造了一定数据。\n对于新增指令，我着重加强了对jr,jal的测试\n以下是一组测试数据，重点观察$ra取值的改变是否正常\n1 2 3 4 5 6 7 8 9 0c000c06 // jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f301c //ori $ra, $0, 0x0000301c //label: 03e00008 //jr $ra 03fff820 //add $ra, $ra, $ra 可知$ra会在pc+4和0不断跳转\n直到变为0x0000301c后跳转到add语句变为0x00006038\n下面是我的输出结果，与MIPS结果一致\n1 2 3 4 5 6 7 @00003000: $31 \u0026lt;= 00003004 @00003004: $31 \u0026lt;= 00000000 @00003008: $31 \u0026lt;= 0000300c @0000300c: $31 \u0026lt;= 00000000 @00003010: $31 \u0026lt;= 00003014 @00003014: $31 \u0026lt;= 0000301c @0000301c: $31 \u0026lt;= 00006038 测试题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ?\naddr信号来自于ALU的计算，即GRF[base]+sign_ext(offset) 其中addr[11:2]意为取ALU计算结果从第2位开始的12位数字作为address。 其原因在于对于lw指令，第0位和第1位均为0，自第2位起开始计数才是以32bit为单位，才能与DM寄存器堆的寄存器编号相对应。\n思考两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。\n控制信号每种取值所对应的指令： 举例：\n1 2 3 4 5 6 7 assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign EXTOp = sw || sh || sb || lw || lh || lb; 每条指令对应的控制信号取值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 always@(*) begin case (Operation) `ADD : begin Br = 1\u0026#39;b0; Jr = 1\u0026#39;b0; Link = 1\u0026#39;b0; J = 1\u0026#39;b0; WrSel = 1\u0026#39;b1; ... end ... default : begin end end 分析优劣： 由指令确定其控制信号： 优点：考虑全面，不会有漏掉的指令，对每个指令也不会有漏掉的控制信号 上机新增指令时直接对其分析，一个也不会漏 缺点：代码重复冗长 产生新的控制信号时还需要对每个指令都加句话\n对控制信号归纳其生效指令： 优点：本质上是上一种方法的总结归纳，代码量少 缺点：自行归纳时某些控制信号可能会忘记考虑一些指令\nPS：解决方法：对新指令在演草纸上进行所有控制信号枚举，之后再进行归纳，用于代码书写\n在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。\n同步复位：clk优先（还必须得是上升沿） 异步复位：reset优先\nC 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。\n1 2 if temp32 ≠ temp31 then SignalException(IntegerOverflow) 这是add和addu、addi和addiu的唯一区别 u的本意即为不考虑输出 那在忽略输出的前提下自然就等价了。\n","date":"2024-10-31T14:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/292fa3e8c7e86664cbaefef9ddc7893_hu9110516496620476980.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/","title":"单周期CPU的verilog搭建"},{"content":"序列输入之数据特征分析 数据类型 不作介绍 关系 顺序关系 依次赋值 层次关系（赋值的所属对象） 1 2 3 4 5 6 7 8 Scanner scanner = new Scanner(System.in); int i; int n = scanner.nextInt(); for(i = 0; i \u0026lt; n; i++){ id = scanner.nextInt(); name = scanner.next();// id 与 name之间为顺序关系 // 不同组之间形成不同层次 } 结构 硬编码式的解析处理 较为简单，确定的输入方式 缺点：兼容性灵活性差 使用正则表达式的解析处理 可对应一个有穷自动机解析 默认使用贪婪匹配\n\u0026ldquo;.\u0026rdquo; 任意\n\u0026ldquo;*\u0026rdquo; 同一项内容任意项\n\u0026ldquo;+\u0026rdquo; 同一内容一项或多项\n\u0026ldquo;?\u0026rdquo; 同一内容零项或一项\n非贪婪匹配\n```java Pattern = new Pattern.compile(\u0026quot;(\\\\w+?)((good)*)\u0026quot;); // 添加 \\w+? 实现非贪婪 // 注意 \\\\ 编译问题 ``` 弊端：可读性差，技巧性高\n递归下降式解析处理 递归 借助递归进行解析 下降 从顶层到底层 按层解析 文法 终结符 取值不可变的符号，单个字符层级上的元素 非终结符 取值可变，以\u0026lt;\u0026gt;表示 定义规则 L -\u0026gt; R\n定义非终结符的取值方式\n1 2 3 4 5 \u0026lt;Var\u0026gt; -\u0026gt; \u0026lt;digit\u0026gt; | \u0026lt;Const\u0026gt; \u0026lt;Var\u0026gt; //递归下降 无限循环 \u0026lt;Const\u0026gt; -\u0026gt; \u0026lt;op\u0026gt; | \u0026lt;digit\u0026gt; \u0026lt;op\u0026gt; \u0026lt;digit\u0026gt; -\u0026gt; \u0026#39;0\u0026#39;|\u0026#39;1\u0026#39;|\u0026#39;2\u0026#39;|\u0026#39;3\u0026#39;|\u0026#39;4\u0026#39;|\u0026#39;5\u0026#39;|\u0026#39;6\u0026#39;|\u0026#39;7\u0026#39;|\u0026#39;8\u0026#39;|\u0026#39;9\u0026#39; \u0026lt;op\u0026gt; -\u0026gt; \u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;|\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39; // \u0026#39;+\u0026#39;为终结符，\u0026lt;op\u0026gt;,\u0026lt;Const\u0026gt;为非终结符 词法分析：定义Token 1 2 3 4 5 public class Token{ private String name; private Type type; // ... } //实现了一种抽象 语法分析：建立抽象语法树 根据文法所定义的关系\n1 2 3 4 5 public class Var{ private Arraylist\u0026lt;digit\u0026gt;; private Arraylist\u0026lt;op\u0026gt;; // ... } // 在表达树的方面降了一层 由表达式到项，由项到因子\n每一个非终结符都对应一棵局部语法树\n","date":"2024-10-24T15:30:00+08:00","image":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/15c277c39924c01bcd89e8f7b84de46_hu6067831623915793491.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/","title":"oopre课堂随笔-序列输入"},{"content":" 设计文档 Key Point: 数据通路，控制器及其连接\n要实现的核心指令介绍 add,sub,lui,ori,lw,sw,beq,nop\n数据通路的建立 名称 功能 简写 程序计数器 输出当前指令所在地址 PC 下指令地址 计算下一指令所在地址并传递给PC NPC 寄存器堆 32 个 32 位寄存器 GRF 指令存储器 存储所有的指令 IM 数据存储器 充当内存存储数据 DM 扩展单元 进行位扩展运算 EXT 算术逻辑单元 进行各项基本运算 ALU 下面先对各数据通路进行分析，并在此过程中得到对控制器的需求\n(在每个数据通路中都只考虑自己需要什么！\n输出的东西如何被使用是其他数据通路考虑的事情！！)\nPC 一个 32 位寄存器即可\n输出引脚：输出当前指令所在地址，提供给IM用于取指令\n输入引脚：由NPC算出的下一条指令地址\n作为整个设备中最核心的时序逻辑，在PC层面其本质应为Moore机\n在下一周期上升沿才可输出下一PC\n在输出PC以后，其他数据通路都基本呈现组合逻辑的形态，即时性进行输出内容的改变，即Mealy机\n（ROM和GRF的写入操作还是要等下一上升沿的，但是关于其写入的各项信息都是即时性得到的）\n当然，最后输出PC值的时候要再加上 3000\n若用PC初始化3000的方法，在复位后PC还是会输出 0\nNPC 下一指令的地址可能是PC+4\n对于beq跳转 也可能是PC+4+sign_ext(imm_16 || 00)\n对于j, jal跳转 还可能是PC[31:28] || imm_26 || 00\n输入引脚：输入当前PC值，imm_16, imm_26\n选择信号：br, zero, j\n这里区分br和zero是有原因的。\n详见zero产出地：ALU\n输出引脚：下一条指令PC值\n！！经后续分析，对于XXXAndLink指令，PC+4是被需要的，那就直接从NPC输出\nNPC外部的连接也比较直白\n具体分析：\n控制信号的使用：\n只有br和zero同时为1时才是成功beq跳转 鉴别出j，jal等才使用imm_26直接地址跳转 Tips: 由于jal指令为本人后续添加，因此选择了新增了MUX而不是改变原MUX\n计算过程实现：简单的加法，移位，位扩展，位拼接运算\n要注意位扩展一定是sign_ext，因此完全可以直接使用bit_sign_extender\nIM 采用了4096*32bit的ROM 地址长度选项只需12位\n！！ROM的地址以字为单位，因此PC要右移2位才能传给ROM\n右移之后还需bit_extender到12位\n（一定要先右移再extend，因为实质上就是取PC[13:2]）\n其余的没什么内容了\nSplitter 把这个东西单独拿出来写只是图个方便（）\nSplitter内部的构造就只是一些小splitter\nEXT EXT也是一个相对好说的部件\n根据EXTOp进行不同形式的位扩展\n（缺点（？）是只能用于16bit -\u0026gt; 32bit）\nEXTOp 含义 0 无符号扩展 1 符号扩展 EXTOp具体怎么得到就是Ctrl要考虑的了\n外部构造：\n内部结构：\n好的我刚刚意识到bit_extender本来就可以输入EXTOp\n但是我的EXT更好看（？）那就不改了\nGRF GRF相对来说就复杂多了\n内部结构在P0课下已经搭好了，但其正确性仍需后续测试\n在此仅略加展示：\n而其外部结构也大有文章\n指令 使用数据 add,sub 读rs,rt写ALU到rd ori 读rs写ALU到rt lui 写ALU到rt lw 读rs（即base）求ALU写MemReadData到rt sw 读rs（即base）求ALU但不写Grf beq 读rs,rd求ALU（做减法判zero）但不写Grf jal 不读但写PC+4到$31 因此构造相应的控制信号与多路选择器即可\nWrsel 含义 0 写到rt 1 写到rd Wdsel 含义 0 写ALU的结果 1 写MemReadData 后续添加的jal指令我又使用了控制信号Link\nLink 含义 0 按上述两个选择器行事 1 写PC+4到$31 当然，除此之外还有最重要的写使能信号\n整体外部结构如下图所示：\nALU 首先明确ALU要解决的问题：\n加法，减法，或，左移16位共4种运算\n显然ALUOp需要4种，即需要两位信号\nALUOp 使用指令 00 add，加法 01 sub，beq，减法 10 ori，或运算 11 lui，左移16位 不过，我并没有直接分四种器件进行操作\n采用了gxp老师课上提到的方法：\n加法和减法可使用同一加法器！！\na - b = a + ~b + 1\n而两个数相加再加1正是加法器已经提供的功能！\n最上方的接口即为进位接口\n！但是复用器件的代价就是更多的选择信号\n减法不仅仅要选择进位信号，还要选择参与运算的数\n对于整个ALU还需要区分进行了什么运算\n我们分为如下三个\n使用指令 M1 M1含义 Cin Cin含义 M2 M2含义 加法 0 使用b 0 进位为0 00 加减 减法 1 使用~b 1 进位为1 00 加减 或运算 X X X X 01 或运算 左移16位 X X X X 10 左移 如何根据ALUOp写出这些控制信号也一目了然：\n只需把上面两个表合起来，让ALUOp直接对应控制信号\n用Combinational Analysis给我们写出来就行了\n最终内部结构如下：\n在此解释前文NPC中zero与br都需存在的原因：\nbeq也是对rs,rt的值做减法，但关键在于结果值为0时输出zero信号为1\n因此zero信号也是会被sub甚至add干扰的\n所以在zero==1时必须有br==1才有效\n另一方向显然，br==1时判跳转有效当然离不开zero==1的判定\n关于其外部连接，关键只是两个控制信号：\n我们把GRF处使用的表格稍有侧重点地修改\n指令 使用数据 add,sub rs,rt算ALU（加减） ori rs，imm算ALU（或运算） lui imm算ALU（移位） lw,sw rs，imm算ALU（加法） beq rs,rd算ALU（做减法判zero） 将rs替换成RD1，将rt,rd按照对应法则替换到RD2\n可得到更清晰的表格\n指令 使用数据 add,sub RD1,RD2算ALU（加减） ori RD1，imm算ALU（或运算） lui imm算ALU（移位） lw,sw RD1，imm算ALU（加法） beq RD1,RD2算ALU（做减法判zero） 即可发现控制信号除了ALUOp之外，还有操作数2的选择\n操作数2可选择RD2或imm\n因此构造相应的控制信号与多路选择器即可\nBsel 含义 0 RD2 1 imm 这里的imm都是imm_16经过EXT的结果\n事已至此，可以顺便EXTOp也考虑清楚\n准确来说，只有ori需要无符号（EXTOp == 0）\nEXTOp 指令 0 ori 1 lw,sw X 其他 beq的sign_ext已经在NPC里面确认了\nEXTOp对于beq指令没有意义\n外部连接如下图所示：\nDM 我们采用了3072*32bit的RAM 地址长度选项只需9位\nDM和GRF逻辑类似\n但是由于我们直接使用RAM\n在一些内容的表达上需要按照RAM行事\nRAM 应使用双端口模式，即设置 RAM 的 Data Interface 属性为 Separate load and store ports RAM的ld也需要特别激活，因此需要一个lw信号来控制它 str信号就是普通的写使能信号 clr信号为异步复位信号 和ROM类似，RAM的地址也以字为单位，因此PC要右移2位才能传入 右移之后还需bit_extender到9位 （一定要先右移再extend，因为实质上就是取PC[10:2]）\nDM的A接口是地址，由ALU算出\n要存入的信息则是GRF从rt读出来的RD2\n连接比较简单\n控制器的搭建 在数据通路的苦苦搭建之中，其实控制信号已经都有了自己的定义\n我们发现，这些定义一般都依赖于指令\n那么控制器就可以建起这个桥梁：\n通过opcode和funct得到指令\n再由指令得出控制信号\n由外部信号到指令 得到指令的过程我使用了比较器，因此构建过程非常简单\n由指令到控制信号 由指令到控制信号那可就更简单了\n除了 ALUOp（）\n我们使用OR阵列\n哪条指令需要这个信号，我们就给它或到这个控制信号上\n这种拉线式的写法还是很方便的\nALUOp就只能拜托我们亲爱的Combinational Analysis啦\nCTRL在整个main电路中的书写还是比较简单的\n我把他设计成了一个很富有信息量的样子（）\n搭电路的过程中一些小惬意的时光就是在修改电路外观~\n测试文档 那么至此，我们的基础版CPU算是实现了基本自洽\n接下来，就需要有大量的边界与随机指令去测试它了！\n我首先测试了课程组给出的附件，并翻译为MIPS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 .text ori\t$28, $0, 0 ori\t$29, $0, 0 ori\t$1, $0, 0x3456 add\t$1, $1, $1 lw\t$1, 4($0) sw\t$1, 4($0) lui\t$2, 0x7878 sub\t$3, $2, $1 lui\t$5, 0x1234 ori\t$4, $0, 5 nop sw\t$5, -1($4) lw\t$3, -1($4) beq\t$3, $5, _1 beq\t$0, $0, _13 _1: ori\t$7, $3, 0x404 beq\t$7, $3, _11 nop lui\t$8, 0x7777 ori\t$8, $8, -1 sub\t$0, $0, $8 ori\t0, $0, 0x1100 add\t$10, $7, $6 ori\t$8, $0, 0 ori\t$9, $0, 1 ori\t$10, $0, 1 _minus2: add\t$8, $8, $10 beq\t$8, $9, _minus2 _13: _11: _minus1: beq\t$0, $0, _minus1 # dead continue 寄存器数据及跳转测试 // 本测试的不足之处在于支持了MARS不支持的错误运算 //如最大正数加1，最小负数减1，-1减最小负数等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //记得写v2.0 raw 3c00ffff // 测试`$0` //下面是对低16位赋值 3c01ffff 3c028000 00000000 //nop测试 3c047fff 3c058000 //下面是对低16位赋值 3421ffff // `$1` = -1 34420000 // `$2` = 最小负数 34630001 // `$3` = 1 3484ffff // `$4` = 最大正数 34a50001 // `$5` = 最小负数 + 1 //sw与lw的简单测试 ac64ffff //在0处存 `$4` 测试offset为负 bc200001 //把0处的值给`$0` 测试`$0` 8c040000 //把0处的值给`$4` 测试offset为0 00253020 // `$6` = `$5` + `$1` 10460002 //等于最小负数 跳2句 //跳-8句跳回形成死循环 00643820 //最大正数加一 10e20000 //等于最小负数 跳0句 00a34022 //最小负数+1减一 11020000 //等于最小负数 跳0句 01034822 //最小负数减一 11240000 //等于最大正数 跳0句 00225022 //-1减最小负数 1144fff8 //等于最大正数 跳-8句 检验方法 在保证sw无问题的前提下\n将所有的敏感变量都及时存储\nbe like:\n1 2 3 4 5 6 .macro save(%data) #不保存$t0,$t1 sw %data, 0($t0) # 不能用addi ori $t1, $0, 4 add $t0, $t0, $t1 .end_macro 之后只需要直接比对MARS和DM的存储区即可\n","date":"2024-10-23T12:30:15+08:00","image":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/88e20704208d17e1fd4372ecfb993c3_hu1946466944430747746.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/","title":"单周期CPU的logisim搭建"},{"content":"输入指令处理 switch case 与 各方法封装 1 基本可用 但展开复杂 练习一些markdown操作（）\n1\n1 2 3 a b c d e f CommandUtil 提供command方法 // cmd\n♫ Manager类管理Arraylist commandUtil ♫ cmdUtil = cmdUtilArray.get(operator - 1);✓\ncmdUtil.command(\u0026hellip;);✓\n逻辑性错误 数据流 引用（对象 or 方法） 运算（边界条件！） 控制流 差一 意外分支 综合性 输入输出 拷贝 String 引用错误 访问空指针 报错java.lang.NullPointerException\n（注意逻辑短路先后顺序避免报错） 越界异常 类型转换错误 报错java.lang.ClassCastException （可转化情况： 类型相同 有抽象层次关系 ","date":"2024-09-26T21:30:15+08:00","image":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86/","title":"oopre课堂随笔-指令处理"},{"content":"Welcome!! I feel so excited and interested to create my first blog!\nI plan to name my blog \u0026lsquo;Demiurge\u0026rsquo; just because this song is really astonishing and touching\u0026hellip;\n(By the way, the illustration is also fantastic)\nI am suddenly awared that 我可以直接说汉语啊喂（\n那么，今后请多多指教！\n","date":"2024-09-24T00:37:20+08:00","image":"https://demiurge-zby.github.io/p/demiurgefirstblog/demiurge_hu5188072458766260427.png","permalink":"https://demiurge-zby.github.io/p/demiurgefirstblog/","title":"DemiurgeFirstBlog"}]