[{"content":" 说在前面 能通过P5实在是很好的一件事。 在我第一道题直接AC确定课下无bug，在我很快做出前两道题确定自己能通过后，我真的如释重负。 题目并不难，在课下提交截止前找出bug并修复真的是我能通过P5的重要原因。 反思前两题，还可以做得更快。思路清晰，才能更精准更利索。\n上次也说到了，咱们的P6要实现30条指令了！\n具体地说： add, sub, and, or, slt, sltu, lui, addi, andi, ori, lb, lh, lw, sb, sh, sw, mult, multu, div, divu, mfhi, mflo, mthi, mtlo, beq, bne, j, jal, jr, nop\n接下来，我们就开始吧！\n设计文档 本次P6搭建，我还是选择采用边搭建边写设计文档的方法。\n通过记录设计文档来记录我的每一步更改进度，对于P6这种考验严谨性的工程是较有益的。\nP6的主要任务，是在一个相对完善的架构上去增添大量的同类型新指令和少量的特殊指令。\nadd, sub, and, or, slt, sltu, lui,\naddi, andi, ori,\nlb, lh, lw, sb, sh, sw,\nmult, multu, div, divu, mfhi, mflo, mthi, mtlo,\nbeq, bne, j, jal, jr,\nnop\n比较新鲜的指令有set型，字节访存，还有最特别的乘除模块指令！\n我的搭建逻辑是最后处理乘除模块，先搭简单的，或者说白了，先搭非乘除模块（）\n顶层模块的改装 由于P6修改了IM和DM模块，在外部接入指令存储器与数据存储器，并在外部实现写入内容的输出\n对于这些新的接口，\n1 2 3 4 5 6 7 8 9 10 11 input [31:0] i_inst_rdata, input [31:0] m_data_rdata, output [31:0] i_inst_addr, output [31:0] m_data_addr, output [31:0] m_data_wdata, output [3 :0] m_data_byteen, output [31:0] m_inst_addr, output w_grf_we, output [4:0] w_grf_addr, output [31:0] w_grf_wdata, output [31:0] w_inst_addr 为了较少地改动我们的原版CPU，我们采用 assign 顶层输出信号 = 部件输入信号 assign 部件输出信号 = 顶层输入信号 的方式进行书写。\n相当于：本来传给IM,DM部件的信号现在要作为顶层输出信号传给外部IM,DM、 而本来从IM和DM部件得到的数据现在要由外部IM,DM通过顶层输入信号进行赋值。\n其中只有m_data_byteen这一信号是我们从未出现过的，它涉及到了lh,lb,sh,sb四条新指令。\nDM的写 不难设计一个STORE模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 `timescale 1ns / 1ps `define SW 2\u0026#39;b01 `define SH 2\u0026#39;b10 `define SB 2\u0026#39;b11 `default_nettype none module STORE( input wire [1:0] DMWr_M, input wire [31:0] MemAddr_M, output wire [3:0] byteen ); wire half; wire [1:0] by_te; assign half = MemAddr_M[1]; assign by_te = MemAddr_M[1:0]; assign byteen = { ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b1))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b11))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b1))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b10))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b0))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b01))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b0))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b00)))}; endmodule 在顶层,我们可以直接将m_data_byteen与byteen接口相连 也可以新建信号以提高可扩展性\nDM不需要读使能，它始终会读出该地址存储的值，只是后续再通过WdSel来判断你用不用这个信号罢了 而且DM的写使能也很方便实现： |byteen ,将它的各位或起来就可以作为写使能，即存在1就要写。 byteen本身又是控制信号，即哪是1哪被写。\nDM的写就基本完成了 （毕竟功能本身已经由testbench全权负责了）\n! 这样的执行逻辑与MARS是不同的！经过和学长的交流，m_data_wdata跟MemData显然应当是不同的。\n在此加入对MemData做处理的语句，也不难写\n1 2 3 4 5 assign m_data_wdata = (DMWr_M == `LW) ? MemData_M : (DMWr_M == `LH) ? {MemData_M[15:0], MemData_M[15:0]} : (DMWr_M == `LB) ? {MemData_M[7:0], MemData_M[7:0], MemData_M[7:0], MemData_M[7:0]} : 32\u0026#39;b0; DM的读 前文也说到，DM一直会读，但是lw,lh,lb就需要你来处理了。 根据读出的整个字和控制信号，我们可以实现把MemReadData变成正确的值。 相应地，我们需要通过一个模块将m_data_rdata变为MemRead 再将MemRead赋值给MemReadData（同样是为了可扩展性）\n这个模块也很好写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 `timescale 1ns / 1ps `define LW 2\u0026#39;b01 `define LH 2\u0026#39;b10 `define LB 2\u0026#39;b11 `default_nettype none module LOAD( input wire [1:0] DMRd_M, input wire [31:0] m_data_rdata, input wire [31:0] MemAddr_M, output wire [31:0] MemRead ); wire half; wire [1:0] by_te; assign half = MemAddr_M[1]; assign by_te = MemAddr_M[1:0]; assign MemRead = (DMRd_M == `LW) ? m_data_rdata : (DMRd_M == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b1) ? {{16{m_data_rdata[31]}}, m_data_rdata[31:16]} : (DMRd_M == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b0) ? {{16{m_data_rdata[15]}}, m_data_rdata[15:0]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b11) ? {{24{m_data_rdata[31]}}, m_data_rdata[31:24]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b10) ? {{24{m_data_rdata[23]}}, m_data_rdata[23:16]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b01) ? {{24{m_data_rdata[15]}}, m_data_rdata[15:8]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b00) ? {{24{m_data_rdata[7]}}, m_data_rdata[7:0]} : 32\u0026#39;b0; endmodule IM 这个就不用说了，两句话的事\n1 2 assign i_inst_addr = pc_F; assign Instr_F = i_inst_rdata; sh,sb,lh,lb 做事做到底，就把他们直接都写完吧\n书写逻辑： 1.CTRL各项控制信号添加 (和lw，sw完全对应一致) 2.CTRL中Tuse,Tnew (和lw，sw完全对应一致) 3.具体实现（已完成）\n简单的E级ALU写数指令 这类指令也很简单，在此也只有两类： add型: add, sub, and, or ori型：addi, andi, ori （在此add型再添加：slt, sltu 原因在下一小节\n读两个数 算一个数 也就是add型指令 把它归为同一类的原因，主要是控制信号过于相似： 相同调控（置相同的数）的信号有：WrSel, RFWr, Tuse_rs, Tuse_rt, Tnew_D 特异性的信号是ALUOp,用宏定义增强可读性\n书写时要额外注意slt和sltu\n1 2 3 assign slt = ($signed(num_1) \u0026lt; $signed(num_2)) ? $signed(1) : $signed(0); // 1和0是有符号数。但我还是保险起见 assign sltu = (num_1 \u0026lt; num_2) ? 32\u0026#39;b1 : 32\u0026#39;b0; // 32\u0026#39;b1和32\u0026#39;b0都是无符号数 读一个数 拿一个立即数 算一个数 也就是ori型指令 其实和上一类很像，不过区别在于： num_2是IMM_32而非V2 写的寄存器是rt而非rd 相同调控（置相同的数）的信号有：RFWr, ImmSel, Tuse_rs, Tuse_rt, Tnew_D ！特异性： ADDI是符号扩展 ,ORI,ANDI是零扩展\nD级算数指令 真的要在D级算数？ 这是我之前从未触及的一个点。在此，为提高效率，我将冒险进行优化： 这类指令有slt, sltu, lui, jal 把它们前移至D级改变了两件事：Tnew降低、Tuse降低 我之前并没有写过E-D转发，使得lui和jal的Tnew均为1 经过优化，他们的Tnew可以变成0，从而避免后续指令被阻塞 但他们也有风险：风险就是Tuse降低使得他们本身的操之过急可能会使自己被阻塞\n事实上，lui和jal是直接对立即数操作，因此并没有Tuse的风险问题。 而slt和sltu则有风险。\n因此我将slt和sltu放回了简单的E级ALU写数指令。\nlui 和 jal 的 E-\u0026gt;D转发 接下来先说说我对lui和jal的改进吧。 首先，jal的转发十分简单，只要当A1(A2)等于31且Link_E时把pc+8传过去而已。 jal在后面把这个值选择赋给了ALUData_E_True,即\n1 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : ALUData_E; 那么相应地，lui的转发也可以很简单。 真正要写入寄存器的lui的值当然还是ALU算出来的，相当于节省了把这个值选择赋给ALUData_E_True的过程。 lui未曾有的，是他的独特信号，即Lui lui要转发的值，就是{IMM32_E[15:0], 16\u0026rsquo;b0} 由于后续由ALU承包，Lui信号只需要坚持到E-\u0026gt;D转发就够了 可知我们需要改动CTRL，D_E这两个子模块。\n那么咱们的成效就要显露出来了： 那就是减少阻塞！Tnew降为0！\n在CTRL中更改Tnew信号后，这一段路，也算是走完了。\n跳转指令 增添的新指令是bne 已经可以称得上和beq完全一致了吧\u0026hellip;\n主要差别只在于zero和!zero 相同调控（置相同的数）的信号有：PCSel, Tuse_rs, Tuse_rt, (Tnew都不存在)\n不过bne和beq要区分，所以还是需要有控制信号传出来。\n主要就是NPC引入新接口bne,参与了npc的计算罢了\n1 ((beq \u0026amp;\u0026amp; zero) || (bne \u0026amp;\u0026amp; !zero)) ? br_pc : pc_D + 32\u0026#39;d8; 接下来，剩下的8个乘除模块指令，就要从零建起了。\n乘除模块 乘除模块共8条指令 mult, multu, div, divu, mfhi, mflo, mthi, mtlo\nMDALU模块 我们可以构建模块MDALU 接口如下所示：\n名称 位宽 方向 clk 1 I reset 1 I MDALUOp 4 I num_1 32 I num_2 32 I start_busy 1 O busy 1 O HI 32 O LO 32 O clk和reset的功能就不多说了，要清空所有寄存器 start_busy:得知指令为 mult,multu,div,divu，引发运算，阻塞与busy （在start_busy的时候就要为下一周期阻塞了，再不阻塞E级就要进来新指令了）\nMDALUOp:控制信号\n1 2 3 4 5 6 7 8 assign MDALUOp = mult ? `MULT : multu ? `MULTU : div ? `DIV : divu ? `DIVU : mfhi ? `MFHI : mflo ? `MFLO : mthi ? `MTHI : mtlo ? `MTLO : `NONE; busy：这个可以说是最重要的一个点。 在busy状态下，我们要进行阻塞，Pc、F_D级不动，D_E级清空，E级及以后顺延运算。 问题的关键在于： 如何控制busy时间？\n以乘法为例： 每个时钟上升沿，start_busy信号为1时，给cnt归0，给busy赋1，算出LO，HI要被赋的值（现在再不算，等会阻塞的时候E级都清空了） (由于非阻塞赋值，在下一时钟上升沿cnt = 0, busy = 1)\nbusy为1时，\n若cnt == 4，busy和cnt清零，并对regHI，regLO赋值 (由于非阻塞赋值，第五个时钟周期开始时cnt刚被赋值为4， 那么下一个时钟上升沿是busy和cnt都清零，regHI和regLO被赋值， assign语句的即时性使得HI与LO直接出值) 否则cnt++ 指令的控制信号 这八条指令除了MDALUOp以外，也有其对应的控制信号要处理。\nmult,multu,div,divu是完全同质的指令。 特点是读GRF，直接写HI,LO，不写GRF和DM 可以归纳其控制信号RFWr = DMWr = DMRd = 0; ImmSel = 0;运算数都是寄存器\nTuse_rs = Tuse_rt = 3\u0026rsquo;b1;\n乘除法的Tnew不必担心： 得出结果就直接塞到寄存器里了 新指令一旦进来，就说明我的regHI和regLO已经写好了 转发都不用，更别说阻塞了\n再说了，乘除法不差你这一点阻塞，本身阻塞的也够多了（）\nmfhi,mflo是一个访存指令。 要读HI,LO，写GRF 这考虑的就要多了。\n首先，它写GRF，就决定了它需要去转发： 指令的Tnew = 1,可进行M-\u0026gt;D,M-\u0026gt;E的转发。 我们当然可以直接把它加入ALUData_E_true(像当初pc+8那样)\n其次，写要写到哪：rd 那么WrSel要置1\n另外，写当然需要写使能：RFWr = 1\nmthi,mtlo要对HI和LO进行写 要读GRF 写HI,LO\n那么其实这和第一类指令很相似 不写GRF和DM，控制信号RFWr = DMWr = DMRd = 0; ImmSel = 0;运算数都是寄存器 特点是Tuse_rs = 3\u0026rsquo;b1; 但是不需要读GRF[rt]\n同样类似地，它的值也是即拿即写 不需要转发与阻塞\n指令在模块内的书写 前四条已经较详细地描述过了 但在实际书写上，还是存在一定问题： 1. 在阻塞之后，什么值都丢了，那么你就必须有自己预先存好的Op，预先存好的计算结果，才能使得你这个周期还能按着原来的指令的轨迹去走。 但是，op你应该怎么存？ 这至少需要一个时钟周期去存它，那么如果你只根据Op判断，你就已经丢失了一个时钟周期。不仅如此，对于一个周期就能完成的mf,ml指令而言，这更是荒唐。 因此，我目前的写法是不仅对Op写case语句，还对MDALUOp写case语句。 那么，Op的控制也应更加严格，即执行完语句后，应把Op置为`NONE。 （注意：default的情况不要对Op处理！因为default可能是还没来得及赋值的Op,这下好了，同一上升沿两次赋值）\n符号乘法要怎么写？ 鉴于曾经在这里WA过一发，我在此直接给出写法：\n1 {tempHI, tempLO} \u0026lt;= $signed(num_1) * $signed(num_2); 就这么简单。不要担心位宽不一致。它会自动扩展。\nmf指令是一个读HI，LO指令，而我们的HI与LO本就一直在输出。 只需要MDALUOp的控制信号管理一下ALUData_E_true的选择即可。\nmt指令为写HI，LO指令，直接在case语句里面写寄存器就行。 ！！这里要注意，我们写HI，LO寄存器其实是在下一时钟周期才完成的 因此有人会担心，如果下一条指令就要读HI，LO会不会出错误？ 答案是不会。因为我们的assign一直在输出，HI,LO被写之后拿出来的数肯定是对的。\n曾经又在这里WA过一发：mt指令读的都是rs!!!\n模块在顶层的书写 作为少有的要改动顶层模块的设计 首先要注意先前所提到的 mf指令涉及到的写寄存器与转发的问题，都需要靠ALUData_E_true来解决\n1 2 3 4 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : (MDALUOp_E == `MFHI) ? HI : (MDALUOp_E == `MFLO) ? LO : ALUData_E; 当然还有模块本身的接口及其信息传递\n另外要注意的就是阻塞： 阻塞实际上也就是多或上了两个信号start_busy和busy信号\n那么接下来的，就是大量指令引发的巨量测试。\n测试文档 单个指令的测试 对于新加入的指令本身，我们需要进行一次较为彻底的测试。\n一是功能本身的基础是否实现，二是一些特殊情况需要验证。\n首先是lh,lb,sh,sb指令： 侧重对符号扩展的测试\n对于add, sub, and, or, slt, sltu, lui, addi, andi, ori 要注意addi的符号扩展是否做到\n对于bne就正常测试成功or失败跳转即可\n对于乘除法模块则也要注意符号问题\n这一层次的测试基本上是用于debug的，因为只涉及自身功能，不涉及冒险，课下的弱测强度基本足够了。\n当然还是建议自行做足测试的。\n指令之间的冲突处理 利用思考题处的表格自行构造样例，再结合评测机进行测试。\n我决定写多个小型测试，对各种转发与阻塞的情况编写特别代码来检测结果。在此不便展示。\n思考题 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？\n因为乘除法部件的运算逻辑与读写数据都与ALU截然不同。 首先，乘除法的高强度阻塞与特别的时序逻辑决定了他不能和组合逻辑直接混用。\n乘除法模块中计算指令就不说了，mf指令是组合逻辑assign，mt指令是写寄存器的时序逻辑。这和原ALU是不太兼容的。\n其次，HI，LO寄存器也只有MDALU能用到，和ALU混用，就提高了内部耦合度，显得混乱。\n这么做，把计算分为ALU和MDALU，最后再进行选择，其实相当于是形成了一个更大的ALU，含有原ALU和MDALU。因此，单独的乘除法部件更好地做到了“高内聚，低耦合”。\n独立的HI,LO： 首先，HI,LO有其自身特殊性，不能被直接读，只能靠mf指令读。 其次，把HI，LO放在E区，与其他寄存器分离开来，能够实现即出即写，避免了读写冲突。\n真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。\n经过资料查阅，在真实的流水线CPU中，32位乘法是分部分计算的，一个周期可以32位对8位数的乘法（？），然后4个周期能算完。 除法据说是用试商法，一次试4位，8个周期做完除法。\n请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？\nstart可以引发busy，而start和busy都能导致阻塞。 通过计数器控制阻塞周期数，在最后一周期，清空busy,cnt，并完成寄存器赋值。 由于阻塞清空了E寄存器，我将MDALUOp和运算结果进行了及时存储。当然，在最后一周期，这些存储的信号也要清空。\n请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）\n清晰性： 提前将DMWr和addr共同作用的结果算出来，清晰明了地表达了究竟要写哪些字节，对每个字节执行独立的赋值。\n统一性： sw,sh,sb都能用同样的按字节赋值的逻辑来执行。 不过需要被写数据要进行一些预处理：\n1 2 3 4 5 assign m_data_wdata = (DMWr_M == `LW) ? MemData_M : (DMWr_M == `LH) ? {MemData_M[15:0], MemData_M[15:0]} : (DMWr_M == `LB) ? {MemData_M[7:0], MemData_M[7:0], MemData_M[7:0], MemData_M[7:0]} : 32\u0026#39;b0; 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？\n写入DM的确实只写了一个字节 但从DM获取的是一整个字，要经过后续处理\n执行lw和sw时当然还是按字读写更快 但是执行对半字与字节的操作时，按字节读写效率更高\n为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？\n抽象： 我对指令进行了归类，如设计文档所示。并按类地添加和处理指令 最显著的作用如DMRd,DMWr,ALUOp,MDALUOp等等，单个多位信号传入流水线寄存器，相较于多个单位信号是更方便的。\n规范： 对于同一类指令，可以对其先归为一类，再统一为控制信号赋值 （其实也没简单太多，比如addi这种符号扩展，还要单独写）\n帮助： 在译码和处理数据冲突的时候也就是在CTRL内，按类调整控制信号与T信号，省时省力\n在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？\n新的冲突只有数据冒险。处理方法也别无二致。\n阻塞： 我在修改CTRL的时候，已经为各个指令赋好了Tuse_rs,Tuse_rt,Tnew，阻塞正常进行\n转发：\n新添的所有指令中，需要的位点没有改变：V1_D,V2_D,num_1,num_2（此处忽略lh,lb.sh,sb） 新添的所有指令中，写寄存器的内容：大多都还是原来的路径，除了M级有新数据：即来自LO,HI的新数据。（要知道乘除运算指令本身是不写GRF的） 对于这个的处理前文也有提及：\n1 2 3 4 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : (MDALUOp_E == `MFHI) ? HI : (MDALUOp_E == `MFLO) ? LO : ALUData_E; 对于这个改动的测试样例：\n1 2 3 4 5 6 7 8 9 10 11 ... mult $s1, $s2 mfhi $t0 ## 写$t0 add $t1, $t0, $t0 ## 读$t0，M-\u0026gt;E需转发，写$t1 mtlo $t1 ## 读$t1，M-\u0026gt;E需转发 mflo $t2 ## 写$t2 add $t3 $t2 $t2 ## 读$t2，M-\u0026gt;E需转发，写$t3 mthi $t3 ## 读$t3，M-\u0026gt;E需转发 mfhi $t4 ## 写$t4 sw $t4 0($0) ## 读$t4，M-\u0026gt;E需转发 lw $t5 0($0) ## 写$t5 这个样例过多测试了M-\u0026gt;E转发，下面补充一个M-\u0026gt;D转发\n1 2 3 4 5 6 mtlo $t5 ## 读$t5 mflo $t6 ## 写$t6 label: or $t6 $t6 $0 ## 表示正在死循环 bne $0 $t6 label ## M-\u0026gt;D转发 nop 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。\n我采用了手动构造法。 通过建立策略矩阵，按照T的关系来进行构造 具体分类方式如下图所示：\n这两张图还需添加关于lui和mf指令的测试，单独对这两个指令构造测试也是可行的。\n","date":"2024-11-12T14:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA2/Der_Richter_hu1678884075292437805.jpg","permalink":"https://demiurge-zby.github.io/p/%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA2/","title":"流水线CPU搭建（2）"},{"content":" 说在前面 这周真的太忙了。 不说流水线和数竞这两块大骨头，硬控两小时的党课，硬控两小时的挑战杯志愿者，硬控一小时的组会，硬控五小时的毛概PPT\u0026hellip;\n虽说这周还买了曲包摘了星\n但是流水线CPU真难写。 读者可以看看我写设计文档心境的变化。\n（提交截止前2h突然发现bug。。5点半硬控到7点去上党课）\n为什么说这是流水线的（1）呢？ 因为目前还只有10条指令。流水线（2）是P6，30条指令的事了。\n那么，请君观之。\n设计文档 流水线的设计与单周期的区别主要是两点：\n流水线寄存器的插入 冒险的处理 这两点说起来轻轻松松，但实操起来实在繁杂。\n在漫无目的地发愣了很久之后，我决心要先写出一篇设计文档，把思路理清了再去书写。\n发愣的核心原因在于总感觉自己处理不好寄存器要放什么，谁应该在哪个区（浅显的思考当然不能处理好）\n有的时候更是连第一步没想好就忙着转发阻塞什么的\n哪怕后续转发的时候再优化，现在把需求理清，车间划好，才能想下一步迈进。\n流水线寄存器 要将原来的单周期分割为五个周期，具体是什么样呢\n首先，我想理清楚有哪些操作\n(我最不明白的就是回环：NPC，GRF)\nF pc出值给IM\nIM出指令\npc+4得更新到pc\n这是一个恶心的点，使得你现在就必须考虑延迟槽的问题\n所有不是pc+4的npc，都是经过跳转的\n所有要跳转的，都要用延迟槽\n所有用延迟槽的，都要先执行pc+4，因为跳转结果在第二周期才得出来（哪怕你提前得出来了你也得等延迟槽！！）\n所以跳转结果是在下一个周期才赋值，是一种特殊的赋值\n所以pc应当默认使用pc+4，除非有NPC算出的东西进来\n这个控制信号应当是任何跳转语句都能引发，我称之为not_pc_4\n这个信号作用于PC，所以还是称它为PCSel吧\nPCSel为1的条件就是所有跳转语句\n其中beq跳转失败时还是要用pc+4\n因此NPC不能直接把pc_4的这一个输出值删掉\n这个信号在什么时候产生呢？\n肯定已经到D阶段了\nbeq在F阶段，此时PCSel仍为0 （因为跳转语句不在延迟槽，这一句不是延迟槽，则上一句不是跳转，则PCSel为0）\nbeq在D阶段，延迟槽语句在F阶段 这时候PCSel为1\n因此下一个pc将是跳转的，没有问题！\nPCSel产生即使用，不经过流水线（虽然他其实能够在F阶段就拿出来，但是延迟槽使得你不能过早赋值，你还得等，反而要经过流水线）\n顺便谈到zero\nzero经过提前到D级，也是即拿即用，不需要经过流水线\npc，Instr都给 F_D\nF_D拿到指令\nF_D 存储PC和Instr（这太好了）\nD 好，接下来看这条指令在D阶段要干些什么\nD阶段最核心莫过于GRF\n但是其他内容也都同等重要\n首先是先前提到过的 NPC和CMP\n单独搞一个CMP出来据说是为了解决P6大量b语句\n这个阶段要给imm_16变成IMM_32,imm_16已经没用了吗？\n我想一想，应该是不会再用了吧？\n并不是！ALU里面怎么有个lui他还要用。哦他不需要。 lui只取32位数的后16位，再左移16位\n所以imm_16彻底无用。我要去删去他的_D标记啦！\n我刚刚又在想，为了可扩展性，要不要把他一直存着呢？我觉得还是存着吧。\n但我又想到，到时候用imm_16，直接从IMM_32里面取不就行了？所以我还是不存了。\nimm_26是j型指令，感觉存着也没用，毕竟得赶快给PC送过去呢！\n好的，那这个阶段把imm_16也解决掉了\n剩下最后一个，就是GRF了！\n读什么？读rs,rt呗还能读谁\n这个阶段又不写。\n所以rd也没什么用。\n要注意GRF的A3选择的时候是rd_W,rt_W之类的 害，到时候再写吧\n对！写的时候那个pc也得是pc_W\n关于W阶段啥东西都应该是W\n到时候再说！！！\nD_E 存储很多很多东西 还有用的控制信号（EXT，J，Jr当场使用了） 还有用的数据（imm_16和imm_26应该都没用了） 当然还有pc\nE 好嘞，该读的信息都读了，该处理的信息也处理了\n下面就是执行操作了\n关键的内容还是ALU\n而ALU的核心就是各个东西都是E\n（为什么这个模块异常的简单？）\nE_M 还是一个基本问题，后面需要什么 pc是当然的 后面有Mem取数和Write回写 需要Mem写的地址，写的内容，GRF写的地址，写的内容 还有他们的读写使能 还是多存点好，就把ALUOp删了吧\n别忘了传递ALUData信息\nM 整体和单周期也没有区别\nM_W 我的建议是别删\n没有什么理由。 就先别删吧\u0026hellip;\n添加MemReadData_M MemData_M和Mem_Addr_M也带上吧\nW 回到GRF\n该用W的都用上W即可\n意外地快。 不处理冒险的数据通路搭好了？？\n冒险处理 我自己也没想到已经走到了这一步。 这一基础性的工作就这样被我搁置了这么久。 其实，接下来才是核心。\n转发和阻塞！！！\n转发 首先要构建好转发的所有路径 转发的核心矛盾，是读了还没写的东西 （一定要注意0号寄存器！写进去了也还是0，因此不能转发）\n我在这里直接考虑所有路径\n指令 F D E M W add,sub 取指令 取rs,rt 算数 得到数据进行转发rd 写数rd ori,lui 取指令,扩展imm 取rs 算数 得到数据转发rt 写数rt lw 取指令，扩展imm 取base，rt 算数 寻址取数 得到数据转发rt，写数rt sw 取指令，扩展imm 取base，rt 算数 寻址存数 无 j 取指令，扩展imm 算出NPC延迟槽后用 无 无 无 jal 取指令，扩展imm 算出NPC延迟槽后用，算出PC_8 可转发（但没人需要） 可转发 可转发，写数$31 jr 取指令 读rs并给NPC 无 无 无 让我们分析一下根据这个表分析一下 Tuse:最晚使用时间： 例如我们add读寄存器值的时候可能数据还没出来，但是真正要用到的时候其实在ALU 因此最晚转发时间在E级。\n我在此分如下几类指令：\nR型读2求1型 rs与rt要读，正常转发 Tuse_rs = 1（ALU的时候有就行） Tuse_rt = 1（ALU的时候有就行） Tnew 初始（即相对于E）= 1 (M才能开转) RegAddr 现场算\nI型拿1读1求1型 rs 要读，正常转发 Tuse_rs = 1（ALU的时候有就行） Tuse_rt = inf imm正常传，传到了num_2,因此rt的值在E级要额外存为V2_E_Data\nTnew 初始 = 1 (M才能开转)\n读寄存器跳转型 说白了就是jr（） Tuse_rs = 0 !!! Tuse_rt = inf 所有跳转的特点都在于其必须在D级得出跳转结果。 而jr就必须从V1_D拿到完全正确的值 因此E-\u0026gt;D的转发是有益的 （但从E开始的转发需要是在D级就得出结果的指令（不经过ALU）） 符合条件的并不多。 我暂时采用阻塞。\n直接跳转型 j不必多说 Tuse_rs = inf Tuse_rt = inf\nRFWr = 0\n条件跳转型 beq。关键在于br和zero两个指令。 其中zero同样要保证在D级算对！必须拿到对的值。 拿不到？我也先采用阻塞。\nTuse_rs = 0 Tuse_rt = 0 RFWr = 0\nLink型 典例jal Tnew = 0 !!!!!(不过我还是把它当做Tnew = 1来用) Tuse_rs = inf Tuse_rt = inf\nE级就能用。因此E-\u0026gt;D这条转发路径是有益的。我目前先用了阻塞。 写$ra太慢了！必须转发！ 该怎么转？能在M和W转。（E也能转） 一定要注意：一旦选择转它，你要拿他去覆盖转的值！！\n1 2 wire [31:0] ALUData_E_true; assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : ALUData_E; 这个ALUData_E_true直接传进流水线E_M和M_W， 即如果本指令为Link型，你就只能读到这一个$31数！\n诶诶，如果一个Link指令，既要写$ra，又要写其他寄存器 呸呸呸想什么呢！一条指令最多写一个寄存器！！\n条件跳转Link型 最关键的便是不跳转，就不Link！ 比如beqal，其link信号应为beqal\u0026amp;\u0026amp;zero(传Link信号的时候就控制好)\nL型 rs rt 正常获取转发 Tuse_rs = 1 Tuse_rt = inf(看题意会不会旁敲侧击使用rt) imm正常扩展 ALU算的值会在M级被转发！！ 但是在W级正确的值还会被转发过去。 诶？我W级转发过去的数没有当时M级转过来的优先级高啊 要是连着两句lw,值不就错了吗？ 所以我所有的lw都进行了阻塞。 不过还是要注意，错误的值还是不要转发（？） 经过思考，哪怕你不转发，原来的值也是错的。。那就坚决阻塞。\nTnew = 2 最慢！！！（一直到M级取出来，W级才能用）\nS型 Tuse_rs = 1, 在E级需要算对数rs， Tuse_rt = 2，在M级需要有正确的寄存器值rt RFWr = 0 Tnew = 0，不对寄存器进行写\n转发路径共四条： M-\u0026gt;D 传ALUData_M(经过pc+4和ALUData的选择) RegAddr_M跟A1A2比 W-\u0026gt;D 传RegData(经过MemReadData_W和ALUData_W的选择) RegAdde_W跟A1A2比 M-\u0026gt;E 传ALUData_M(经过pc+4和ALUData的选择) RegAddr_M跟rs_E rt_E比 W-\u0026gt;E 传RegData(经过MemReadData_W和ALUData_W的选择) RegAddr_W跟rs_E rt_E比 为什么没有到M的转发？ ////因为M级使用即Tuse = 2,而Tnew没有大于2的（Tnew = 3即W级才产出数据。这显然是荒谬的） 这个言论本身才是荒谬的！！Tnew = 3 已经是阻塞的问题了！不是是否转发的判断！ W-\u0026gt;M 是必要的！！\n转发这个操作本身，最重要的就是做到时时刻刻转发。 1.能转则转，不能错过转发信息（若唯一转发信息为W级，此信息一旦错过，你将失去转发机会，从而导致数值错误） 2.能转则转，一旦有转发信息就要进行覆盖，保证获取到的一定是最新数据。 为什么没有E-\u0026gt;D的转发？ E-\u0026gt;D 即 Tnew = 0 且 Tuse = 0，满足需求只有jal（lui也可以。但是我已经把他塞进ALU了） 但是我还没写。 因此Tnew = 1，要阻塞。 阻塞 我们采用把阻塞控制在D阶段完成的方法。 Tuse:在D级的时候，读寄存器的最晚周期与D级的差 Tnew_X:X周期的指令要写的内容能够转发出去的最早周期与E级的差 （在周期A算出来，则可以在周期A+1转发）\n我们需要考虑D与E关系，D与M关系 为什么不考虑D与W关系？？ 因为Tnew_W一定为0了（谁家指令在W级还没算出来数（笑））\n对于两个阻塞的关系，我们采用暴力地或起来 一条通道可能不通就阻塞。\n阻塞只需满足:\n确实发生读写冲突且来不及转发（Tuse \u0026lt; Tnew） 我们先分为rs冲突与rt冲突\n1 assign stall = stall_rs || stall_rt; 然后以rs为例：\nstall_rs = stall_rs_DE || stall_rs_DM\n以stall_rs_DE为例：\n确实发生读写冲突： (rs_D（即A1）== RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026rsquo;b0) 且 \u0026amp;\u0026amp; 来不及转发： (Tuse_rs \u0026lt; Tnew_E)\n所以\n1 2 3 4 stall = ((A1 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_E)) || ((A1 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_M)) || ((A2 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_E)) || ((A2 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_M)); 接下来，只需对 Tuse 和 Tnew_X 下定义：\n功能还在CTRL中实现: 因为我要用指令来描绘 Tnew 和 Tuse_rs 和 Tuse_rt\n指令 Tnew Tuse_rs Tuse_rt add 1 1 1 sub 1 1 1 ori 1 1 5 lui 1(个人原因) 5 5 beq 无(0) 0 0 jr 无(0) 0 5 jal 1(不转发导致的) 5 5 lw 2 1 无(5) sw 无(0) 1 2 Tuse 直接生成 Tnew_X 初值生成，递减操作\n递减操作的实现： 放进流水线嘛，过个周期减一下\n测试文档 刚搭完流水线寄存器，出来一堆compile bug 或多或少的少加控制信号，打错字什么的。。 然后运行了充斥着nop的代码，没什么问题。\n然后就向Hazard进军了！\nHazard测试的编写很有针对性。 前提是你要针对好所有的代码情况，事先分析好Tnew,Tuse关系 才能模拟出所有的冒险。 所有的转发，所有的阻塞，都要到位。 共9^3种组合。\n思考题 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。\nbeq提前使得其Tuse降为0，这无疑提高了阻塞率。 当这条指令前面是Tnew = 1的add,sub,ori等等均阻塞\n用原来的方法，虽有可能损失更大，但是也存在很多无损失的情况。提前分支判断则是较为稳定的损失。\n举例：\n1 2 add $16 $16 $16 beq $16 $0 label 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？\n正因题意所说，因为延迟槽的存在，jal语句后的那条指令是已被执行的，跳转回来时当然要跨过延迟槽这句话\n我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？\n功能部件本就耗时，如果再加上转发逻辑，二者必定是顺序关系，导致时钟周期长度增长，频率上限降低，效率也就低了。 但是如果在下一周期，转发操作和下一周期的操作是独立并行的，不影响执行速度。\n我们为什么要使用 GPR 内部转发？该如何实现？\nGRF内部转发本质上是W到D的转发，只是W和D用了同一个部件 有同学使用了negedge的办法进行W，这样posedge读的时候就一定已经被新值写入。\n我采用了传统转发。无非转发的值是RegData_W,参与判断的是RegAddr_W罢了。\n我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？\n需求者严格意义上有很多，不过他们是可以合并的。 所有需要使用或传递的部件，都是需求者。 但是我们可以先进行转发，再把结果给需求者们。 总体来说，需求者可以是CMP的两个数，ALU的两个数，D_E和E_M流水线寄存器。\n需求者还有M级 sw时RD2的值！！！！！需要换上最新数据！！！\n供给者我们都安排到流水线寄存器的输出。 M级的数据可以是ALUData,Pc+8 W级的数据可以是MemReadData,ALUData,Pc+8\n前文也提到了，E到D的转发尚未考虑。\n因此，共有M-\u0026gt;D，M-\u0026gt;E，W-\u0026gt;D，W-\u0026gt;E，W-\u0026gt;M五种。 （以及E-\u0026gt;D）（6种）\n!!刚de出的bug!!!还有W-\u0026gt;M转发！！！！\n再总结一下所有被转发：\nRD1\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V1_D\u0026mdash;\u0026gt;V1_E\u0026ndash;ME,WE转发\u0026ndash;\u0026gt;num_1\u0026mdash;\u0026gt;运算\nRD2\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V2_D\u0026mdash;\u0026gt;V2_E\u0026ndash;ME,WE转发\u0026ndash;\u0026gt;V2_E_Data\u0026mdash;\u0026gt;V2_M_Data\u0026ndash;WM转发\u0026ndash;\u0026gt;MemData_M\u0026mdash;\u0026gt;被写入\nRD2\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V2_D\u0026mdash;\u0026gt;V2_E\u0026ndash;ME,WE转发、选择\u0026ndash;\u0026gt;num_2\u0026mdash;\u0026gt;运算\n总结一下所有转发：\nM级为ALUData,Pc+8经过选择变为ALUData_true的转发 W级为MemReadData,ALUData,Pc+8经过选择变为RegData的转发\n转发地址为RegAddr已各自计算\n在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。\n这一问题在前文已有谈论。 总结起来，关键还是处理好Tnew,Tuse,读谁，写谁这四个问题 （其中，读谁，写谁都是需要控制信号的） 以及最核心，最有不确定性的“处理”这一部分\n确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。\n我使用的是对控制信号找相关指令的方式。 先由opcode和funct得出结果，再得出指令；接下来由指令得到控制信号。 优势是简洁，不足是容易漏写，错写。 加指令时一定要分析好所有相关信号，再书写。\n","date":"2024-11-10T22:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA1/292fa3e8c7e86664cbaefef9ddc7893_hu11389104909499974286.jpg","permalink":"https://demiurge-zby.github.io/p/%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA1/","title":"流水线CPU搭建（1）"},{"content":"作业最终的架构设计 经过轮轮迭代，面向对象先导课程也终于走向了尾声。\n关于类 本次迭代任务中，共有24个类被创建：\n他们分别是：\nMainClass: 程序入口，实现数据读入操作和大量核心方法。 Adventurer: 核心操作对象，内含有关Bottle，Equipment，Frag，Employ类的相关容器 Bottle：内设三个子类，HpBottle，AtkBottle，DefBottle Equipment：内设三个子类，Axe，Blade，Sword Frag：表达碎片的相关属性与方法 Employ：表达雇佣关系相关属性与方法 Guard，Treasure及其Factory：秘境探险操作中的新对象 具体属性就不详细说了\n关于容器 在容器上的考虑，值得一提的便是CarriedEquipment。它使用了以name为索引的HashMap，这一方法十分契合题设要求。可惜的是，在处处以id为核心标识的情境，使用以name为索引的方法不可避免地要处理好在carry操作之外的重名问题。\n那便是deleteEquipment()方法在第三次迭代强测中带来的惨痛教训\n关于迭代 迭代式开发的课程，着实是令我耳目一新的。\n第一次迭代 OMG，it\u0026rsquo;s LLM! 从第一次迭代时拙劣地模仿IDEA的LLM，到现在理解较为成熟地模仿LLM，大家每个人的进步都是肉眼可见的。\n第二次迭代\n添加了carry指令。当时没有想太多，直接为装备添加了isCarried属性（谁能想到后面装备还能援助给别人呢（） deleteCommodity()让我开始考虑将Bottle和Equipment结合起来，但其差异仍将大于其共性。 第三次迭代 这次迭代是让我最印象深刻的一次迭代，痛失40分（苦笑 核心要点主要是： 容器重构，carry，frag，fight\n删掉了所有find函数，用上了高效简洁的HashMap carry方法重写，建立了专属容器以存放Carried的物品。关于carriedEquipment以name为索引的潜在问题前面已经提到了。 frag的处理。就忽略id属性这一问题，我认为是合理的。frag的最核心属性就应该是name和count，以同名frag作为一个对象基本单元，在获取数量，消耗数量等操作上都是合理的。不过把id忽略掉这种行为本身，对于整个项目来说，可能还是有一定隐患的。 fight较为简单。强测错因是getAtk()误写成getCe()。 第四次迭代 迭代任务确实一次比一次重\n雇佣关系：建立Employ类，对于一个雇佣关系对象本身管理它的各项属性。这种思想让我缓了很久，万物皆为对象！曾经室友写了一个Fight类，让我懵懂地理解了一下什么是过程对象，如今自己写的时候又更明白何为关系对象。把一场战斗（函数(函数其实也是关系，关系就是有序对)）当作一个对象，它有它的属性，有它的方法；把雇佣关系（有序偶对）作为对象，同样有自己的属性与方法。 递归攻击：倒是一个很容易克服的难点。 秘境探险：更多的是一种思想认知的改变，在具体实现上让我对接口有了新的认识。不同的类可以借助接口同一调用不同内容的方法，确实便利了很多 中测de了半天bug原来错在getComprehensiveCe()也是没谁了（）\n使用JUnit的心得体会 覆盖率是一项任务 起初，我确实没有意识到JUnit的功能。能在运行中构造样例运行出来的结果，为什么还要搞那么复杂去专门去测？我对各个方法进行了无意义的测试，完成了基础任务。\n覆盖率赋予每一行代码意义 自第三次迭代作业开始，加入了分支覆盖率的要求。在我开始思考覆盖率的意义之时，我方才意识到，单元测试之所以是单元测试，便在于它使得代码中各种细微的地方都能被顾及得到。同样，覆盖率也能够帮助我写出更完善的测试代码。\n单元测试，但不仅仅是单元 在单元测试中，我们不仅要编写对于单个方法的测试，更需要对较大的方法进行测试，在大方法中测试小方法相互作用关系的正确性。单元测试中的单元不仅是指最小单元，更是单元之间组合形成的层次化结构单元。\n测试数据构造需要技巧 无论何时，以debug为目的的测试终究是要找到bug。因此要尽力去构造bug相关的测试点，构造较极端的情况进行分析，而不是为了达到覆盖率要求而进行大量的无意义测试。\n学习OOpre的心得体会 以方法为核心的逻辑 在学习C语言的时候，我曾畅想，如果各项基本操作都能靠函数实现，而函数的实现也依靠其他函数，人脑只需负责顶层逻辑，那些条条框框的小方法被封装起来等着用该多好\u0026hellip;\n在OOpre的课程中可谓是函数方法用的最多的一集，有大量好用的被封装好的方法，我只负责对方法进行封装，构造新的方法，再调用方法\u0026hellip; 因此，在debug时，C语言和OOpre两门课带给我的感受是很不一样的。前面是对于方法具体实现细枝末节的深深考究，而OOpre的思路总是流畅贯通，哪里有问题它可以根据逻辑分析直接推理出漏洞\n以对象为主体的视角 这一点，是我在第四次迭代中深刻体悟到的，万物皆为对象。前文已有讲述。\n课程建议 希望可以像CO一样提前有一定的基础知识学习期，提供资料自学容器，子类，接口等内容的基础知识，解决课上刚学会的知识总是不能快速理解运用的问题。\n","date":"2024-11-01T13:30:00+08:00","image":"https://demiurge-zby.github.io/p/oopre%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/d477300c36f0221527b9816c97bed3b_hu13817389781556842652.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/","title":"oopre结课总结"},{"content":" 设计文档 前情提要 本次搭建需要实现的指令有\nadd,sum,ori,lui sw,lw beq jal,jr nop 在此基础之上，本人额外添加了lh,lb,sh,sb,j指令。\nverilog的基本构建思路源始于logisim，Tunnel化的logisim电路为verilog代码的编写提供了很大的便利和可扩展性。\nverilog的编写仍然从数据通路基础部件和控制器两方面来书写，不过额外的是，在mips.v中应当实现所有的基础接线操作。\n或者说，mips.v是最独特的一环。\n一切源代码仅供参考，千万不要抄袭！！\n数据通路的构建 PC PC作为CPU中的时序电路核心器件，其功能实现也较为简单，只有同步复位操作和npc赋值操作。\n直接由logisim文件分析PC模块的接口\n名称 位宽 方向 npc 32 I clk 1 I reset 1 I pc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 `default_nettype none module PC( input wire [31:0] npc, input wire clk, input wire reset, output wire [31:0] pc ); reg [31:0] PCreg; always @(posedge clk) begin if (reset) begin PCreg \u0026lt;= 32\u0026#39;h00003000; end else begin PCreg \u0026lt;= npc; end end assign pc = PCreg; endmodule NPC NPC与P3不同，加入了jal，jr指令，使得其增加了两种全新跳转方式：\n26位立即数经位拼接得到直接地址 32为GRF数据得到直接地址 再加上原来的pc+4与pc+4+sign_ext(imm)\n共有四种跳转逻辑，需要较多的控制信号\nbr 和 zero 控制 相对寻址跳转 j 控制imm_26绝对寻址跳转\njr 控制$ra绝对寻址跳转\n接口信息如下：\n名称 位宽 方向 pc 32 I imm_16 16 I imm_26 26 I reg_ra 32 I br 1 I zero 1 I j 1 I jr 1 I pc_4 32 O npc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 `default_nettype none module NPC( input wire br, input wire zero, input wire [15:0] imm_16, input wire [25:0] imm_26, input wire [31:0] pc, input wire [31:0] reg_ra, input wire j, input wire jr, output wire [31:0] pc_4, output wire [31:0] npc ); wire [31:0] j_pc; wire [31:0] br_pc; assign pc_4 = pc + 32\u0026#39;d4; assign j_pc = {pc[31:28],imm_26,{2{1\u0026#39;b0}}}; assign br_pc = pc_4 + {{15{imm_16[15]}},imm_16[14:0],{2{1\u0026#39;b0}}}; assign npc = (jr) ? reg_ra : (j) ? j_pc : (br \u0026amp;\u0026amp; zero) ? br_pc : pc_4; endmodule IM IM作为需要读取指令的单位，需要调用readmemh\n为了保证读取的正确顺序，定义寄存器堆时使用[0:4095]\n也可以添加参数控制readmemh读取到的起始位置与终止位置\n由于该指令寄存器堆应当存储4096*32bit\n然而起始位置却是0x00003000 因此可以先对pc减去0x00003000\n再取[13:2]作为指令寄存器堆的读取地址\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I Instruction 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 `default_nettype none module IM( input wire [31:0] pc, input wire reset, input wire clk, output wire [31:0] Instruction ); wire [31:0] address; reg [31:0] InstrMemory [0:4095]; always @(posedge clk) begin if(reset) begin $readmemh(\u0026#34;code.txt\u0026#34;, InstrMemory); end end assign address = pc - 32\u0026#39;h00003000; assign Instruction = InstrMemory[address[13:2]]; endmodule EXT 注意位拼接操作的写法！！不能少打大括号\n位拼接“0”时，一定要控制有多少个0\n例如16个“0”,应使用{16{1\u0026rsquo;b0}}或{16\u0026rsquo;b0}\n名称 位宽 方向 EXTOp 1 I imm_16 16 I IMM_32 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `default_nettype none module EXT( input wire EXTOp, input wire [15:0] imm_16, output wire [31:0] IMM_32 ); wire [31:0] signed_IMM; wire [31:0] unsigned_IMM; assign signed_IMM = {{16{imm_16[15]}},imm_16}; assign unsigned_IMM = {{16{1\u0026#39;b0}},imm_16}; assign IMM_32 = EXTOp ? signed_IMM : unsigned_IMM; endmodule GRF GRF的最特殊性在于其0号寄存器\n值不能被改变 始终值为0 在此有两种处理方案\n初始时为所有寄存器赋0\n之后不对0号寄存器进行写入 读0号寄存器时始终输出0 由于个人偏好，希望各个寄存器中的值保持正确，本人采用了第一种写法\n根据题目要求，需要输出寄存器被写时的各项参数，需要将pc传入其中\n接口如下所示：\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I WE 1 I A1 5 I A2 5 I A3 5 I WD 32 I RD1 32 O RD2 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 `default_nettype none module GRF( input wire [31:0] pc, input wire [4:0] A1, input wire [4:0] A2, input wire [4:0] A3, input wire [31:0] WD, input wire reset, input wire clk, input wire WE, output wire [31:0] RD1, output wire [31:0] RD2 ); reg [31:0] grf [31:0]; integer i; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 32;i = i + 1) begin grf[i] \u0026lt;= 32\u0026#39;b0; end end else begin if(WE \u0026amp;\u0026amp; A3) begin grf[A3] \u0026lt;= WD; $display(\u0026#34;@%h: $%d \u0026lt;= %h\u0026#34;, pc, A3, WD); end end end assign RD1 = grf[A1]; assign RD2 = grf[A2]; endmodule ALU 实现基本与logisim同理，但是操作更为简单\n注意使用`define以增强代码可读性\n名称 位宽 方向 ALUOp 2 I num_1 32 I num_2 32 I zero 1 O out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 `default_nettype none `define ADD 2\u0026#39;b00 `define SUB 2\u0026#39;b01 `define ORI 2\u0026#39;b10 `define LUI 2\u0026#39;b11 module ALU( input wire [1:0] ALUOp, input wire [31:0] num_1, input wire [31:0] num_2, output wire zero, output wire [31:0] out ); wire [31:0] add; wire [31:0] sub; wire [31:0] ori; wire [31:0] lui; assign add = num_1 + num_2; assign sub = num_1 - num_2; assign ori = num_1 | num_2; assign lui = {num_2[15:0],{16{1\u0026#39;b0}}}; assign zero = (num_1 == num_2) ? 1\u0026#39;b1 : 1\u0026#39;b0; assign out = (ALUOp == `ADD) ? add : (ALUOp == `SUB) ? sub : (ALUOp == `ORI) ? ori : lui; endmodule DM 仅对于lw和sw而言，DM本应是极为简单的。\n但是正因为sh,sb的特殊性，我尝试了对其功能的描述\nsh,sb指令的核心问题，在于我们不能直接做到针对一个字部分内容的修改\n因为我们的寄存器都是以32bit为单位的 因此我们要先把它所在寄存器的值取出来，进行位拼接操作得到该寄存器应存入的新数，再存入DM之中\n由于添加了指令，我的WE与RE信号都进行了调整\n控制信号取值 含义 00 以w为单位 01 以h为单位 10 以b为单位 11 不予使能 同样地，为了输出中间参数，pc需要被引入。\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 我还添加了word,half,by_te等中间变量，便于我后续的描述\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 `default_nettype none `define SW 2\u0026#39;b00 `define SH 2\u0026#39;b01 `define SB 2\u0026#39;b10 `define LW 2\u0026#39;b00 `define LH 2\u0026#39;b01 `define LB 2\u0026#39;b10 module DM( input wire [31:0] pc, input wire [31:0] data, input wire [31:0] addr, input wire [1:0] WE, input wire [1:0] RE, input wire clk, input wire reset, output wire [31:0] out ); reg [31:0] DataMemory [0:3071]; integer i; wire [11:0] word; wire half; wire [1:0] by_te; assign word = addr[13:2]; assign by_te = addr[1:0]; assign half = addr[1]; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 3072; i = i + 1) begin DataMemory[i] \u0026lt;= 32\u0026#39;b0; end end else begin case (WE) `SW: begin DataMemory[word] \u0026lt;= data; $display(\u0026#34;@%h: *%h \u0026lt;= %h\u0026#34;, pc, addr, data); end `SH: begin case (half) 1\u0026#39;b1: begin DataMemory[word] \u0026lt;= {data[15:0], DataMemory[word][15:0]}; end 1\u0026#39;b0: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[15:0]}; end default: begin end endcase end `SB: begin case (by_te) 2\u0026#39;b11: begin DataMemory[word] \u0026lt;= {data[7:0], DataMemory[word][23:0]}; end 2\u0026#39;b10: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:24], data[7:0], DataMemory[word][15:0]}; end 2\u0026#39;b01: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[7:0], DataMemory[word][7:0]}; end 2\u0026#39;b00: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:8], data[7:0]}; end default: begin end endcase end default: begin end endcase end end assign out = (RE == `LW) ? DataMemory[word] : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b1) ? {{16{DataMemory[word][31]}},DataMemory[word][31:16]} : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b0) ? {{16{DataMemory[word][15]}}, DataMemory[word][15:0]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b11) ? {{24{DataMemory[word][31]}}, DataMemory[word][31:24]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b10) ? {{24{DataMemory[word][23]}}, DataMemory[word][23:16]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b01) ? {{24{DataMemory[word][15]}}, DataMemory[word][15:8]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b00) ? {{24{DataMemory[word][7]}}, DataMemory[word][7:0]} : 32\u0026#39;b0; endmodule 控制器的编写 在搭建数据通路的过程中，控制信号的要求也已经浮出水面。\n关键还是由IM到指令，由指令到控制信号的过程\n不过加入了其他操作，使得DMWr,DMRd发生了一定的改变 以及额外添加的Link,J,Jr等控制信号\n相较于P3的BSel,此处本人将其更名为ImmSel,强调其解决的是立即数与寄存器谁参与ALU运算的问题\n名称 位宽 方向 opcode 6 I funct 6 I Br 1 O EXTOp 1 O RFWr 1 O DMWr 2 O DMRd 2 O ALUOp 2 O WrSel 1 O WdSel 1 O ImmSel 1 O Link 1 O J 1 O Jr 1 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 `default_nettype none module CTRL( input wire [5:0] opcode, input wire [5:0] funct, output wire Br, output wire EXTOp, output wire RFWr, output wire [1:0] DMWr, output wire [1:0] DMRd, output wire [1:0] ALUOp, output wire WrSel, output wire WdSel, output wire ImmSel, output wire Link, output wire J, output wire Jr ); wire add; wire sub; wire ori; wire lui; wire sw; wire sh; wire sb; wire lw; wire lh; wire lb; wire beq; wire j; wire jal; wire jr; wire R; assign R = (opcode == 6\u0026#39;b000000); assign add = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100000); assign sub = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100010); assign jr = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b001000); assign j = (opcode == 6\u0026#39;b000010); assign jal = (opcode == 6\u0026#39;b000011); assign ori = (opcode == 6\u0026#39;b001101); assign lui = (opcode == 6\u0026#39;b001111); assign sw = (opcode == 6\u0026#39;b101011); assign sh = (opcode == 6\u0026#39;b101001); assign sb = (opcode == 6\u0026#39;b101000); assign lw = (opcode == 6\u0026#39;b100011); assign lh = (opcode == 6\u0026#39;b100001); assign lb = (opcode == 6\u0026#39;b100000); assign beq = (opcode == 6\u0026#39;b000100); assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign ImmSel = ori || lui || sw || sh || sb || lw || lh || lb; assign EXTOp = sw || sh || sb || lw || lh || lb; assign ALUOp = sub ? 2\u0026#39;b01 : ori ? 2\u0026#39;b10 : lui ? 2\u0026#39;b11 : 2\u0026#39;b00; assign RFWr = add || sub || ori || lui || lw || lb || lh || jal; assign DMRd = lw ? 2\u0026#39;b00 : lh ? 2\u0026#39;b01 : lb ? 2\u0026#39;b10 : 2\u0026#39;b11; assign DMWr = sw ? 2\u0026#39;b00 : sh ? 2\u0026#39;b01 : sb ? 2\u0026#39;b10 : 2\u0026#39;b11; endmodule mips.v 前面说了那么多，其实都是相对独立的结构 那么接下来，才是verilog描述的独特之处 才能更深刻地展示verilog的抽象功能\n接口十分简单，毕竟真正来自外部的信号只有clk和reset\n名称 位宽 方向 clk 1 I reset 1 I 1 2 3 4 5 `default_nettype none module mips( input wire clk, input wire reset ); 接线逻辑 在我书写这一板块的过程中，我曾选用了将所有的wire先定义好，再全部统一赋值，再逐个接接口的方法\n结果这样导致的问题（或者说我曾经出现的bug） 就是你不能确定你需要的信号都得到了定义与赋值\n因此，我秉承了P3的基本思路，对各个部件的外部接线进行分析。\n分析方法：\n先定义所有需要的输出信号 输入信号分为 直接与其他某部件的输出信号直接相连 由其他部件的输出信号相互作用（计算or选择）得到 为这些相互作用进行assign处理 基础信号 名义上如此，其实这是在模拟我没有模块化的Splitter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 基础信号定义 wire [5:0] opcode; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [4:0] shamt; wire [5:0] funct; assign opcode = Instr[31:26]; assign rs = Instr[25:21]; assign rt = Instr[20:16]; assign rd = Instr[15:11]; assign shamt = Instr[10:6]; assign funct = Instr[5:0]; wire [15:0] imm_16; wire [25:0] imm_26; assign imm_16 = Instr[15:0]; assign imm_26 = Instr[25:0]; CTRL 定义大量控制信号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //控制信号定义 wire Br; wire EXTOp; wire RegWrite; wire [1:0] DMWr; wire [1:0] DMRd; wire [1:0] ALUOp; wire WrSel; wire WdSel; wire ImmSel; wire Link; wire J; wire Jr; CTRL Ctrl( .opcode(opcode), .funct(funct), .Br(Br), .EXTOp(EXTOp), .RFWr(RegWrite), .DMWr(DMWr), .DMRd(DMRd), .ALUOp(ALUOp), .WrSel(WrSel), .WdSel(WdSel), .ImmSel(ImmSel), .Link(Link), .J(J), .Jr(Jr) ); PC 定义输出信号pc\n1 2 3 4 5 6 7 8 // PC 输出信号 wire [31:0] pc; PC Pc( .npc(npc), .clk(clk), .reset(reset), .pc(pc) ); IM 定义输出信号Instr\n1 2 3 4 5 6 7 8 9 10 // IM输出信号 wire [31:0] Instr; IM Im( .pc(pc), .Instruction(Instr), .clk(clk), .reset(reset) ); EXT 定义输出信号IMM_32\n1 2 3 4 5 6 7 8 // EXT输出信号 wire [31:0] IMM_32; EXT Ext( .EXTOp(EXTOp), .imm_16(imm_16), .IMM_32(IMM_32) ); NPC 定义输出信号npc和pc_4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // NPC输出信号 wire [31:0] npc; wire [31:0] pc_4; NPC Npc( .br(Br), .zero(zero), .imm_16(imm_16), .imm_26(imm_26), .pc(pc), .reg_ra(RD1), .j(J), .jr(Jr), .pc_4(pc_4), .npc(npc) ); GRF 定义输出信号RD1,RD2 定义输入信号，并给出其assign语句实现赋值 要知道，输入信号一定要从其他部件的输出信号或者外部的clk 与reset中得到 如果盲目定义输入信号，却不予有意义的赋值，就会产生xxxzzz等问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // GRF 输入信号·中间变量 wire [31:0] LinkPC; wire [4:0] A1; wire [4:0] A2; wire [4:0] RegAddr; wire [31:0] RegData; // GRF 中间变量的赋值 assign LinkPC = pc_4; assign A1 = rs; assign A2 = rt; assign RegAddr = Link ? 5\u0026#39;b11111 : WrSel ? rd : rt; assign RegData = Link ? LinkPC : WdSel ? MemReadData : ALUData; // GRF 输出信号 wire [31:0] RD1; wire [31:0] RD2; GRF Grf( .clk(clk), .reset(reset), .WE(RegWrite), .pc(pc), .A1(A1), .A2(A2), .A3(RegAddr), .WD(RegData), .RD1(RD1), .RD2(RD2) ); ALU 输出信号zero和ALUData\n定义输入信号num_1，num_2并给出assign\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ALU 输入信号·中间变量 wire [31:0] num_1; wire [31:0] num_2; // ALU 中间变量的赋值 assign num_1 = RD1; assign num_2 = ImmSel ? IMM_32 : RD2; // ALU 输出信号 wire zero; wire [31:0] ALUData; ALU Alu( .ALUOp(ALUOp), .num_1(num_1), .num_2(num_2), .zero(zero), .out(ALUData) ); DM 这两个输入变量的赋值是否没有意义？\nMemAddr一定是ALUData?\nMemData一定是RD2?\n可能确实如此。 但是这样的命名使得整体逻辑更为清晰，也增强了可扩展性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // DM 输入信号·中间变量 wire [31:0] MemAddr; wire [31:0] MemData; // DM 中间变量的赋值 assign MemAddr = ALUData; assign MemData = RD2; // DM 输出信号 wire [31:0] MemReadData; DM Dm( .pc(pc), .data(MemData), .addr(MemAddr), .WE(DMWr), .RE(DMRd), .clk(clk), .reset(reset), .out(MemReadData) ); endmodule 测试文档 我仍然采用了对拍的方法，并自行构造了一定数据。\n对于新增指令，我着重加强了对jr,jal的测试\n以下是一组测试数据，重点观察$ra取值的改变是否正常\n1 2 3 4 5 6 7 8 9 0c000c06 // jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f301c //ori $ra, $0, 0x0000301c //label: 03e00008 //jr $ra 03fff820 //add $ra, $ra, $ra 可知$ra会在pc+4和0不断跳转\n直到变为0x0000301c后跳转到add语句变为0x00006038\n下面是我的输出结果，与MIPS结果一致\n1 2 3 4 5 6 7 @00003000: $31 \u0026lt;= 00003004 @00003004: $31 \u0026lt;= 00000000 @00003008: $31 \u0026lt;= 0000300c @0000300c: $31 \u0026lt;= 00000000 @00003010: $31 \u0026lt;= 00003014 @00003014: $31 \u0026lt;= 0000301c @0000301c: $31 \u0026lt;= 00006038 思考题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ?\naddr信号来自于ALU的计算，即GRF[base]+sign_ext(offset) 其中addr[11:2]意为取ALU计算结果从第2位开始的12位数字作为address。 其原因在于对于lw指令，第0位和第1位均为0，自第2位起开始计数才是以32bit为单位，才能与DM寄存器堆的寄存器编号相对应。\n思考两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。\n控制信号每种取值所对应的指令： 举例：\n1 2 3 4 5 6 7 assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign EXTOp = sw || sh || sb || lw || lh || lb; 每条指令对应的控制信号取值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 always@(*) begin case (Operation) `ADD : begin Br = 1\u0026#39;b0; Jr = 1\u0026#39;b0; Link = 1\u0026#39;b0; J = 1\u0026#39;b0; WrSel = 1\u0026#39;b1; ... end ... default : begin end end 分析优劣： 由指令确定其控制信号： 优点：考虑全面，不会有漏掉的指令，对每个指令也不会有漏掉的控制信号 上机新增指令时直接对其分析，一个也不会漏 缺点：代码重复冗长 产生新的控制信号时还需要对每个指令都加句话\n对控制信号归纳其生效指令： 优点：本质上是上一种方法的总结归纳，代码量少 缺点：自行归纳时某些控制信号可能会忘记考虑一些指令\nPS：解决方法：对新指令在演草纸上进行所有控制信号枚举，之后再进行归纳，用于代码书写\n在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。\n同步复位：clk优先（还必须得是上升沿） 异步复位：reset优先\nC 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。\n1 2 if temp32 ≠ temp31 then SignalException(IntegerOverflow) 这是add和addu、addi和addiu的唯一区别 u的本意即为不考虑输出 那在忽略输出的前提下自然就等价了。\n","date":"2024-10-31T14:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/292fa3e8c7e86664cbaefef9ddc7893_hu9110516496620476980.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/","title":"单周期CPU的verilog搭建"},{"content":"序列输入之数据特征分析 数据类型 不作介绍 关系 顺序关系 依次赋值 层次关系（赋值的所属对象） 1 2 3 4 5 6 7 8 Scanner scanner = new Scanner(System.in); int i; int n = scanner.nextInt(); for(i = 0; i \u0026lt; n; i++){ id = scanner.nextInt(); name = scanner.next();// id 与 name之间为顺序关系 // 不同组之间形成不同层次 } 结构 硬编码式的解析处理 较为简单，确定的输入方式 缺点：兼容性灵活性差 使用正则表达式的解析处理 可对应一个有穷自动机解析 默认使用贪婪匹配\n\u0026ldquo;.\u0026rdquo; 任意\n\u0026ldquo;*\u0026rdquo; 同一项内容任意项\n\u0026ldquo;+\u0026rdquo; 同一内容一项或多项\n\u0026ldquo;?\u0026rdquo; 同一内容零项或一项\n非贪婪匹配\n```java Pattern = new Pattern.compile(\u0026quot;(\\\\w+?)((good)*)\u0026quot;); // 添加 \\w+? 实现非贪婪 // 注意 \\\\ 编译问题 ``` 弊端：可读性差，技巧性高\n递归下降式解析处理 递归 借助递归进行解析 下降 从顶层到底层 按层解析 文法 终结符 取值不可变的符号，单个字符层级上的元素 非终结符 取值可变，以\u0026lt;\u0026gt;表示 定义规则 L -\u0026gt; R\n定义非终结符的取值方式\n1 2 3 4 5 \u0026lt;Var\u0026gt; -\u0026gt; \u0026lt;digit\u0026gt; | \u0026lt;Const\u0026gt; \u0026lt;Var\u0026gt; //递归下降 无限循环 \u0026lt;Const\u0026gt; -\u0026gt; \u0026lt;op\u0026gt; | \u0026lt;digit\u0026gt; \u0026lt;op\u0026gt; \u0026lt;digit\u0026gt; -\u0026gt; \u0026#39;0\u0026#39;|\u0026#39;1\u0026#39;|\u0026#39;2\u0026#39;|\u0026#39;3\u0026#39;|\u0026#39;4\u0026#39;|\u0026#39;5\u0026#39;|\u0026#39;6\u0026#39;|\u0026#39;7\u0026#39;|\u0026#39;8\u0026#39;|\u0026#39;9\u0026#39; \u0026lt;op\u0026gt; -\u0026gt; \u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;|\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39; // \u0026#39;+\u0026#39;为终结符，\u0026lt;op\u0026gt;,\u0026lt;Const\u0026gt;为非终结符 词法分析：定义Token 1 2 3 4 5 public class Token{ private String name; private Type type; // ... } //实现了一种抽象 语法分析：建立抽象语法树 根据文法所定义的关系\n1 2 3 4 5 public class Var{ private Arraylist\u0026lt;digit\u0026gt;; private Arraylist\u0026lt;op\u0026gt;; // ... } // 在表达树的方面降了一层 由表达式到项，由项到因子\n每一个非终结符都对应一棵局部语法树\n","date":"2024-10-24T15:30:00+08:00","image":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/15c277c39924c01bcd89e8f7b84de46_hu6067831623915793491.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/","title":"oopre课堂随笔-序列输入"},{"content":" 设计文档 Key Point: 数据通路，控制器及其连接\n要实现的核心指令介绍 add,sub,lui,ori,lw,sw,beq,nop\n数据通路的建立 名称 功能 简写 程序计数器 输出当前指令所在地址 PC 下指令地址 计算下一指令所在地址并传递给PC NPC 寄存器堆 32 个 32 位寄存器 GRF 指令存储器 存储所有的指令 IM 数据存储器 充当内存存储数据 DM 扩展单元 进行位扩展运算 EXT 算术逻辑单元 进行各项基本运算 ALU 下面先对各数据通路进行分析，并在此过程中得到对控制器的需求\n(在每个数据通路中都只考虑自己需要什么！\n输出的东西如何被使用是其他数据通路考虑的事情！！)\nPC 一个 32 位寄存器即可\n输出引脚：输出当前指令所在地址，提供给IM用于取指令\n输入引脚：由NPC算出的下一条指令地址\n作为整个设备中最核心的时序逻辑，在PC层面其本质应为Moore机\n在下一周期上升沿才可输出下一PC\n在输出PC以后，其他数据通路都基本呈现组合逻辑的形态，即时性进行输出内容的改变，即Mealy机\n（ROM和GRF的写入操作还是要等下一上升沿的，但是关于其写入的各项信息都是即时性得到的）\n当然，最后输出PC值的时候要再加上 3000\n若用PC初始化3000的方法，在复位后PC还是会输出 0\nNPC 下一指令的地址可能是PC+4\n对于beq跳转 也可能是PC+4+sign_ext(imm_16 || 00)\n对于j, jal跳转 还可能是PC[31:28] || imm_26 || 00\n输入引脚：输入当前PC值，imm_16, imm_26\n选择信号：br, zero, j\n这里区分br和zero是有原因的。\n详见zero产出地：ALU\n输出引脚：下一条指令PC值\n！！经后续分析，对于XXXAndLink指令，PC+4是被需要的，那就直接从NPC输出\nNPC外部的连接也比较直白\n具体分析：\n控制信号的使用：\n只有br和zero同时为1时才是成功beq跳转 鉴别出j，jal等才使用imm_26直接地址跳转 Tips: 由于jal指令为本人后续添加，因此选择了新增了MUX而不是改变原MUX\n计算过程实现：简单的加法，移位，位扩展，位拼接运算\n要注意位扩展一定是sign_ext，因此完全可以直接使用bit_sign_extender\nIM 采用了4096*32bit的ROM 地址长度选项只需12位\n！！ROM的地址以字为单位，因此PC要右移2位才能传给ROM\n右移之后还需bit_extender到12位\n（一定要先右移再extend，因为实质上就是取PC[13:2]）\n其余的没什么内容了\nSplitter 把这个东西单独拿出来写只是图个方便（）\nSplitter内部的构造就只是一些小splitter\nEXT EXT也是一个相对好说的部件\n根据EXTOp进行不同形式的位扩展\n（缺点（？）是只能用于16bit -\u0026gt; 32bit）\nEXTOp 含义 0 无符号扩展 1 符号扩展 EXTOp具体怎么得到就是Ctrl要考虑的了\n外部构造：\n内部结构：\n好的我刚刚意识到bit_extender本来就可以输入EXTOp\n但是我的EXT更好看（？）那就不改了\nGRF GRF相对来说就复杂多了\n内部结构在P0课下已经搭好了，但其正确性仍需后续测试\n在此仅略加展示：\n而其外部结构也大有文章\n指令 使用数据 add,sub 读rs,rt写ALU到rd ori 读rs写ALU到rt lui 写ALU到rt lw 读rs（即base）求ALU写MemReadData到rt sw 读rs（即base）求ALU但不写Grf beq 读rs,rd求ALU（做减法判zero）但不写Grf jal 不读但写PC+4到$31 因此构造相应的控制信号与多路选择器即可\nWrsel 含义 0 写到rt 1 写到rd Wdsel 含义 0 写ALU的结果 1 写MemReadData 后续添加的jal指令我又使用了控制信号Link\nLink 含义 0 按上述两个选择器行事 1 写PC+4到$31 当然，除此之外还有最重要的写使能信号\n整体外部结构如下图所示：\nALU 首先明确ALU要解决的问题：\n加法，减法，或，左移16位共4种运算\n显然ALUOp需要4种，即需要两位信号\nALUOp 使用指令 00 add，加法 01 sub，beq，减法 10 ori，或运算 11 lui，左移16位 不过，我并没有直接分四种器件进行操作\n采用了gxp老师课上提到的方法：\n加法和减法可使用同一加法器！！\na - b = a + ~b + 1\n而两个数相加再加1正是加法器已经提供的功能！\n最上方的接口即为进位接口\n！但是复用器件的代价就是更多的选择信号\n减法不仅仅要选择进位信号，还要选择参与运算的数\n对于整个ALU还需要区分进行了什么运算\n我们分为如下三个\n使用指令 M1 M1含义 Cin Cin含义 M2 M2含义 加法 0 使用b 0 进位为0 00 加减 减法 1 使用~b 1 进位为1 00 加减 或运算 X X X X 01 或运算 左移16位 X X X X 10 左移 如何根据ALUOp写出这些控制信号也一目了然：\n只需把上面两个表合起来，让ALUOp直接对应控制信号\n用Combinational Analysis给我们写出来就行了\n最终内部结构如下：\n在此解释前文NPC中zero与br都需存在的原因：\nbeq也是对rs,rt的值做减法，但关键在于结果值为0时输出zero信号为1\n因此zero信号也是会被sub甚至add干扰的\n所以在zero==1时必须有br==1才有效\n另一方向显然，br==1时判跳转有效当然离不开zero==1的判定\n关于其外部连接，关键只是两个控制信号：\n我们把GRF处使用的表格稍有侧重点地修改\n指令 使用数据 add,sub rs,rt算ALU（加减） ori rs，imm算ALU（或运算） lui imm算ALU（移位） lw,sw rs，imm算ALU（加法） beq rs,rd算ALU（做减法判zero） 将rs替换成RD1，将rt,rd按照对应法则替换到RD2\n可得到更清晰的表格\n指令 使用数据 add,sub RD1,RD2算ALU（加减） ori RD1，imm算ALU（或运算） lui imm算ALU（移位） lw,sw RD1，imm算ALU（加法） beq RD1,RD2算ALU（做减法判zero） 即可发现控制信号除了ALUOp之外，还有操作数2的选择\n操作数2可选择RD2或imm\n因此构造相应的控制信号与多路选择器即可\nBsel 含义 0 RD2 1 imm 这里的imm都是imm_16经过EXT的结果\n事已至此，可以顺便EXTOp也考虑清楚\n准确来说，只有ori需要无符号（EXTOp == 0）\nEXTOp 指令 0 ori 1 lw,sw X 其他 beq的sign_ext已经在NPC里面确认了\nEXTOp对于beq指令没有意义\n外部连接如下图所示：\nDM 我们采用了3072*32bit的RAM 地址长度选项只需9位\nDM和GRF逻辑类似\n但是由于我们直接使用RAM\n在一些内容的表达上需要按照RAM行事\nRAM 应使用双端口模式，即设置 RAM 的 Data Interface 属性为 Separate load and store ports RAM的ld也需要特别激活，因此需要一个lw信号来控制它 str信号就是普通的写使能信号 clr信号为异步复位信号 和ROM类似，RAM的地址也以字为单位，因此PC要右移2位才能传入 右移之后还需bit_extender到9位 （一定要先右移再extend，因为实质上就是取PC[10:2]）\nDM的A接口是地址，由ALU算出\n要存入的信息则是GRF从rt读出来的RD2\n连接比较简单\n控制器的搭建 在数据通路的苦苦搭建之中，其实控制信号已经都有了自己的定义\n我们发现，这些定义一般都依赖于指令\n那么控制器就可以建起这个桥梁：\n通过opcode和funct得到指令\n再由指令得出控制信号\n由外部信号到指令 得到指令的过程我使用了比较器，因此构建过程非常简单\n由指令到控制信号 由指令到控制信号那可就更简单了\n除了 ALUOp（）\n我们使用OR阵列\n哪条指令需要这个信号，我们就给它或到这个控制信号上\n这种拉线式的写法还是很方便的\nALUOp就只能拜托我们亲爱的Combinational Analysis啦\nCTRL在整个main电路中的书写还是比较简单的\n我把他设计成了一个很富有信息量的样子（）\n搭电路的过程中一些小惬意的时光就是在修改电路外观~\n测试文档 那么至此，我们的基础版CPU算是实现了基本自洽\n接下来，就需要有大量的边界与随机指令去测试它了！\n我首先测试了课程组给出的附件，并翻译为MIPS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 .text ori\t$28, $0, 0 ori\t$29, $0, 0 ori\t$1, $0, 0x3456 add\t$1, $1, $1 lw\t$1, 4($0) sw\t$1, 4($0) lui\t$2, 0x7878 sub\t$3, $2, $1 lui\t$5, 0x1234 ori\t$4, $0, 5 nop sw\t$5, -1($4) lw\t$3, -1($4) beq\t$3, $5, _1 beq\t$0, $0, _13 _1: ori\t$7, $3, 0x404 beq\t$7, $3, _11 nop lui\t$8, 0x7777 ori\t$8, $8, -1 sub\t$0, $0, $8 ori\t0, $0, 0x1100 add\t$10, $7, $6 ori\t$8, $0, 0 ori\t$9, $0, 1 ori\t$10, $0, 1 _minus2: add\t$8, $8, $10 beq\t$8, $9, _minus2 _13: _11: _minus1: beq\t$0, $0, _minus1 # dead continue 寄存器数据及跳转测试 // 本测试的不足之处在于支持了MARS不支持的错误运算 //如最大正数加1，最小负数减1，-1减最小负数等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //记得写v2.0 raw 3c00ffff // 测试`$0` //下面是对低16位赋值 3c01ffff 3c028000 00000000 //nop测试 3c047fff 3c058000 //下面是对低16位赋值 3421ffff // `$1` = -1 34420000 // `$2` = 最小负数 34630001 // `$3` = 1 3484ffff // `$4` = 最大正数 34a50001 // `$5` = 最小负数 + 1 //sw与lw的简单测试 ac64ffff //在0处存 `$4` 测试offset为负 bc200001 //把0处的值给`$0` 测试`$0` 8c040000 //把0处的值给`$4` 测试offset为0 00253020 // `$6` = `$5` + `$1` 10460002 //等于最小负数 跳2句 //跳-8句跳回形成死循环 00643820 //最大正数加一 10e20000 //等于最小负数 跳0句 00a34022 //最小负数+1减一 11020000 //等于最小负数 跳0句 01034822 //最小负数减一 11240000 //等于最大正数 跳0句 00225022 //-1减最小负数 1144fff8 //等于最大正数 跳-8句 检验方法 在保证sw无问题的前提下\n将所有的敏感变量都及时存储\nbe like:\n1 2 3 4 5 6 .macro save(%data) #不保存$t0,$t1 sw %data, 0($t0) # 不能用addi ori $t1, $0, 4 add $t0, $t0, $t1 .end_macro 之后只需要直接比对MARS和DM的存储区即可\n","date":"2024-10-23T12:30:15+08:00","image":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/88e20704208d17e1fd4372ecfb993c3_hu1946466944430747746.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/","title":"单周期CPU的logisim搭建"},{"content":"输入指令处理 switch case 与 各方法封装 1 基本可用 但展开复杂 练习一些markdown操作（）\n1\n1 2 3 a b c d e f CommandUtil 提供command方法 // cmd\n♫ Manager类管理Arraylist commandUtil ♫ cmdUtil = cmdUtilArray.get(operator - 1);✓\ncmdUtil.command(\u0026hellip;);✓\n逻辑性错误 数据流 引用（对象 or 方法） 运算（边界条件！） 控制流 差一 意外分支 综合性 输入输出 拷贝 String 引用错误 访问空指针 报错java.lang.NullPointerException\n（注意逻辑短路先后顺序避免报错） 越界异常 类型转换错误 报错java.lang.ClassCastException （可转化情况： 类型相同 有抽象层次关系 ","date":"2024-09-26T21:30:15+08:00","image":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86/","title":"oopre课堂随笔-指令处理"},{"content":"Welcome!! I feel so excited and interested to create my first blog!\nI plan to name my blog \u0026lsquo;Demiurge\u0026rsquo; just because this song is really astonishing and touching\u0026hellip;\n(By the way, the illustration is also fantastic)\nI am suddenly awared that 我可以直接说汉语啊喂（\n那么，今后请多多指教！\n","date":"2024-09-24T00:37:20+08:00","image":"https://demiurge-zby.github.io/p/demiurgefirstblog/demiurge_hu5188072458766260427.png","permalink":"https://demiurge-zby.github.io/p/demiurgefirstblog/","title":"DemiurgeFirstBlog"}]