[{"content":" 说在前面 本系列从P6上机结束开始制作，因此靠前的一些P可能记不清楚 本系列主观色彩较强，不过尚有一定准确信息 作者在P6献出首挂，并玉玉了一周（？） 接下来，就以我的吐槽为主了\nPre上机 考三道题，分别为logisim,verilog,MIPS\n原120min延时到180min\nlogisim考查：\n同步复位：不能使用clk和reset的与（clk在上升沿与clk == 1是两个概念！）\n正确的方法：1. 用reset，MUX控制输入数据，再把修正后的数据传给寄存器 2. 不使用MUX，而是将reset取反（再位拓展）后与Data与起来(reset==1时，结果为0\u0026amp;Data=0)，这样来控制输入数据 实质上两种方法都是保证给要写入寄存器的值做一个实时修正 保证只有上升沿那一瞬间，才能决定是否进行复位\n状态机： 已经很久远了，个人认为把斐波那契这种高阶的弄会就好\n加入An传进寄存器1，再传进寄存器2，再传进寄存器3, 那么当寄存器3为An时，寄存器2即为A(n+1)，寄存器1为A(n+2) 这就是logisim里暂时保留数据若干个时钟周期的途径\nverilog和MIPS考得都很水\n建议一定要学好verilog的组合逻辑循环怎么写 或者你能够熟练地打表 让你求32位的和，你就用C写出来一个a[0]+a[1]+\u0026hellip;倒也未尝不可\n1 2 3 4 5 always@（*）使用说明 0.全使用= 1.初始化（所有变量） 2.全是reg型和integer型 3.有用的东西最后再assign到某个wire变量上去 P0上机 三道题，logisim练习\n原120min延时到180min\n是谁国庆前一晚还在上机啊\n但是贴心的助教们出了一次极水极水的题！\n考察内容：善于封装子模块、Mealy(米利)机和Moore(摩尔)机的判别\n大家都是一路AC\n我WA了一次，比较器要设置成Unsigned！！！\nP1上机 三道题，verilog练习\n原120min延时到180min\n一般是一个简单的组合逻辑加两个状态机\n本来以为没有延时，差点以为要挂了，所以第二题做出来就开始摆了\n错因没有什么价值，纯粹打错符号了\n第三题是一个很复杂的状态机 难度堪比cpu_checker(笑)\n最后搭出来WA了几个点，也没弄明白WA在哪\nP2上机 三道题，MIPS练习\n原120min延时到180min\nT1 未给出C代码 题面如下：\n已知b,m,n，在[m,n]中找出一个整数a，使得a%b最小，输出a%b 看起来还唬唬人，但是真从m循环到n不动一点脑子肯定是会TLE的\n这东西他让你输出的是余数，那可就太简单了 要么是0，要么是m%b 如果是0，说明m到n存在b的倍数，那么n/b就不等于m/b 所以其实就是考察div,mfhi,mflo的使用 伪代码如下\n1 2 3 4 5 6 if (m / b != n / b) { printf(\u0026#34;0\u0026#34;); } else { printf(\u0026#34;%d\u0026#34;, m % b); } 有没有\\n我忘了（）\nT2考循环T3考递归 都有C语言代码，静静翻译就好，一般不会有bug 如果有，着重检查你的bgt,blt,beq,bne等等是否写反\n递归就着重两个字“保护” 保护的时间是jal前和jal后（物理意义，不是代码执行顺序） jal前表示进入递归之前做好现场保护 jal后则是退出上一层递归回到jal的PC+4的位置,恢复当时现场\nP3上机 终于来到我们的CPU阶段！ 以及闯关制的开始。\n最后一次使用logisim\n自此开始，课上是否通过基本等价于课下搭的CPU是否有误\n三道题，新指令添加\n原120min延时到150min（这个不同届不一样）\n本次没有明显感受，难度不太高 课下的记忆点更充实些\nP4上机 三道题，新指令添加\n120min 无延时。\n题目也不难，和T3难度相当\n作者没能AK。\n因为有课下bug!!!!!\n但是这个bug太小了。 jr $rs而非jr$31\n玉玉随笔：\n历经了轮轮评测， 也从未想过要在课上debug。 但我看到了完全与题意无关的报错信息， 我意识到了课下着实存在着的bug， 我惊惶，但又或是接受，接受我真的会在P4倒下，会在这条闯关路上走得一坨烂泥。 在课上最终de出了bug，确是万幸。 只是那瞬间，无休止的荒诞涌进一触即破的思绪， 畏惧后怕质疑庆幸猛地迸发开来， 只留呆滞的躯体挪动着不太灵光的鼠标， 看着界面的圆圈转着转着，拉着我去和P4说再见了。 P5上机 120min 无延时。\n课上过一题 = 课下没问题 = P5必通过！\n前两题顺风顺水 第三题做的悠哉悠哉不知不觉只剩10min\n交了一发 10个点过9个 挂了个TLE\n意识到这题卡时间 阻塞条件再细化 但是始终没有落实到寄存器冲突上 再交还是TLE 只剩下2min了 那 就交卷吧\n越是静下来，越是容易意识到问题关键 为什么当时不把那17个寄存器都排除呢？ 阻塞条件一定要细化！！ 只是担心于它的不确定性，怎么不去研究他的变化范围。\n2min很漫长。等了很久，等考试结束， 等未通过的同学都离开考场， 等问答环节来临， 我问助教究竟要优化到什么等级： 答案显然。 对于一定不被写的15个寄存器，不会有转发当然不必阻塞。\nP6上机 —— 1 史上最惊为天人的一集\n真的有人课下没bug课上还能全挂？！！\nT1时序逻辑掺组合逻辑 在乘除模块里求最高位1最低位0结果一直输出xxxx 结果是为没初始化 一de就是80min\nT2更是荒谬 32位累加没有设置位宽 这么简单的问题在当时混乱的大脑下藏了40min\n后续又做了一堆无用功，漫无目的地构造测试数据，感动自己地打表等等。。\n最终以0题通过幸终。\nP6上机 —— 2 时隔一个月的90min AK\n怀揣着极度的不安与不满，\n因为我真的不能保证我的课下确无问题。\n就这样 踏入了大家都在P7gap的空旷的考场\nT1已经退化成add类指令了。。 只是写入的值换成add结果的最高位1\n最高位1？这我可太熟了（苦笑 这不上周给我绊死的那位嘛 这周周中好好地跟他清算了一波 没想到还能见面，那就再也不见了\nT2一看条件存储，我先跳了\nT3经典跳转类 完成基础功能TLE最后一个点 乘除模块偷跑却又超速一个点 意识到不能暗改乘除 但是我也不知道怎么做\n此时我智慧的大脑居然认为测试点出错了 肯定有死循环 不然我有的点过快了这个点还能过慢？\n然后去做P2了 大致扫一眼：什么条件跳转。。原来是标题欺诈。 再定睛一看：啊？又是最高位1？ 只是把DM写的地址加上了一个与最高位1有关的数\n最麻烦的事大抵也就是DMWr的位扩展 但是还好我提前改成三位了\nT2过关，我开始回去看T3\n诶诶 这个T3一个点TLE 这不就是我的P5吗？？\n我P5的反思居然还派上用场了 我开始去思考我的阻塞\u0026hellip;\u0026hellip; 用不到，不需转发就不阻塞！！ 又写了四行优化阻塞逻辑 交了一发终于AC。\n最后，还是喷一下上周。 课下无bug课上全挂真是神人了。\n另外，如果感觉自己课下没bug还课上全挂的别担心 你的课下可能确无bug 考场上的蠢度永远是自己无法想象的。\nP7上机 —— 1 紧接上文，考场外的蠢度你也无法想象。\n四道强测： 功能强测 异常强测 中断强测 冒险强测\n一道附加指令：Withdraw\n120min\n刚开始交前四题，全挂。\n我有点崩溃，但是看到大家也是一片红，我深深感觉到强测之强。\n（其实很多人都一遍过，只是我没看见）\n直到\u0026hellip;\u0026hellip;zzy 60min交卷 zjy 70min交卷\n我开始怀疑自己是不是真的写的太烂了。\n一直到我看到ALE里面没引入Instr，我终于意识到： 我最新版没提交！！！\n一瞬间，像是通过了一束电流，整个人呆住了。\n急忙地改回代码，中间还改错了一次，漏写了一个接口，让我期待落空了几分钟。。\n不过当我把新版本改好，漫长的排队等待\u0026hellip;\u0026hellip;\n绿了，绿了，红了？绿了？ 还差一个中断异常，有2个点挂了。\n中断区别于异常，我觉得比较易错的是空泡的处理，琢磨了一段时间，我好像意识到自己应当采用两种不同的流水方式。\n但是这时已经8:55了。如果我提交并通过，我将没有机会再去不通过。\n我迟迟没有提交。\n我只顾着懊悔为什么没提交最新版，却没想到其实我可以先把前面一道题弄错，从而能够判断这题能不能过的同时顺利不通过。\n希望能给大家一点启发吧。\nUpdate 12.3\n没想到中测就能测出来这个问题。\n我特意交了一版没修改nop流水方式的，居然挂掉了一个点，和当时中断强测的点略有类似。\n而且修改之后便通过了。\n那可能，就是这样了？\n我好像安定下来了，但又诚惶诚恐。\n跟P6好像啊，一场考试下来还不知道自己课下还有没有问题。\n据说加指令的题也不简单。2h能拿下吗？\n紧张，紧张。\nP7上机 —— 2 在开考前进行了龙芯杯的宣讲。 考试时间7:40-9:40，注意时间把控。\n其实对自己的MIPS还是略带自信的，因为我确实不相信他会加强测试点。\n建议下载压缩包后直接速提交，不要再做解压，或是装进ISE等事项。你要提交的就是源代码。\n否则就会喜提20min的gap，心神不宁地排300余人的队\n强测过了之后，完全不可懈怠！一定要严谨严肃。\n本次题目为： 添加异常WATCH 触发方式有二：IMWATCH与DMWATCH\nPC0添加18号寄存器与19号寄存器（支持正常读写）\n19号寄存器为异常判断使能 18号寄存器高16位是IM敏感值，低16位是DM敏感值\n异常逻辑就是 当前pc与IM敏感值相同时且19号寄存器使能满足要求时触发IMWATCH DM敏感值在sl指令读写地址范围内时且19号寄存器使能满足要求时触发DMWATCH\n几个注意点：\n异常优先级。以往的异常是不会同时出现的，而如今IMWATCH随时可触发，DMWATCH可以与ADEL,ADES同时触发 IMWATCH优先级低于取指异常，高于其他异常。 DMWATCH优先级低于ADES,ADEL（对于同时出现的异常） 范围内。对于DMWATCH注意要匹配的是在范围内，如sw，DM敏感值是四个值中的一个即可。 这里我们可以大胆用ADDR\u0026lt;= watchaddr \u0026lt;=ADDR+3, 他一定字对齐，否则会出现优先级更高的ADES异常。\n乘除槽。IMWATCH可以在任何指令上触发，因此乘除法也可能是异常指令，不能等到他走到M级在检测出来，此时为时已晚，乘除槽停不下来。 因此需要提前判断好IMWATCH异常，将其加入MDALU模块。 阻塞。mtc0 18和19都是危险的，会直接影响WATCH的判断，因此必须阻塞。 这决定了IMWATCH不能在F级判断，因为这样会使D级为mfc0 18,19也需要阻塞，而这会导致死循环，因为我们的阻塞逻辑就是在D级实现的，那么mtc0就被卡在D级不得动弹。\n在D级判断IMWATCH是较为正确的选择。\n作者其实没有一交即过。 让我以为这个测试很强。\n其实是因为写成了CP018号寄存器31:16 == pc[31:16]\u0026hellip;\n应该是CP018号寄存器31:16 == pc[15:0]， 或者{16\u0026rsquo;b0,CP018号寄存器31:16} == pc.\n改完没想到就直接过了。 一瞬间，惊喜而释然。\n说在最后 计组上机就这样圆满结束了。\n在提问环节，助教问我： 你觉得你在计组闯关的收获是什么？\n回首，一路走来实在坎坷。\nPre的茫然 P1的无力 P4的惊愕 P5的懊悔 P6的愚钝 P7的畏惧\n平稳，或是激荡地 每一个Project都有着课上课下的呐喊\n从第一个单周期CPU 到封装流水线CPU可支持中断支持外设支持异常处理支持30余条指令的MIPS微系统 诞辰不久的博客也日渐丰满\n这像是一种高压下的凝聚 引领着我们去稳健处理庞大的项目\n从形象框架到代码实现 从独立执行到高效流水 从单一指令到复杂延时 从固定运行到异常中断\n不同的Project把步骤分离 并予以较强的正确性检查 使得P5不必担心P4部件的实现 P6不必担心P5转发阻塞的实现 P7不必担心P6CPU本身的实现\u0026hellip;\n未来的项目倘若没有这些具象的规划 根本不敢想有多困难。\n当然，感谢每一位同行者的帮助与支持。非常感谢。\nCO上机结束，我也终于可以好好躺下，大脑放得很空很空，吸入又呼出些跳动的空气，悄悄捕捉又一颗充满爱与自由的心。\n","date":"2024-12-10T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E4%B8%8A%E6%9C%BA/3c7fe802fe677d02b6b3708d9f40249_hu9209242832316334602.png","permalink":"https://demiurge-zby.github.io/p/%E4%B8%8A%E6%9C%BA/","title":"上机"},{"content":" 说在前面 还得是设计文档。 每次一旦盯着理论看，又想看全又想做细，就会陷入P5当时的茫然 总是想一针见血地写出最有远见卓识的代码，当然会踌躇，更何况还未必能写出来。 但是一步一步走出来，也就走出来了。\n设计文档 在对P7的整体内容有了把握之后，我们可以知道，本次P7主要要完成的任务是：\n更改流水线各级使之可以产生异常 添加 CP0 与 异常处理 添加 Bridge 与两个外设（计时器）交互 ExcCode的产生与流水 根据教程的表格，我们可以得到：\n异常与中断码 助记符与名称 指令与指令类型 描述 0 Int （外部中断） 所有指令 中断请求，来源于计时器与外部中断。 4 AdEL （取指异常） 所有指令 PC 地址未字对齐。 4 AdEL （取指异常） 所有指令 PC 地址超过 0x3000 ~ 0x6ffc。 4 AdEL （取数异常） lw 取数地址未与 4 字节对齐。 4 AdEL （取数异常） lh 取数地址未与 2 字节对齐。 4 AdEL （取数异常） lh, lb 取 Timer 寄存器的值。 4 AdEL （取数异常） load 型指令 计算地址时加法溢出。 4 AdEL （取数异常） load 型指令 取数地址超出 DM、Timer0、Timer1、中断发生器的范围。 5 AdES （存数异常） sw 存数地址未 4 字节对齐。 5 AdES （存数异常） sh 存数地址未 2 字节对齐。 5 AdES （存数异常） sh, sb 存 Timer 寄存器的值。 5 AdES （存数异常） store 型指令 计算地址加法溢出。 5 AdES （存数异常） store 型指令 向计时器的 Count 寄存器存值。 5 AdES （存数异常） store 型指令 存数地址超出 DM、Timer0、Timer1、中断发生器的范围。 8 Syscall （系统调用） syscall 系统调用。 10 RI（未知指令） 未知指令 未知的指令码。 12 Ov（溢出异常） add, addi, sub 算术溢出。 根据教程的要求，我们容易知道，只需分析好每一个部位可能产生的异常，然后随着流水线流水即可。 同一条指令在某一个阶段不会产生多种异常。（这由异常的划分方式确定） 但是一个阶段可能存在多个异常。其处理顺序为先来后到。也就是处理最老的指令，执行到最后面的指令的新错误。\n有人说，你这样做就是只处理最新的错误啊，怎么保证处理了最新的错误还能处理旧的错误呢？\n这是因为处理异常的方法是把句子变成nop，并重新从受害指令下一条开始执行。 这样，未被处理的指令的错误就会重新展现出来，再次被处理。\n我们决定，传入流水线的ExcCode，是要经过一个有优先级的多路选择器的。 为了区分，我们命名为\nExcCode_X(本阶段产生的) 和ExcCode_X_true(实际传入流水线的) 以及ExcCode_X_last(流水线传进来的)\n接下来就来判断异常吧。 我打算根据流水级来进行分类处理。\n注意： Int表示外部中断，更表示此处无异常。因此ExcCode可以大胆赋0，具体是否中断还要看外部信号。\n附一个可能用到的表格：\n条目 地址或地址范围 备注 数据存储器 0x0000_0000∼0x0000_2FFF 指令存储器 0x0000_3000∼0x0000_6FFF PC 初始值 0x0000_3000 异常处理程序入口地址 0x0000_4180 计时器 0 寄存器地址 0x0000_7F00∼0x0000_7F0B 计时器 0 的 3 个寄存器 计时器 1 寄存器地址 0x0000_7F10∼0x0000_7F1B 计时器 1 的 3 个寄存器 中断发生器响应地址 0x0000_7F20∼0x0000_7F23 我们使用以下宏定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 `define Exc_AdEL 5\u0026#39;d4 `define Exc_AdES 5\u0026#39;d5 `define Exc_Syscall 5\u0026#39;d8 `define Exc_RI 5\u0026#39;d10 `define Exc_Ov 5\u0026#39;d12 `define IM_start 32\u0026#39;h3000 `define IM_end 32\u0026#39;h6fff `define DM_start 32\u0026#39;h0000 `define DM_end 32\u0026#39;h2fff `define T0_start 32\u0026#39;h7f00 `define T0_end 32\u0026#39;h7f0b `define T1_start 32\u0026#39;h7f10 `define T1_end 32\u0026#39;h7f1b `define T0_count_start 32\u0026#39;h7f08 `define T0_count_end 32\u0026#39;h7f0b `define T1_count_start 32\u0026#39;h7f18 `define T1_count_end 32\u0026#39;h7f1b `define Int_generator_start 32\u0026#39;h7f20 `define Int_generator_end 32\u0026#39;h7f23 ExcCode_F 我们发现只能发生： AdEL: PC未字对齐或PC超界\n1 2 3 assign ExcCode_F = ((pc_F[1:0] != 2\u0026#39;b0) || pc_F \u0026lt; `IM_start || pc_F \u0026gt; `IM_end) ? `Exc_AdEL : 0; assign ExcCode_F_true = ExcCode_F; ExcCode_D D级的核心工作是译码。\nRI：未知指令 Syscall: 系统调用\nRI与Syscall信号也由Ctrl译码时顺带产生。\n1 2 3 4 5 6 assign RI = !(nop || add || sub || And || Or || slt || sltu || lui || addi || andi || ori || lb || lh || lw || sb || sh || sw || mult || multu || div || divu || mfhi || mflo || mthi || mtlo || beq || bne || jal || jr || mfc0 || mtc0 || eret || syscall); assign Syscall = syscall; 1 2 3 4 5 assign ExcCode_D = (Syscall) ? `Exc_Syscall : (RI) ? `Exc_RI : 0; //此处虽然有优先级，但是两者是不会同时发生的 assign ExcCode_D_true = (ExcCode_D_last) ? ExcCode_D_last : ExcCode_D; //优先级，同一指令按最老的错误来 ExcCode_E AdEL: 计算load地址时加法溢出\nAdES：计算store地址时加法溢出 Ov:add,addi,sub的算数溢出\n这些信号利用ALU模块得出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 wire overflow_add; wire overflow_sub; wire [32:0] ext_num_1; wire [32:0] ext_num_2; wire [32:0] ext_add; wire [32:0] ext_sub; assign ext_num_1 = {num_1[31], num_1}; assign ext_num_2 = {num_2[31], num_2}; assign ext_add = ext_num_1 + ext_num_2; assign ext_sub = ext_num_1 - ext_num_2; assign overflow_add = ext_add[32] ^ ext_add[31]; assign overflow_sub = ext_sub[32] ^ ext_sub[31]; assign Ov = ((add || addi) \u0026amp;\u0026amp; overflow_add) || (sub \u0026amp;\u0026amp; overflow_sub); assign AdEL_E = (DMRd_E) \u0026amp;\u0026amp; overflow_add; assign AdES_E = (DMWr_E) \u0026amp;\u0026amp; overflow_add; 大错特错！大错特错！！！\n1 2 assign Ov = (((ALUOp == `ADD) || (ALUOp == `ADDI)) \u0026amp;\u0026amp; !DMRd_E \u0026amp;\u0026amp; !DMWr_E \u0026amp;\u0026amp; overflow_add) || ((ALUOp == `SUB) \u0026amp;\u0026amp; overflow_sub); de出这个bug真费了不少功夫。 第一次de出来是意识到ALUOp是ADD,未必指令就是ADD, 还有可能是store与load指令！！\n结果还没过。。\n这次很随便一个数据居然de出来了 因为一条ori指令出现了Ov!!!\n这让我感到极为震惊。我就看了看Ov的所有相关信号———— 当我看到add,并发现它是一个32位数时\u0026hellip;\u0026hellip;\n太抽象了！！！！！ add原来是数据信号啊不是控制信号！！！ 控制信号是ALUOp！！！！！\nUpdate 12.1: 这也太抽象了！！！ 感谢COKiller!!! 没想到能在这里de三次。。\n第一次是因为sw犯了Ov 第二次是因为ori犯了Ov 第三次是因为div犯了Ov!!!!!!!\n天打五雷轰。\nmultu,divu乃至于mfc0，mfhi都在ALUOp对应ADD！！！\n所以我老实了。 我直接把Instr传到E级，由Instr指导is_ADD。\n1 2 3 4 assign is_ADD = (Instr_E[31:26] == 6\u0026#39;b000000) \u0026amp;\u0026amp; (Instr_E[5:0] == 6\u0026#39;b100000); assign Ov = ((is_ADD || (ALUOp == `ADDI)) \u0026amp;\u0026amp; overflow_add) || ((ALUOp == `SUB) \u0026amp;\u0026amp; overflow_sub); 这样应该就没有问题了罢。。\n1 2 3 4 5 assign ExcCode_E = (AdEL_E) ? `Exc_AdEL : (AdES_E) ? `Exc_AdES : (Ov) ? `Exc_Ov : 0; assign ExcCode_E_true = (ExcCode_E_last) ? ExcCode_E_last : ExcCode_E; ExcCode_M AdEL:\nlw,lh字对齐 lh,lb取Timer 超范围 AdES:\nsw,sh字对齐 sh,sb写Timer 所有store写Count寄存器 超范围 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 assign AdEL_M = (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMRd_M == `LW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); assign AdES_M = (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMWr_M == `SW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_count_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_count_end) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end)) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end)) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end)) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); assign ExcCode_M = (AdEL_M) ? `Exc_AdEL : (AdES_M) ? `Exc_AdES : 0; assign ExcCode_M_true = (ExcCode_M_last) ? ExcCode_M_last : ExcCode_M; 好嘞笑死了，已经被自己蠢死了\n应当改为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 assign AdEL_M = (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMRd_M == `LW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); assign AdES_M = (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMWr_M == `SW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_count_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_count_end) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); 不同的异常类型确实应该或起来，但是地址越界是一种异常！！ 必须同时满足在所有区域之外！内部表述应使用与\nW级不产生异常。 至此，我们貌似写完了所有异常。\nCP0及异常处理 我们一般将CP0放进M级。 这意味着指令异常在M级进行处理。\n这形成了单周期CPU的封装： 一般认为M级指令为正在执行的指令。 一般认为PC_M即为宏观PC。 一般认为W级处的指令是已完成的指令。 一般认为F,D,E级的指令都是未开始执行的指令。\n一旦有这样单周期的认知，那么 出现异常就是指M级指令出现异常; 受害PC即为M级PC。 或者说，任何指令在某一流水级产生的异常， 都要等待该指令进入M级才可被处理。\nCP0基础信息 课程组给出的接口表格：\n端口 方向 位数 解释 clk I 1 时钟信号 reset I 1 复位信号 en I 1 写使能信号 CP0Addr I 5 寄存器地址 CP0In I 32 CP0 CP0Out O 32 CP0 VPC I 32 受害PC BDIn I 1 是否是延迟槽指令 ExcCodeIn I 5 记录异常类型 HWInt I 6 输入中断信号 EXLClr I 1 用来复位 EXL EPCOut O 32 EPC 的值 Req O 1 进入处理程序请求 课程组给出的关键寄存器信息：\n寄存器 编号 功能 SR 12 配置异常的功能 Cause 13 记录异常发生的原因和情况 EPC 14 记录异常处理结束后需要返回的PC 课程组给出的关键功能域：\n寄存器 功能域 位域 解释 SR（State Register） IM（Interrupt Mask） 15:10 分别对应六个外部中断，相应位置1表示允许中断，置0表示禁止中断。这是一个被动的功能，只能通过mtc0这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。 SR（State Register） EXL（Exception Level） 1 任何异常发生时置1，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。 SR（State Register） IE（Interrupt Enable） 0 全局中断使能，该位置1表示允许中断，置0表示禁止中断。 Cause BD（Branch Delay） 31 当该位置1时，EPC指向当前指令的前一条指令（一定为跳转），否则指向当前指令。 Cause IP（Interrupt Pending） 15:10 6位待决的中断位，分别对应6个外部中断，相应位置1表示有中断，置0表示无中断。每个周期将会被修改一次，修改的内容来自计时器和外部中断。 Cause ExcCode 6:2 异常编码，记录当前发生的是什么异常。 EPC - - 记录异常处理结束后需要返回的PC。 对于关键域，我们使用宏定义以方便书写：\n1 2 3 4 5 6 `define IM SR[15:10] `define EXL SR[1] `define IE SR[0] `define BD Cause[31] `define IP Cause[15:10] `define ExcCode Cause[6:2] 对于CP0，它的主要功能即为 存储异常中断的相关信息，表征异常中断的开始与结束， 引导转向异常中断模块处理与退回原指令。\n判断异常中断的发生 1 2 3 4 5 6 7 wire Exc_req; wire Int_req; assign Exc_req = (ExcCodeIn != 5\u0026#39;b0) \u0026amp;\u0026amp; (`EXL == 1\u0026#39;b0); //我们不太确定EXL为1时能否触发异常。但是其实我是把EXL==1当成全局异常判断使能看待的 assign Int_req = (|(HWInt \u0026amp; `IM)) \u0026amp;\u0026amp; `IE \u0026amp;\u0026amp; (`EXL == 1\u0026#39;b0); assign req = Exc_req || Int_req; 这里比较巧妙的是 (|(HWInt \u0026amp; `IM)) 这一语句\n巧妙使用了按位与，先得到各个信号是否中断且中断是否被允许 然后再把这6位或起来（不或也可以）\n当然最后不能忘了全局使能与EXL限制\n存储异常中断的相关信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 always @(posedge clk) begin if (reset) begin SR \u0026lt;= 0; Cause \u0026lt;= 0; EPC \u0026lt;= 0; end else begin `IP \u0026lt;= HWInt; if (req) begin `EXL \u0026lt;= 1\u0026#39;b1; EPC \u0026lt;= (BDIn) ? (VPC - 32\u0026#39;d4) : VPC; `ExcCode \u0026lt;= (Int_req) ? 5\u0026#39;b0 : ExcCodeIn; `BD \u0026lt;= BDIn; end if (EXLCLr) begin `EXL \u0026lt;= 1\u0026#39;b0; end end end `ExcCode \u0026lt;= (Int_req) ? 5\u0026rsquo;b0 : ExcCodeIn; 这句话是表明优先级的，Int与Exc的区别，在CP0中就是靠Cause寄存器来展现。 如果同时发生Int与Exc，如何保证Int优先？ 只需一个三目运算符，先判断中断。\nEPC \u0026lt;= (BDIn) ? (VPC - 32\u0026rsquo;d4) : VPC;\n这句话体现了BDIn的功能。 如果这句话是延迟槽语句，那么你应当保证跳转指令正常进行。如果你只重新执行延迟槽，跳转指令就不能实现。 那么此时我们就不采用直接重新执行受害指令的方法，而是采用执行受害指令前一句的分支跳转。\n但是为什么可以选择执行受害指令上一句？ 这样的做法无疑是执行了两遍这一指令。\n但是正因为它是跳转指令，它并没有累加效应。 就连唯一有写功能的jal也只会写他对应的那一个值。\n那就有人说，你这不是钻空子吗？万一添加个新跳转指令，让你给$ra写当前$ra的值加4，这不就完了吗？\n新指令在W级，延迟槽在M级判出问题（或中断）。这样的话你完全来得及让第一次的写入无效，只需把W级写使能修改一下，把BDIn和req引出去，并说明这个时候不能写入。\n诶诶，那又有人问了，你这么写不就说明你的写使能是可能最后突然改变的，那你之前要是执行过转发怎么办？\n这就不得不说咱们的单周期思想了。在异常中断面前，M级以前的指令都相当于没有执行。转发给你啥都无所谓。\n那就又有人问了，M级本身要是被转发了怎么办？\n害，M级如果发生异常中断了，那就也需要重新执行，也相当于未执行指令。\n好，一段小思考结束了。\n写入关键寄存器 这一操作也应在CP0中完成 其实也只是添加了如下内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /*always @(posedge clk) begin if (reset) begin SR \u0026lt;= 0; Cause \u0026lt;= 0; EPC \u0026lt;= 0; end else begin `IP \u0026lt;= HWInt; if (req) begin `EXL \u0026lt;= 1\u0026#39;b1; EPC \u0026lt;= (BDIn) ? (VPC - 32\u0026#39;d4) : VPC; `ExcCode \u0026lt;= (Int_req) ? 5\u0026#39;b0 : ExcCodeIn; `BD \u0026lt;= BDIn; end if (EXLCLr) begin `EXL \u0026lt;= 1\u0026#39;b0; end*/ if (en \u0026amp;\u0026amp; !req) begin //执行mtc0时发生中断，则不予写入 case (CP0Addr) 5\u0026#39;d12 : begin SR \u0026lt;= CP0In; end 5\u0026#39;d14 : begin EPC \u0026lt;= CP0In; end default: begin end endcase end/* end end*/ 但是具体en，CP0Addr，CP0In怎么得到，那就是CP0外部的事了。\n在这里我还是打算直接写好。因为这确实是一块很小的，而且与下一部分关系不大的内容。\n核心就是添加mtc0,mfc0指令，放进流水线等等。\n这个和mfhi,mthi的逻辑几乎完全相同。\n先分析mtc0吧，只需要在M级给CP0的en接口接上Mtc0_M 写的地址是rd_M 写的内容是MemData_M\n注意控制信号Tuse_rt = 2\nmfc0要注意RFWr置1，Tnew = 2 写的地址是rt 写的内容是RegData\n1 2 assign RegData = Mfc0_W ? CP0Out_W : WdSel_W ? MemReadData_W : ALUData_W; 可以发现CP0Addr始终为rd,所以直接让该端口接rd_M。\n整体来说是这个样子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CP0 Cp0( .clk(clk), .reset(reset), .en(Mtc0_M), .CP0Addr(rd_M), .CP0In(MemData_M), .VPC(pc_M), .BDIn(PCSel_W), // 如果上一句是跳转，那么这一句是延迟槽 .ExcCodeIn(ExcCode_M_true), .HWInt(HWInt), .EXLCLr(EXLClr), .CP0Out(CP0Out_M), .EPCOut(EPC), .req(req) ); CPU进行异常处理 语句跳转 遇到异常时进入Exception Handler 0x00004180 在异常处理程序结束时会执行指令eret回到EPC\n语句清空 利用CP0生成的req信号对所有流水线寄存器进行清空。 （因为CP0在M级，那么此时W级的操作在本时钟周期已完成，由于同步复位，清空寄存器只会影响下一周期的内容，这样下一周期所有指令都已完成，不受干扰。）\n（注意精确异常，认真阅读教程中关于乘除槽精确异常的讲述。 ）\n这里有很重要的一点在于eret没有延迟槽。因此执行完eret后，下一条指令应当是EPC。\neret在D级，此时eret的下一条指令（物理层面）在F级\n我们需要F级的指令是EPC而非eret的下一条指令\n以下内容看乐子就行\n我们采用一种奇妙的做法：\n当eret在F级时，我们直接进行检测该指令是否是eret。\n如果是，那么NPC为EPC。\n1 2 3 4 5 6 wire Eret_F; assign Eret_F = (Instr_F == 32\u0026#39;d01000010000000000000000000011000); assign _npc = Eret_F ? EPC : PCSel_D ? npc : (pc_F + 32\u0026#39;d4); 解释一下之前的定义： _npc为真正的NPC PCSel_D是判断D级是否为跳转指令 npc是跳转指令算出来的npc\n这里要注意EPC它并不是一个定值，他可能被mtc0改变！！ 因此有一套转发与阻塞逻辑： 我现在需要一个正确的pc\n1 2 3 4 assign _EPC = (Mtc0_D \u0026amp;\u0026amp; rd_D == 5\u0026#39;d14) ? V2_D : (Mtc0_E \u0026amp;\u0026amp; rd_E == 5\u0026#39;d14) ? V2_E_Data : (Mtc0_M \u0026amp;\u0026amp; rd_M == 5\u0026#39;d14) ? CP0In : EPC; 这样的转发足够吗？ 不够！必须阻塞！！\nmtc0不被阻塞的前提是mtc0认为自己能在写CP0之前拿到对的值 所以他在没有到达CP0的时候的值都有可能不对\nEPC的值是在mtc0到达W级的时候被传送到F级供eret使用\n在mtc0在M级的时候，它的CP0In肯定也是对的，可以转发。\n在mtc0在D,E级的时候，都可以考虑阻塞。\n1 2 3 4 5 6 7 /*assign stall = start_busy || (busy \u0026amp;\u0026amp; MDALUOp_D) ||*/ ((Eret_F \u0026amp;\u0026amp; Mtc0_D \u0026amp;\u0026amp; rd_D == 5\u0026#39;d14)) || ((Eret_F \u0026amp;\u0026amp; Mtc0_E \u0026amp;\u0026amp; rd_E == 5\u0026#39;d14)) ||/* ((A1 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_E)) || ((A1 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_M)) || ((A2 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_E)) || ((A2 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_M));*/ 我们看似用的是D级的阻塞，但这样也能起到阻塞F级eret的作用\n这一段的写法过于创新。我们不得不有把这种设计毁掉的打算。\nUpdate 12.1: 我很抱歉。在没有de出真正的bug之前，我选择把这一种方法全部删去。采用了大家普遍使用的D级执行。\n当然，在修改之后当时并没能解决任何问题。\n这里要注意一点： eret严格意义上在M级才能视为被执行。 因此EXLClr需要在Eret信号传到M级时才置1。\n至于eret的清空延迟槽，就不再多说了，需要注意它的BD应为0。 在阻塞上我也是正常全力阻塞，转发也不想写了。。\n逻辑就是eret在D级，mtc0在E,M级且要写的内容是EPC时直接大胆阻塞。\n对于异常跳转，监测标志为req req置1时，pc需变为0x00004180\n1 2 3 4 5 6 7 8 9 10 11 /*always @(posedge clk) begin if (reset) begin PCreg \u0026lt;= 32\u0026#39;h00003000; end*/ else if (req) begin PCreg \u0026lt;= 32\u0026#39;h00004180; end/* else if (En_pc) begin PCreg \u0026lt;= npc; end end*/ req优先级需注意，低于reset，位于第二高的地位。\n紧接着，我们解决req对寄存器的清空。\n本来很简单的一件事情，由于阻塞而变得复杂。 阻塞，产生了空泡，但这个空泡不应是全空的。\n这个空泡应当是上一条指令生命的延续。\n尤其是PC信息与Bd信息。 对于阻塞型清空，应保持不变。\n如D_E流水线寄存器中：\n1 2 3 pc_E \u0026lt;= reset ? 32\u0026#39;h00003000 : req ? 32\u0026#39;h0000_4180 : pc_D; PCSel_E \u0026lt;= (reset || req) ? 0 : PCSel_D; 真的是这样吗？？\nUpdate 12.2 上机debug\n空泡要存的信息究竟是谁？\n是被阻塞指令的pc和跳转指令的PCSel\n因此\n1 2 3 4 pc_E \u0026lt;= reset ? 32\u0026#39;h00003000 : req ? 32\u0026#39;h00004180 : pc_D; ExcCode_E_last \u0026lt;= 0; PCSel_E \u0026lt;= (reset || req) ? 0 : PCSel_E; 两种继承方式！ PCSel直接继承，pc流水继承。\n其次我已做了改动，eret不再是PCSel指令了。\n为什么要这么做呢？\neret他要起到修正PCSel的作用这确实，但是他还有很多自己的特别作用！\n你不能对它进行额外的流水处理！\n你总不能让一句nop拥有eret性质吧，我们EXLClr可是跟eret很有关系的。\n外设及其交互 其实整体来说，外设的作用就只有信息存储与中断产生。\n中断信号的导入 中断信号相对简单，只需要传递给HWInt接口。\nTimer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。\n1 2 wire [5:0] HWInt; assign HWInt = {3\u0026#39;b0, interrupt, IRQ_1, IRQ_0}; 系统桥与信息存储 我们在此构建一个新模块Bridge\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 module BRIDGE( input wire [31:0] addr, input wire [3 :0] byteen, input wire [31:0] Rd_T0, input wire [31:0] Rd_T1, input wire [31:0] Rd_DM, output wire [31:0] Rd, output wire [3:0] m_data_byteen, output wire [3:0] m_int_byteen, output wire hit_T0, output wire hit_T1 ); wire hit_DM; wire hit_Int; assign hit_T0 = (byteen == 4\u0026#39;b1111) \u0026amp;\u0026amp; (addr \u0026lt;= `T0_end) \u0026amp;\u0026amp; (addr \u0026gt;= `T0_start); assign hit_T1 = (byteen == 4\u0026#39;b1111) \u0026amp;\u0026amp; (addr \u0026lt;= `T1_end) \u0026amp;\u0026amp; (addr \u0026gt;= `T1_start); assign hit_DM = (addr \u0026lt;= `DM_end) \u0026amp;\u0026amp; (addr \u0026gt;= `DM_start); assign hit_Int = (addr \u0026lt;= `Int_generator_end) \u0026amp;\u0026amp; (addr \u0026gt;= `Int_generator_start); assign m_data_byteen = (hit_DM) ? byteen : 0; assign m_int_byteen = (hit_Int) ? byteen : 0; assign Rd = (hit_T0) ? Rd_T0 : (hit_T1) ? Rd_T1 : (hit_DM) ? Rd_DM : 0; endmodule 我们可以看出，它无非是\n根据addr和byteen得出新的字节使能信号 对各方面的读取进行选择，得出真正的读入内容 这样，我们就可以顺利搭建顶层模块：\n无非是两个Timer，还有一些信息处理与传输嘛，最后还是给CPU使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 wire hit_T0; wire hit_T1; wire [31:0] Rd; BRIDGE bridge( .addr(addr), .byteen(byteen), .Rd_T0(Rd_T0), .Rd_T1(Rd_T1), .Rd_DM(m_data_rdata), .Rd(Rd), .m_data_byteen(m_data_byteen), .m_int_byteen(m_int_byteen), .hit_T0(hit_T0), .hit_T1(hit_T1) ); wire IRQ_0; wire [31:0] Rd_T0; TC Timer_0( .clk(clk), .reset(reset), .Addr(addr[31:2]), .WE(hit_T0), .Din(m_data_wdata), .Dout(Rd_T0), .IRQ(IRQ_0) ); wire IRQ_1; wire [31:0] Rd_T1; TC Timer_1( .clk(clk), .reset(reset), .Addr(addr[31:2]), .WE(hit_T1), .Din(m_data_wdata), .Dout(Rd_T1), .IRQ(IRQ_1) ); endmodule 注意一下TC传的地址是[31:2]\n连完顶层模块，P7好像就，结束了？\n通过ISE把语法错误搞完，然后\u0026hellip;\n陷入无尽的debug之中了。\n测试文档 P6既然过了，P7的无异常情况基本是不需要考虑的。\n基本处理模式 测试首先从简单的异常开始，比如简单的Ov\n认真观察波形图，分析一下进入异常处理程序后各寄存器的情况，以及是怎么跳转回去的，跳转回去各寄存器的情况又如何。\n此时的异常处理程序还比较简单，比如可以只有4条语句：\n取EPC，EPC+4，存EPC，eret\n(这个还能顺便测测阻塞)\n1 2 3 4 5 6 .ktext 0x4180 mfc0\t$k0, $14 addu\t$k0, $k0, 4 mtc0\t$k0, $14 eret 99999999 (一条无效指令，测一测延迟槽清空) 防止漏判 构造出所有引发异常的组合。\n你只需要对着你那个表格，一种种地敲\n关键是看好ExcCode\n防止误判 这个是比较难发现的，在使用COKiller之前，我碰运气确实找到了一些样例误判，但是用了COKiller我才发现div触发Ov没有被我发现。\n我的建议就是多用评测机，多看代码。\n其他细节谬误 这些我觉得可以对着学长博客所强调的点先检查是否实现，再写测试程序来看写的是否正确。\n例如空泡的信息继承，乘除槽的执行与否等等。\n思考题 请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？\n鼠标和键盘等都属于外设，外设与CPU的时钟频率可谓是天差地别。中间必须要有一个接口，实现两者之间的信息交流。\n这个接口往往有硬件的控制信号，更有软件的处理程序，能够使这些信号变为CPU接受的形式。\n请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）\n因为我们的异常处理程序是统一放在这里的，你要执行异常处理程序就是要到达这个pc。\n不过用户自己实现处理异常中断应该也不会有大的问题，毕竟我们自己搭CPU测试的时候不就是自己写处理中断的程序嘛，写得很烂就是了。。\n但是0x4180本身位置的控制一定是经过慎重考虑的，有其空间分配的优越性。\n为何与外设通信需要 Bridge？\n高内聚，低耦合。\n外设可以添加，但是CPU不应为之改变。 这时候，系统桥就能起到分析处理双方信息的作用。\n当我们添加新外设，只需改动Bridge来控制要读谁，要写谁的问题。\n请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并针对每一种模式绘制状态移图。\n整个流程两种模式十分类似，差别在于是否具有周期性。\n对于IDLE，ctrl[0]为0转为状态LOAD，并把IRQ置0，接下来，无条件进入计时阶段，如果中途ctrl[0]为1就终止，进入IDLE，否则就计数完成时进入INT，发送中断。\n到了INT阶段， if(`ctrl[2:1] == 2\u0026rsquo;b00)，那么就一直中断，进入IDLE继续循环。 否则，IRQ置0，即只中断这一个周期，然后进入IDLE重新循环。\n不过共同之处在于，ctrl[0]对中断的产生都有明显的控制作用。\n倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？\n会发生EPC为0的问题。这个问题在设计文档已经提到过，还是那句话：\n空泡应当是上一条指令生命的延续。\n我们处理的核心问题是EPC，所以说空泡要着重继承与之有关的PC值与Bd值。\n空泡要存的信息究竟是谁？\n是被阻塞指令的pc和跳转指令的PCSel\n为什么 jalr 指令为什么不能写成 jalr $31,$31？\n这也是我的设计文档中所提到的一个问题。\nBd为1而是用重复执行跳转指令的方法确实有潜在问题，正如jalr $31, $31的情况：\n这是一个有累加效应的写指令。两次执行jalr的写效果是不同的。\n解决方案文中也有讨论到： 异常中断在延迟槽发生，那么就屏蔽req时的写GRF，让此时W级的写指令无效。\n下一次回到这句话的时候才是真正执行。\n倘若延迟槽又出现问题，那就再让此时W级写使能无效即可。\n","date":"2024-11-26T20:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p7-mips%E5%BE%AE%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/destruction321_hu5083056439175028234.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p7-mips%E5%BE%AE%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/","title":"北航CO P7 MIPS微系统搭建"},{"content":" 说在前面 能通过P5实在是很好的一件事。 在我第一道题直接AC确定课下无bug，在我很快做出前两道题确定自己能通过后，我真的如释重负。 题目并不难，在课下提交截止前找出bug并修复真的是我能通过P5的重要原因。 反思前两题，还可以做得更快。思路清晰，才能更精准更利索。\n上次也说到了，咱们的P6要实现30条指令了！\n具体地说： add, sub, and, or, slt, sltu, lui, addi, andi, ori, lb, lh, lw, sb, sh, sw, mult, multu, div, divu, mfhi, mflo, mthi, mtlo, beq, bne, j, jal, jr, nop\n接下来，我们就开始吧！\n设计文档 本次P6搭建，我还是选择采用边搭建边写设计文档的方法。\n通过记录设计文档来记录我的每一步更改进度，对于P6这种考验严谨性的工程是较有益的。\nP6的主要任务，是在一个相对完善的架构上去增添大量的同类型新指令和少量的特殊指令。\nadd, sub, and, or, slt, sltu, lui,\naddi, andi, ori,\nlb, lh, lw, sb, sh, sw,\nmult, multu, div, divu, mfhi, mflo, mthi, mtlo,\nbeq, bne, j, jal, jr,\nnop\n比较新鲜的指令有set型，字节访存，还有最特别的乘除模块指令！\n我的搭建逻辑是最后处理乘除模块，先搭简单的，或者说白了，先搭非乘除模块（）\n顶层模块的改装 由于P6修改了IM和DM模块，在外部接入指令存储器与数据存储器，并在外部实现写入内容的输出\n对于这些新的接口，\n1 2 3 4 5 6 7 8 9 10 11 input [31:0] i_inst_rdata, input [31:0] m_data_rdata, output [31:0] i_inst_addr, output [31:0] m_data_addr, output [31:0] m_data_wdata, output [3 :0] m_data_byteen, output [31:0] m_inst_addr, output w_grf_we, output [4:0] w_grf_addr, output [31:0] w_grf_wdata, output [31:0] w_inst_addr 为了较少地改动我们的原版CPU，我们采用 assign 顶层输出信号 = 部件输入信号 assign 部件输出信号 = 顶层输入信号 的方式进行书写。\n相当于：本来传给IM,DM部件的信号现在要作为顶层输出信号传给外部IM,DM、 而本来从IM和DM部件得到的数据现在要由外部IM,DM通过顶层输入信号进行赋值。\n其中只有m_data_byteen这一信号是我们从未出现过的，它涉及到了lh,lb,sh,sb四条新指令。\nDM的写 不难设计一个STORE模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 `timescale 1ns / 1ps `define SW 2\u0026#39;b01 `define SH 2\u0026#39;b10 `define SB 2\u0026#39;b11 `default_nettype none module STORE( input wire [1:0] DMWr_M, input wire [31:0] MemAddr_M, output wire [3:0] byteen ); wire half; wire [1:0] by_te; assign half = MemAddr_M[1]; assign by_te = MemAddr_M[1:0]; assign byteen = { ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b1))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b11))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b1))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b10))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b0))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b01))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b0))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b00)))}; endmodule 在顶层,我们可以直接将m_data_byteen与byteen接口相连 也可以新建信号以提高可扩展性\nDM不需要读使能，它始终会读出该地址存储的值，只是后续再通过WdSel来判断你用不用这个信号罢了 而且DM的写使能也很方便实现： |byteen ,将它的各位或起来就可以作为写使能，即存在1就要写。 byteen本身又是控制信号，即哪是1哪被写。\nDM的写就基本完成了 （毕竟功能本身已经由testbench全权负责了）\n! 这样的执行逻辑与MARS是不同的！经过和学长的交流，m_data_wdata跟MemData显然应当是不同的。\n在此加入对MemData做处理的语句，也不难写\n1 2 3 4 5 assign m_data_wdata = (DMWr_M == `LW) ? MemData_M : (DMWr_M == `LH) ? {MemData_M[15:0], MemData_M[15:0]} : (DMWr_M == `LB) ? {MemData_M[7:0], MemData_M[7:0], MemData_M[7:0], MemData_M[7:0]} : 32\u0026#39;b0; DM的读 前文也说到，DM一直会读，但是lw,lh,lb就需要你来处理了。 根据读出的整个字和控制信号，我们可以实现把MemReadData变成正确的值。 相应地，我们需要通过一个模块将m_data_rdata变为MemRead 再将MemRead赋值给MemReadData（同样是为了可扩展性）\n这个模块也很好写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 `timescale 1ns / 1ps `define LW 2\u0026#39;b01 `define LH 2\u0026#39;b10 `define LB 2\u0026#39;b11 `default_nettype none module LOAD( input wire [1:0] DMRd_M, input wire [31:0] m_data_rdata, input wire [31:0] MemAddr_M, output wire [31:0] MemRead ); wire half; wire [1:0] by_te; assign half = MemAddr_M[1]; assign by_te = MemAddr_M[1:0]; assign MemRead = (DMRd_M == `LW) ? m_data_rdata : (DMRd_M == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b1) ? {{16{m_data_rdata[31]}}, m_data_rdata[31:16]} : (DMRd_M == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b0) ? {{16{m_data_rdata[15]}}, m_data_rdata[15:0]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b11) ? {{24{m_data_rdata[31]}}, m_data_rdata[31:24]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b10) ? {{24{m_data_rdata[23]}}, m_data_rdata[23:16]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b01) ? {{24{m_data_rdata[15]}}, m_data_rdata[15:8]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b00) ? {{24{m_data_rdata[7]}}, m_data_rdata[7:0]} : 32\u0026#39;b0; endmodule IM 这个就不用说了，两句话的事\n1 2 assign i_inst_addr = pc_F; assign Instr_F = i_inst_rdata; sh,sb,lh,lb 做事做到底，就把他们直接都写完吧\n书写逻辑： 1.CTRL各项控制信号添加 (和lw，sw完全对应一致) 2.CTRL中Tuse,Tnew (和lw，sw完全对应一致) 3.具体实现（已完成）\n简单的E级ALU写数指令 这类指令也很简单，在此也只有两类： add型: add, sub, and, or ori型：addi, andi, ori （在此add型再添加：slt, sltu 原因在下一小节\n读两个数 算一个数 也就是add型指令 把它归为同一类的原因，主要是控制信号过于相似： 相同调控（置相同的数）的信号有：WrSel, RFWr, Tuse_rs, Tuse_rt, Tnew_D 特异性的信号是ALUOp,用宏定义增强可读性\n书写时要额外注意slt和sltu\n1 2 3 assign slt = ($signed(num_1) \u0026lt; $signed(num_2)) ? $signed(1) : $signed(0); // 1和0是有符号数。但我还是保险起见 assign sltu = (num_1 \u0026lt; num_2) ? 32\u0026#39;b1 : 32\u0026#39;b0; // 32\u0026#39;b1和32\u0026#39;b0都是无符号数 读一个数 拿一个立即数 算一个数 也就是ori型指令 其实和上一类很像，不过区别在于： num_2是IMM_32而非V2 写的寄存器是rt而非rd 相同调控（置相同的数）的信号有：RFWr, ImmSel, Tuse_rs, Tuse_rt, Tnew_D ！特异性： ADDI是符号扩展 ,ORI,ANDI是零扩展\nD级算数指令 真的要在D级算数？ 这是我之前从未触及的一个点。在此，为提高效率，我将冒险进行优化： 这类指令有slt, sltu, lui, jal 把它们前移至D级改变了两件事：Tnew降低、Tuse降低 我之前并没有写过E-D转发，使得lui和jal的Tnew均为1 经过优化，他们的Tnew可以变成0，从而避免后续指令被阻塞 但他们也有风险：风险就是Tuse降低使得他们本身的操之过急可能会使自己被阻塞\n事实上，lui和jal是直接对立即数操作，因此并没有Tuse的风险问题。 而slt和sltu则有风险。\n因此我将slt和sltu放回了简单的E级ALU写数指令。\nlui 和 jal 的 E-\u0026gt;D转发 接下来先说说我对lui和jal的改进吧。 首先，jal的转发十分简单，只要当A1(A2)等于31且Link_E时把pc+8传过去而已。 jal在后面把这个值选择赋给了ALUData_E_True,即\n1 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : ALUData_E; 那么相应地，lui的转发也可以很简单。 真正要写入寄存器的lui的值当然还是ALU算出来的，相当于节省了把这个值选择赋给ALUData_E_True的过程。 lui未曾有的，是他的独特信号，即Lui lui要转发的值，就是{IMM32_E[15:0], 16\u0026rsquo;b0} 由于后续由ALU承包，Lui信号只需要坚持到E-\u0026gt;D转发就够了 可知我们需要改动CTRL，D_E这两个子模块。\n那么咱们的成效就要显露出来了： 那就是减少阻塞！Tnew降为0！\n在CTRL中更改Tnew信号后，这一段路，也算是走完了。\n跳转指令 增添的新指令是bne 已经可以称得上和beq完全一致了吧\u0026hellip;\n主要差别只在于zero和!zero 相同调控（置相同的数）的信号有：PCSel, Tuse_rs, Tuse_rt, (Tnew都不存在)\n不过bne和beq要区分，所以还是需要有控制信号传出来。\n主要就是NPC引入新接口bne,参与了npc的计算罢了\n1 ((beq \u0026amp;\u0026amp; zero) || (bne \u0026amp;\u0026amp; !zero)) ? br_pc : pc_D + 32\u0026#39;d8; 接下来，剩下的8个乘除模块指令，就要从零建起了。\n乘除模块 乘除模块共8条指令 mult, multu, div, divu, mfhi, mflo, mthi, mtlo\nMDALU模块 我们可以构建模块MDALU 接口如下所示：\n名称 位宽 方向 clk 1 I reset 1 I MDALUOp 4 I num_1 32 I num_2 32 I start_busy 1 O busy 1 O HI 32 O LO 32 O clk和reset的功能就不多说了，要清空所有寄存器 start_busy:得知指令为 mult,multu,div,divu，引发运算，阻塞与busy （在start_busy的时候就要为下一周期阻塞了，再不阻塞E级就要进来新指令了）\nMDALUOp:控制信号\n1 2 3 4 5 6 7 8 assign MDALUOp = mult ? `MULT : multu ? `MULTU : div ? `DIV : divu ? `DIVU : mfhi ? `MFHI : mflo ? `MFLO : mthi ? `MTHI : mtlo ? `MTLO : `NONE; busy：这个可以说是最重要的一个点。 在busy状态下，我们要进行阻塞，Pc、F_D级不动，D_E级清空，E级及以后顺延运算。 问题的关键在于： 如何控制busy时间？\n以乘法为例： 每个时钟上升沿，start_busy信号为1时，给cnt归0，给busy赋1，算出LO，HI要被赋的值（现在再不算，等会阻塞的时候E级都清空了） (由于非阻塞赋值，在下一时钟上升沿cnt = 0, busy = 1)\nbusy为1时，\n若cnt == 4，busy和cnt清零，并对regHI，regLO赋值 (由于非阻塞赋值，第五个时钟周期开始时cnt刚被赋值为4， 那么下一个时钟上升沿是busy和cnt都清零，regHI和regLO被赋值， assign语句的即时性使得HI与LO直接出值) 否则cnt++ 指令的控制信号 这八条指令除了MDALUOp以外，也有其对应的控制信号要处理。\nmult,multu,div,divu是完全同质的指令。 特点是读GRF，直接写HI,LO，不写GRF和DM 可以归纳其控制信号RFWr = DMWr = DMRd = 0; ImmSel = 0;运算数都是寄存器\nTuse_rs = Tuse_rt = 3\u0026rsquo;b1;\n乘除法的Tnew不必担心： 得出结果就直接塞到寄存器里了 新指令一旦进来，就说明我的regHI和regLO已经写好了 转发都不用，更别说阻塞了\n再说了，乘除法不差你这一点阻塞，本身阻塞的也够多了（）\nmfhi,mflo是一个访存指令。 要读HI,LO，写GRF 这考虑的就要多了。\n首先，它写GRF，就决定了它需要去转发： 指令的Tnew = 1,可进行M-\u0026gt;D,M-\u0026gt;E的转发。 我们当然可以直接把它加入ALUData_E_true(像当初pc+8那样)\n其次，写要写到哪：rd 那么WrSel要置1\n另外，写当然需要写使能：RFWr = 1\nmthi,mtlo要对HI和LO进行写 要读GRF 写HI,LO\n那么其实这和第一类指令很相似 不写GRF和DM，控制信号RFWr = DMWr = DMRd = 0; ImmSel = 0;运算数都是寄存器 特点是Tuse_rs = 3\u0026rsquo;b1; 但是不需要读GRF[rt]\n同样类似地，它的值也是即拿即写 不需要转发与阻塞\n指令在模块内的书写 前四条已经较详细地描述过了 但在实际书写上，还是存在一定问题： 1. 在阻塞之后，什么值都丢了，那么你就必须有自己预先存好的Op，预先存好的计算结果，才能使得你这个周期还能按着原来的指令的轨迹去走。 但是，op你应该怎么存？ 这至少需要一个时钟周期去存它，那么如果你只根据Op判断，你就已经丢失了一个时钟周期。不仅如此，对于一个周期就能完成的mf,ml指令而言，这更是荒唐。 因此，我目前的写法是不仅对Op写case语句，还对MDALUOp写case语句。 那么，Op的控制也应更加严格，即执行完语句后，应把Op置为`NONE。 （注意：default的情况不要对Op处理！因为default可能是还没来得及赋值的Op,这下好了，同一上升沿两次赋值）\n符号乘法要怎么写？ 鉴于曾经在这里WA过一发，我在此直接给出写法：\n1 {tempHI, tempLO} \u0026lt;= $signed(num_1) * $signed(num_2); 就这么简单。不要担心位宽不一致。它会自动扩展。\nmf指令是一个读HI，LO指令，而我们的HI与LO本就一直在输出。 只需要MDALUOp的控制信号管理一下ALUData_E_true的选择即可。\nmt指令为写HI，LO指令，直接在case语句里面写寄存器就行。 ！！这里要注意，我们写HI，LO寄存器其实是在下一时钟周期才完成的 因此有人会担心，如果下一条指令就要读HI，LO会不会出错误？ 答案是不会。因为我们的assign一直在输出，HI,LO被写之后拿出来的数肯定是对的。\n曾经又在这里WA过一发：mt指令读的都是rs!!!\n模块在顶层的书写 作为少有的要改动顶层模块的设计 首先要注意先前所提到的 mf指令涉及到的写寄存器与转发的问题，都需要靠ALUData_E_true来解决\n1 2 3 4 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : (MDALUOp_E == `MFHI) ? HI : (MDALUOp_E == `MFLO) ? LO : ALUData_E; 当然还有模块本身的接口及其信息传递\n另外要注意的就是阻塞： 阻塞实际上也就是多或上了两个信号start_busy和busy信号 并非如此！ 阻塞应该或上start_busy信号清空E级倒没错（防止ALUOp不变回0引发两个case语句都被执行） 但是busy信号应当与MDALUOp_E与起来再或 因为乘除的结果放进HI，LO里是不影响其他指令的进行的，只有遇到与HI,LO相关的语句，我们才有阻塞的必要。 通过这样优化，大大降低了阻塞率。\n那么接下来的，就是大量指令引发的巨量测试。\n测试文档 单个指令的测试 对于新加入的指令本身，我们需要进行一次较为彻底的测试。\n一是功能本身的基础是否实现，二是一些特殊情况需要验证。\n首先是lh,lb,sh,sb指令： 侧重对符号扩展的测试\n对于add, sub, and, or, slt, sltu, lui, addi, andi, ori 要注意addi的符号扩展是否做到\n对于bne就正常测试成功or失败跳转即可\n对于乘除法模块则也要注意符号问题\n这一层次的测试基本上是用于debug的，因为只涉及自身功能，不涉及冒险，课下的弱测强度基本足够了。\n当然还是建议自行做足测试的。\n指令之间的冲突处理 利用思考题处的表格自行构造样例，再结合评测机进行测试。\n我决定写多个小型测试，对各种转发与阻塞的情况编写特别代码来检测结果。在此不便展示。\n思考题 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？\n因为乘除法部件的运算逻辑与读写数据都与ALU截然不同。 首先，乘除法的高强度阻塞与特别的时序逻辑决定了他不能和组合逻辑直接混用。\n乘除法模块中计算指令就不说了，mf指令是组合逻辑assign，mt指令是写寄存器的时序逻辑。这和原ALU是不太兼容的。\n其次，HI，LO寄存器也只有MDALU能用到，和ALU混用，就提高了内部耦合度，显得混乱。\n这么做，把计算分为ALU和MDALU，最后再进行选择，其实相当于是形成了一个更大的ALU，含有原ALU和MDALU。因此，单独的乘除法部件更好地做到了“高内聚，低耦合”。\n最大的好处：先前没有理解好乘除法的阻塞，事实上，只要乘除法运算过程中没有与乘除类有关的指令，就不需要阻塞。那咱们的效率可谓是大大提升了。\n独立的HI,LO： 首先，HI,LO有其自身特殊性，不能被直接读，只能靠mf指令读。 其次，把HI，LO放在E区，与其他寄存器分离开来，能够实现即出即写，避免了读写冲突。\n真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。\n经过资料查阅，在真实的流水线CPU中，32位乘法是分部分计算的，一个周期可以32位对8位数的乘法（？），然后4个周期能算完。 除法据说是用试商法，一次试4位，8个周期做完除法。\n请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？\nstart可以引发busy，而start和busy都能导致阻塞。 通过计数器控制阻塞周期数，在最后一周期，清空busy,cnt，并完成寄存器赋值。 由于阻塞清空了E寄存器，我将MDALUOp和运算结果进行了及时存储。当然，在最后一周期，这些存储的信号也要清空。\n请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）\n清晰性： 提前将DMWr和addr共同作用的结果算出来，清晰明了地表达了究竟要写哪些字节，对每个字节执行独立的赋值。\n统一性： sw,sh,sb都能用同样的按字节赋值的逻辑来执行。 不过需要被写数据要进行一些预处理：\n1 2 3 4 5 assign m_data_wdata = (DMWr_M == `LW) ? MemData_M : (DMWr_M == `LH) ? {MemData_M[15:0], MemData_M[15:0]} : (DMWr_M == `LB) ? {MemData_M[7:0], MemData_M[7:0], MemData_M[7:0], MemData_M[7:0]} : 32\u0026#39;b0; 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？\n写入DM的确实只写了一个字节 但从DM获取的是一整个字，要经过后续处理\n执行lw和sw时当然还是按字读写更快 但是执行对半字与字节的操作时，按字节读写效率更高\n为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？\n抽象： 我对指令进行了归类，如设计文档所示。并按类地添加和处理指令 最显著的作用如DMRd,DMWr,ALUOp,MDALUOp等等，单个多位信号传入流水线寄存器，相较于多个单位信号是更方便的。\n规范： 对于同一类指令，可以对其先归为一类，再统一为控制信号赋值 （其实也没简单太多，比如addi这种符号扩展，还要单独写）\n帮助： 在译码和处理数据冲突的时候也就是在CTRL内，按类调整控制信号与T信号，省时省力\n在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？\n新的冲突只有数据冒险。处理方法也别无二致。\n阻塞： 我在修改CTRL的时候，已经为各个指令赋好了Tuse_rs,Tuse_rt,Tnew，阻塞正常进行\n转发：\n新添的所有指令中，需要的位点没有改变：V1_D,V2_D,num_1,num_2（此处忽略lh,lb.sh,sb） 新添的所有指令中，写寄存器的内容：大多都还是原来的路径，除了M级有新数据：即来自LO,HI的新数据。（要知道乘除运算指令本身是不写GRF的） 对于这个的处理前文也有提及：\n1 2 3 4 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : (MDALUOp_E == `MFHI) ? HI : (MDALUOp_E == `MFLO) ? LO : ALUData_E; 对于这个改动的测试样例：\n1 2 3 4 5 6 7 8 9 10 11 ... mult $s1, $s2 mfhi $t0 ## 写$t0 add $t1, $t0, $t0 ## 读$t0，M-\u0026gt;E需转发，写$t1 mtlo $t1 ## 读$t1，M-\u0026gt;E需转发 mflo $t2 ## 写$t2 add $t3 $t2 $t2 ## 读$t2，M-\u0026gt;E需转发，写$t3 mthi $t3 ## 读$t3，M-\u0026gt;E需转发 mfhi $t4 ## 写$t4 sw $t4 0($0) ## 读$t4，M-\u0026gt;E需转发 lw $t5 0($0) ## 写$t5 这个样例过多测试了M-\u0026gt;E转发，下面补充一个M-\u0026gt;D转发\n1 2 3 4 5 6 mtlo $t5 ## 读$t5 mflo $t6 ## 写$t6 label: or $t6 $t6 $0 ## 表示正在死循环 bne $0 $t6 label ## M-\u0026gt;D转发 nop 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。\n我采用了手动构造法。 通过建立策略矩阵，按照T的关系来进行构造 具体分类方式如下图所示：\n这两张图还需添加关于lui和mf指令的测试，单独对这两个指令构造测试也是可行的。\n","date":"2024-11-14T14:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p6-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA2/Der_Richter_hu1678884075292437805.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p6-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA2/","title":"北航CO P6 流水线CPU搭建（2）"},{"content":" 说在前面 这周真的太忙了。 不说流水线和数竞这两块大骨头，硬控两小时的党课，硬控两小时的挑战杯志愿者，硬控一小时的组会，硬控五小时的毛概PPT\u0026hellip;\n虽说这周还买了曲包摘了星\n但是流水线CPU真难写。 读者可以看看我写设计文档心境的变化。\n（提交截止前2h突然发现bug。。5点半硬控到7点去上党课）\n为什么说这是流水线的（1）呢？ 因为目前还只有10条指令。流水线（2）是P6，30条指令的事了。\n那么，请君观之。\n设计文档 流水线的设计与单周期的区别主要是两点：\n流水线寄存器的插入 冒险的处理 这两点说起来轻轻松松，但实操起来实在繁杂。\n在漫无目的地发愣了很久之后，我决心要先写出一篇设计文档，把思路理清了再去书写。\n发愣的核心原因在于总感觉自己处理不好寄存器要放什么，谁应该在哪个区（浅显的思考当然不能处理好）\n有的时候更是连第一步没想好就忙着转发阻塞什么的\n哪怕后续转发的时候再优化，现在把需求理清，车间划好，才能想下一步迈进。\n流水线寄存器 要将原来的单周期分割为五个周期，具体是什么样呢\n首先，我想理清楚有哪些操作\n(我最不明白的就是回环：NPC，GRF)\nF pc出值给IM\nIM出指令\npc+4得更新到pc\n这是一个恶心的点，使得你现在就必须考虑延迟槽的问题\n所有不是pc+4的npc，都是经过跳转的\n所有要跳转的，都要用延迟槽\n所有用延迟槽的，都要先执行pc+4，因为跳转结果在第二周期才得出来（哪怕你提前得出来了你也得等延迟槽！！）\n所以跳转结果是在下一个周期才赋值，是一种特殊的赋值\n所以pc应当默认使用pc+4，除非有NPC算出的东西进来\n这个控制信号应当是任何跳转语句都能引发，我称之为not_pc_4\n这个信号作用于PC，所以还是称它为PCSel吧\nPCSel为1的条件就是所有跳转语句\n这个信号在什么时候产生呢？\n肯定已经到D阶段了\nbeq在F阶段，此时PCSel仍为0 （因为跳转语句不在延迟槽，这一句不是延迟槽，则上一句不是跳转，则PCSel为0）\nbeq在D阶段，延迟槽语句在F阶段 这时候PCSel为1\n因此下一个pc将是跳转的结果，没有问题！\nPCSel产生即使用，不经过流水线（虽然他其实能够在F阶段就拿出来，但是拿出来也要流水到下一周期才能用。此外译码一般都放在D级）\n顺便谈到zero\nzero经过提前到D级后，也是即拿即用，不需要经过流水线\npc，Instr都给 F_D\nF_D拿到指令\nF_D 存储PC和Instr（这很简单）\nD 好，接下来看这条指令在D阶段要干些什么\nD阶段最核心莫过于GRF\n但是其他内容也都同等重要\n首先是先前提到过的 NPC和CMP\n单独搞一个CMP出来据说是为了解决P6大量branch语句\n这个阶段要给imm_16变成IMM_32, imm_16已经没用了吗？要把它加入流水吗？\n我想了一想，应该是不会再用了\n但是，为了可扩展性，要不要把他一直存着呢？我觉得还是存着吧。\n但我又想到，到时候哪怕用imm_16，直接从IMM_32里面取不就行了？所以完全没必要存。\nimm_26是j型指令，感觉存着也没用，毕竟即拿即用，得赶快给PC送过去呢！\n好的，那这个阶段把imm_16也解决掉了\n剩下最后一个，就是GRF了！\n读什么？读rs,rt呗还能读谁\n这个阶段又不写。所以rd目前也没什么用。\n是不是要注意GRF的A3选择的时候是rd_W,rt_W这些？\n对！写的时候那个pc也得是pc_W？\n关于W阶段啥东西都应该是W？\n想太多了！到时候再说！现在只考虑D级！\nD_E 存储很多很多东西 还有用的控制信号（EXT，J，Jr当场使用了） 还有用的数据（imm_16和imm_26都没用了） 当然还有pc\n多存点吧，说不好就有用呢\nE 好嘞，该读的信息都读了，该处理的信息也处理了\n下面就是执行操作了\n关键的内容还是ALU\n而ALU的核心就是各个东西都是E\n（为什么这个模块异常的简单？）\nE_M 还是一个基本问题，后面需要什么\n要传递过去的信号，也要传递新生成的数据\npc是当然的 后面有Mem取数和Write回写 需要Mem写的地址，写的内容，GRF写的地址，写的内容 还有他们的读写使能\n别忘了还要传递ALUData信息\nM 整体和单周期也基本没有区别\nM_W 我的建议是别删\n没有什么理由。 就先别删吧\u0026hellip;\n添加MemReadData_M MemData_M和Mem_Addr_M也带上吧\nW 回到GRF\n该用W的都用上W即可\n意外地快。 不处理冒险的数据通路搭好了？？\n冒险处理 我自己也没想到已经走到了这一步。 这一基础性的工作就这样被我搁置了这么久。 其实，接下来才是核心。\n转发和阻塞！！！\n转发 首先要构建好转发的所有路径 转发的核心矛盾，是读了还没写的东西 （一定要注意0号寄存器！写进去了也还是0，因此不能转发）\n我在这里直接考虑所有路径\n指令 F D E M W add,sub 取指令 取rs,rt 算数 得到数据进行转发rd 写数rd ori,lui 取指令,扩展imm 取rs 算数 得到数据转发rt 写数rt lw 取指令，扩展imm 取base，rt 算数 寻址取数 得到数据转发rt，写数rt sw 取指令，扩展imm 取base，rt 算数 寻址存数 无 j 取指令，扩展imm 算出NPC延迟槽后用 无 无 无 jal 取指令，扩展imm 算出NPC延迟槽后用，算出PC_8 可转发（但没人需要） 可转发 可转发，写数$31 jr 取指令 读rs并给NPC 无 无 无 举个例子add 例如我们add读寄存器值的时候可能数据还没出来，但是真正要用到的时候其实在ALU 因此使用时间在E级。\n在此诠释Tnew的定义：最早的可转发时间。也就是正确数据已产出，且存在转发通路。\n我在此分如下几类指令：\nR型读2求1型 rs与rt要读，正常转发 Tuse_rs = 1（ALU的时候有就行） Tuse_rt = 1（ALU的时候有就行） Tnew 初始（即相对于E）= 1 (M才能开转) RegAddr 现场算\nI型拿1读1求1型 rs 要读，正常转发 Tuse_rs = 1（ALU的时候有就行） Tuse_rt = inf imm正常传，传到了num_2,因此rt的值在E级要额外存为V2_E_Data\nTnew 初始 = 1 (M才能开转)\n读寄存器跳转型 说白了就是jr（） Tuse_rs = 0 !!! Tuse_rt = inf 所有跳转的特点都在于其必须在D级得出跳转结果。 而jr就必须从V1_D拿到完全正确的值 因此E-\u0026gt;D的转发是有益的 （但从E开始的转发需要是在D级就得出结果的指令（不经过ALU）） 符合条件的并不多。 我暂时采用阻塞。\n直接跳转型 j不必多说 Tuse_rs = inf Tuse_rt = inf\nRFWr = 0\n条件跳转型 beq。关键在于br和zero两个指令。 其中zero同样要保证在D级算对！必须拿到对的值。 拿不到？我也先采用阻塞。\nTuse_rs = 0 Tuse_rt = 0 RFWr = 0\nLink型 典例jal Tnew = 0 !!!!!(不过我还是把它当做Tnew = 1来用) Tuse_rs = inf Tuse_rt = inf\nE级就能用。因此E-\u0026gt;D这条转发路径是有益的。我目前先用了阻塞。 写$ra太慢了！必须转发！ 该怎么转？能在M和W转。（E也能转） 一定要注意：一旦选择转它，你要拿他去覆盖转的值！！\n1 2 wire [31:0] ALUData_E_true; assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : ALUData_E; 这个ALUData_E_true直接传进流水线E_M和M_W， 即如果本指令为Link型，你就只能读到这一个$31数！\n条件跳转Link型 最关键的便是不跳转，就不Link！ 比如beqal，其link信号应为beqal\u0026amp;\u0026amp;zero(传Link信号的时候就控制好)\nL型 rs rt 正常获取转发 Tuse_rs = 1 Tuse_rt = inf(看题意新指令会不会特殊条件使用rt) imm正常扩展\nALU算的值会在M级被转发！！ 但是在W级正确的值还会被转发过去。\n准确来说，阻塞逻辑就是为了保证你要用的时候一定能拿到正确的值，无论这中间发生过什么。\n因为你的Tnew就是正确数据生成时间，Tuse就是使用时间。\n如果传过去被使用的是错误数据，那就说明正确数据还没被生成，也就是说这条指令是满足阻塞条件的。所以根本不会出现这种情况。\nTnew = 2 最慢！！！（一直到M级取出来，W级才能用）\nS型 Tuse_rs = 1, 在E级需要算对数rs， Tuse_rt = 2，在M级需要有正确的寄存器值rt RFWr = 0 Tnew = 0，不对寄存器进行写\n转发路径共四条： M-\u0026gt;D 传ALUData_M(经过pc+4和ALUData的选择) RegAddr_M跟A1A2比 W-\u0026gt;D 传RegData(经过MemReadData_W和ALUData_W的选择) RegAdde_W跟A1A2比 M-\u0026gt;E 传ALUData_M(经过pc+4和ALUData的选择) RegAddr_M跟rs_E rt_E比 W-\u0026gt;E 传RegData(经过MemReadData_W和ALUData_W的选择) RegAddr_W跟rs_E rt_E比\n为什么没有到M的转发？ 因为M级使用即Tuse = 2,而Tnew没有大于2的（Tnew = 3即W级才产出数据。这显然是荒谬的）\n事实上，W-\u0026gt;M 是必要的！！ 让我来进行解释：如果你写了Tnew=2，那你就表明了自己能在W级转发数据，怎么能不写W级转发通路呢？ 咱们在编写Tnew的时候，一定要和我们能实现的转发通路一一对应。 只有在你做到能转则转的情况下，你才能说Tnew是正确数据的最早生成时间。 否则，你的效率会更低，且你需要修改你的Tnew表。 为什么没有E-\u0026gt;D的转发？ E-\u0026gt;D 即 Tnew = 0 且 Tuse = 0，满足需求只有jal（lui也可以。但是我已经把他塞进ALU了） 但是我还没写。 因此Tnew = 1，要阻塞。\n从这里也能看出来Tnew和转发通路的关系\n阻塞 我们采用把阻塞控制在D阶段完成的方法。 Tuse:在D级的时候，读寄存器的最晚周期与D级的差 Tnew_X:X周期的指令要写的内容能够转发出去的最早周期与E级的差 （在周期A算出来，则可以在周期A+1转发）\n我们需要考虑D与E关系，D与M关系 为什么不考虑D与W关系？？ 因为Tnew_W一定为0了（谁家指令在W级还没算出来数（笑））\n对于两个阻塞的关系，我们采用暴力地或起来 一条通道可能不通就阻塞。\n这可能确实有点暴力，但我也确实没什么精力去优化描述，以更好地处理例如 lw $31, 0($0) jal label add $t0, $31, $31 这样的情况。这种情况原则上jal转发优先级更高，他还更快，所以如果他有正确的值且寄存器匹配且不为0且T关系等等就可以不管lw的感受。 我没管那么多。\n阻塞只需满足:\n确实发生读写冲突且来不及转发（Tuse \u0026lt; Tnew） 我们先分为rs冲突与rt冲突\n1 assign stall = stall_rs || stall_rt; 然后以rs为例：\nstall_rs = stall_rs_DE || stall_rs_DM\n以stall_rs_DE为例：\n确实发生读写冲突： (rs_D（即A1）== RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026rsquo;b0) 且 \u0026amp;\u0026amp; 来不及转发： (Tuse_rs \u0026lt; Tnew_E)\n所以\n1 2 3 4 stall = ((A1 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_E)) || ((A1 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_M)) || ((A2 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_E)) || ((A2 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_M)); 接下来，只需对 Tuse 和 Tnew_X 下定义：\n功能还在CTRL中实现: 因为我要用指令来描绘 Tnew 和 Tuse_rs 和 Tuse_rt\n指令 Tnew Tuse_rs Tuse_rt add 1 1 1 sub 1 1 1 ori 1 1 5 lui 1(个人原因) 5 5 beq 无(0) 0 0 jr 无(0) 0 5 jal 1(不转发导致的) 5 5 lw 2 1 无(5) sw 无(0) 1 2 Tuse 直接生成 Tnew_X 初值生成，递减操作\n递减操作的实现： 放进流水线嘛，过个周期减一下\n测试文档 刚搭完流水线寄存器，出来一堆compile bug 或多或少的少加控制信号，打错字什么的。。 然后运行了充斥着nop的代码，没什么问题。\n然后就向Hazard进军了！\nHazard测试的编写很有针对性。 前提是你要针对好所有的代码情况，事先分析好Tnew,Tuse关系 才能模拟出所有的冒险。 所有的转发，所有的阻塞，都要到位。\n思考题 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。\nbeq提前使得其Tuse降为0，这无疑提高了阻塞率。 当这条指令前面是Tnew = 1的add,sub,ori等等均阻塞\n用原来的方法，虽有可能损失更大，但是也存在很多无损失的情况。提前分支判断则是较为稳定的损失。\n举例：\n1 2 add $16 $16 $16 beq $16 $0 label 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？\n正因题意所说，因为延迟槽的存在，jal语句后的那条指令是已被执行的，跳转回来时当然要跨过延迟槽这句话\n我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？\n功能部件本就耗时，如果再加上转发逻辑，二者必定是顺序关系，导致时钟周期长度增长，频率上限降低，效率也就低了。 但是如果在下一周期，转发操作和下一周期的操作是独立并行的，不影响执行速度。\n我们为什么要使用 GPR 内部转发？该如何实现？\nGRF内部转发本质上是W到D的转发，只是W和D用了同一个部件 有同学使用了negedge的办法进行W，这样posedge读的时候就一定已经被新值写入。\n我采用了传统转发。无非转发的值是RegData_W,参与判断的是RegAddr_W罢了。\n我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？\n需求者严格意义上有很多，不过他们是可以合并的。 所有需要使用或传递的部件，都是需求者。 但是我们可以先进行转发，再把结果给需求者们。 总体来说，需求者可以是CMP的两个数，ALU的两个数，D_E和E_M流水线寄存器。\n需求者还有M级 sw时RD2的值！！！！！需要换上最新数据！！！\n供给者我们都安排到流水线寄存器的输出。 M级的数据可以是ALUData,Pc+8 W级的数据可以是MemReadData,ALUData,Pc+8\n前文也提到了，E到D的转发尚未考虑。\n因此，共有M-\u0026gt;D，M-\u0026gt;E，W-\u0026gt;D，W-\u0026gt;E，W-\u0026gt;M五种。 （以及E-\u0026gt;D）（6种）\n!!刚de出的bug!!!还有W-\u0026gt;M转发！！！！\n再总结一下所有被转发：\nRD1\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V1_D\u0026mdash;\u0026gt;V1_E\u0026ndash;ME,WE转发\u0026ndash;\u0026gt;num_1\u0026mdash;\u0026gt;运算\nRD2\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V2_D\u0026mdash;\u0026gt;V2_E\u0026ndash;ME,WE转发\u0026ndash;\u0026gt;V2_E_Data\u0026mdash;\u0026gt;V2_M_Data\u0026ndash;WM转发\u0026ndash;\u0026gt;MemData_M\u0026mdash;\u0026gt;被写入\nRD2\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V2_D\u0026mdash;\u0026gt;V2_E\u0026ndash;ME,WE转发、选择\u0026ndash;\u0026gt;num_2\u0026mdash;\u0026gt;运算\n总结一下所有转发：\nM级为ALUData,Pc+8经过选择变为ALUData_true的转发 W级为MemReadData,ALUData,Pc+8经过选择变为RegData的转发\n转发地址为RegAddr已各自计算\n在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。\n这一问题在前文已有谈论。 总结起来，关键还是处理好Tnew,Tuse,读谁，写谁这四个问题 （其中，读谁，写谁都是需要控制信号的） 以及最核心，最有不确定性的“处理”这一部分\n确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。\n我使用的是对控制信号找相关指令的方式。 先由opcode和funct得出结果，再得出指令；接下来由指令得到控制信号。 优势是简洁，不足是容易漏写，错写。 加指令时一定要分析好所有相关信号，再书写。\n","date":"2024-11-10T22:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p5-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA1/292fa3e8c7e86664cbaefef9ddc7893_hu11389104909499974286.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p5-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA1/","title":"北航CO P5 流水线CPU搭建（1）"},{"content":"作业最终的架构设计 经过轮轮迭代，面向对象先导课程也终于走向了尾声。\n关于类 本次迭代任务中，共有24个类被创建：\n他们分别是：\nMainClass: 程序入口，实现数据读入操作和大量核心方法。 Adventurer: 核心操作对象，内含有关Bottle，Equipment，Frag，Employ类的相关容器 Bottle：内设三个子类，HpBottle，AtkBottle，DefBottle Equipment：内设三个子类，Axe，Blade，Sword Frag：表达碎片的相关属性与方法 Employ：表达雇佣关系相关属性与方法 Guard，Treasure及其Factory：秘境探险操作中的新对象 具体属性就不详细说了\n关于容器 在容器上的考虑，值得一提的便是CarriedEquipment。它使用了以name为索引的HashMap，这一方法十分契合题设要求。可惜的是，在处处以id为核心标识的情境，使用以name为索引的方法不可避免地要处理好在carry操作之外的重名问题。\n那便是deleteEquipment()方法在第三次迭代强测中带来的惨痛教训\n关于迭代 迭代式开发的课程，着实是令我耳目一新的。\n第一次迭代 OMG，it\u0026rsquo;s LLM! 从第一次迭代时拙劣地模仿IDEA的LLM，到现在理解较为成熟地模仿LLM，大家每个人的进步都是肉眼可见的。\n第二次迭代\n添加了carry指令。当时没有想太多，直接为装备添加了isCarried属性（谁能想到后面装备还能援助给别人呢（） deleteCommodity()让我开始考虑将Bottle和Equipment结合起来，但其差异仍将大于其共性。 第三次迭代 这次迭代是让我最印象深刻的一次迭代，痛失40分（苦笑 核心要点主要是： 容器重构，carry，frag，fight\n删掉了所有find函数，用上了高效简洁的HashMap carry方法重写，建立了专属容器以存放Carried的物品。关于carriedEquipment以name为索引的潜在问题前面已经提到了。 frag的处理。就忽略id属性这一问题，我认为是合理的。frag的最核心属性就应该是name和count，以同名frag作为一个对象基本单元，在获取数量，消耗数量等操作上都是合理的。不过把id忽略掉这种行为本身，对于整个项目来说，可能还是有一定隐患的。 fight较为简单。强测错因是getAtk()误写成getCe()。 第四次迭代 迭代任务确实一次比一次重\n雇佣关系：建立Employ类，对于一个雇佣关系对象本身管理它的各项属性。这种思想让我缓了很久，万物皆为对象！曾经室友写了一个Fight类，让我懵懂地理解了一下什么是过程对象，如今自己写的时候又更明白何为关系对象。把一场战斗（函数(函数其实也是关系，关系就是有序对)）当作一个对象，它有它的属性，有它的方法；把雇佣关系（有序偶对）作为对象，同样有自己的属性与方法。 递归攻击：倒是一个很容易克服的难点。 秘境探险：更多的是一种思想认知的改变，在具体实现上让我对接口有了新的认识。不同的类可以借助接口同一调用不同内容的方法，确实便利了很多 中测de了半天bug原来错在getComprehensiveCe()也是没谁了（）\n使用JUnit的心得体会 覆盖率是一项任务 起初，我确实没有意识到JUnit的功能。能在运行中构造样例运行出来的结果，为什么还要搞那么复杂去专门去测？我对各个方法进行了无意义的测试，完成了基础任务。\n覆盖率赋予每一行代码意义 自第三次迭代作业开始，加入了分支覆盖率的要求。在我开始思考覆盖率的意义之时，我方才意识到，单元测试之所以是单元测试，便在于它使得代码中各种细微的地方都能被顾及得到。同样，覆盖率也能够帮助我写出更完善的测试代码。\n单元测试，但不仅仅是单元 在单元测试中，我们不仅要编写对于单个方法的测试，更需要对较大的方法进行测试，在大方法中测试小方法相互作用关系的正确性。单元测试中的单元不仅是指最小单元，更是单元之间组合形成的层次化结构单元。\n测试数据构造需要技巧 无论何时，以debug为目的的测试终究是要找到bug。因此要尽力去构造bug相关的测试点，构造较极端的情况进行分析，而不是为了达到覆盖率要求而进行大量的无意义测试。\n学习OOpre的心得体会 以方法为核心的逻辑 在学习C语言的时候，我曾畅想，如果各项基本操作都能靠函数实现，而函数的实现也依靠其他函数，人脑只需负责顶层逻辑，那些条条框框的小方法被封装起来等着用该多好\u0026hellip;\n在OOpre的课程中可谓是函数方法用的最多的一集，有大量好用的被封装好的方法，我只负责对方法进行封装，构造新的方法，再调用方法\u0026hellip; 因此，在debug时，C语言和OOpre两门课带给我的感受是很不一样的。前面是对于方法具体实现细枝末节的深深考究，而OOpre的思路总是流畅贯通，哪里有问题它可以根据逻辑分析直接推理出漏洞\n以对象为主体的视角 这一点，是我在第四次迭代中深刻体悟到的，万物皆为对象。前文已有讲述。\n课程建议 希望可以像CO一样提前有一定的基础知识学习期，提供资料自学容器，子类，接口等内容的基础知识，解决课上刚学会的知识总是不能快速理解运用的问题。\n","date":"2024-11-01T13:30:00+08:00","image":"https://demiurge-zby.github.io/p/oopre%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/d477300c36f0221527b9816c97bed3b_hu13817389781556842652.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/","title":"oopre结课总结"},{"content":" 设计文档 前情提要 本次搭建需要实现的指令有\nadd,sum,ori,lui sw,lw beq jal,jr nop 在此基础之上，本人额外添加了lh,lb,sh,sb,j指令。\nverilog的基本构建思路源始于logisim，Tunnel化的logisim电路为verilog代码的编写提供了很大的便利和可扩展性。\nverilog的编写仍然从数据通路基础部件和控制器两方面来书写，不过额外的是，在mips.v中应当实现所有的基础接线操作。\n或者说，mips.v是最独特的一环。\n一切源代码仅供参考，千万不要抄袭！！\n数据通路的构建 PC PC作为CPU中的时序电路核心器件，其功能实现也较为简单，只有同步复位操作和npc赋值操作。\n直接由logisim文件分析PC模块的接口\n名称 位宽 方向 npc 32 I clk 1 I reset 1 I pc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 `default_nettype none module PC( input wire [31:0] npc, input wire clk, input wire reset, output wire [31:0] pc ); reg [31:0] PCreg; always @(posedge clk) begin if (reset) begin PCreg \u0026lt;= 32\u0026#39;h00003000; end else begin PCreg \u0026lt;= npc; end end assign pc = PCreg; endmodule NPC NPC与P3不同，加入了jal，jr指令，使得其增加了两种全新跳转方式：\n26位立即数经位拼接得到直接地址 32为GRF数据得到直接地址 再加上原来的pc+4与pc+4+sign_ext(imm)\n共有四种跳转逻辑，需要较多的控制信号\nbr 和 zero 控制 相对寻址跳转 j 控制imm_26绝对寻址跳转\njr 控制$ra绝对寻址跳转\n接口信息如下：\n名称 位宽 方向 pc 32 I imm_16 16 I imm_26 26 I reg_ra 32 I br 1 I zero 1 I j 1 I jr 1 I pc_4 32 O npc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 `default_nettype none module NPC( input wire br, input wire zero, input wire [15:0] imm_16, input wire [25:0] imm_26, input wire [31:0] pc, input wire [31:0] reg_ra, input wire j, input wire jr, output wire [31:0] pc_4, output wire [31:0] npc ); wire [31:0] j_pc; wire [31:0] br_pc; assign pc_4 = pc + 32\u0026#39;d4; assign j_pc = {pc[31:28],imm_26,{2{1\u0026#39;b0}}}; assign br_pc = pc_4 + {{15{imm_16[15]}},imm_16[14:0],{2{1\u0026#39;b0}}}; assign npc = (jr) ? reg_ra : (j) ? j_pc : (br \u0026amp;\u0026amp; zero) ? br_pc : pc_4; endmodule IM IM作为需要读取指令的单位，需要调用readmemh\n为了保证读取的正确顺序，定义寄存器堆时使用[0:4095]\n也可以添加参数控制readmemh读取到的起始位置与终止位置\n由于该指令寄存器堆应当存储4096*32bit\n然而起始位置却是0x00003000 因此可以先对pc减去0x00003000\n再取[13:2]作为指令寄存器堆的读取地址\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I Instruction 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 `default_nettype none module IM( input wire [31:0] pc, input wire reset, input wire clk, output wire [31:0] Instruction ); wire [31:0] address; reg [31:0] InstrMemory [0:4095]; always @(posedge clk) begin if(reset) begin $readmemh(\u0026#34;code.txt\u0026#34;, InstrMemory); end end assign address = pc - 32\u0026#39;h00003000; assign Instruction = InstrMemory[address[13:2]]; endmodule EXT 注意位拼接操作的写法！！不能少打大括号\n位拼接“0”时，一定要控制有多少个0\n例如16个“0”,应使用{16{1\u0026rsquo;b0}}或{16\u0026rsquo;b0}\n名称 位宽 方向 EXTOp 1 I imm_16 16 I IMM_32 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `default_nettype none module EXT( input wire EXTOp, input wire [15:0] imm_16, output wire [31:0] IMM_32 ); wire [31:0] signed_IMM; wire [31:0] unsigned_IMM; assign signed_IMM = {{16{imm_16[15]}},imm_16}; assign unsigned_IMM = {{16{1\u0026#39;b0}},imm_16}; assign IMM_32 = EXTOp ? signed_IMM : unsigned_IMM; endmodule GRF GRF的最特殊性在于其0号寄存器\n值不能被改变 始终值为0 在此有两种处理方案\n初始时为所有寄存器赋0\n之后不对0号寄存器进行写入 读0号寄存器时始终输出0 由于个人偏好，希望各个寄存器中的值保持正确，本人采用了第一种写法\n根据题目要求，需要输出寄存器被写时的各项参数，需要将pc传入其中\n接口如下所示：\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I WE 1 I A1 5 I A2 5 I A3 5 I WD 32 I RD1 32 O RD2 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 `default_nettype none module GRF( input wire [31:0] pc, input wire [4:0] A1, input wire [4:0] A2, input wire [4:0] A3, input wire [31:0] WD, input wire reset, input wire clk, input wire WE, output wire [31:0] RD1, output wire [31:0] RD2 ); reg [31:0] grf [31:0]; integer i; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 32;i = i + 1) begin grf[i] \u0026lt;= 32\u0026#39;b0; end end else begin if(WE \u0026amp;\u0026amp; A3) begin grf[A3] \u0026lt;= WD; $display(\u0026#34;@%h: $%d \u0026lt;= %h\u0026#34;, pc, A3, WD); end end end assign RD1 = grf[A1]; assign RD2 = grf[A2]; endmodule ALU 实现基本与logisim同理，但是操作更为简单\n注意使用`define以增强代码可读性\n名称 位宽 方向 ALUOp 2 I num_1 32 I num_2 32 I zero 1 O out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 `default_nettype none `define ADD 2\u0026#39;b00 `define SUB 2\u0026#39;b01 `define ORI 2\u0026#39;b10 `define LUI 2\u0026#39;b11 module ALU( input wire [1:0] ALUOp, input wire [31:0] num_1, input wire [31:0] num_2, output wire zero, output wire [31:0] out ); wire [31:0] add; wire [31:0] sub; wire [31:0] ori; wire [31:0] lui; assign add = num_1 + num_2; assign sub = num_1 - num_2; assign ori = num_1 | num_2; assign lui = {num_2[15:0],{16{1\u0026#39;b0}}}; assign zero = (num_1 == num_2) ? 1\u0026#39;b1 : 1\u0026#39;b0; assign out = (ALUOp == `ADD) ? add : (ALUOp == `SUB) ? sub : (ALUOp == `ORI) ? ori : lui; endmodule DM 仅对于lw和sw而言，DM本应是极为简单的。\n但是正因为sh,sb的特殊性，我尝试了对其功能的描述\nsh,sb指令的核心问题，在于我们不能直接做到针对一个字部分内容的修改\n因为我们的寄存器都是以32bit为单位的 因此我们要先把它所在寄存器的值取出来，进行位拼接操作得到该寄存器应存入的新数，再存入DM之中\n由于添加了指令，我的WE与RE信号都进行了调整\n控制信号取值 含义 00 以w为单位 01 以h为单位 10 以b为单位 11 不予使能 同样地，为了输出中间参数，pc需要被引入。\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 我还添加了word,half,by_te等中间变量，便于我后续的描述\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 `default_nettype none `define SW 2\u0026#39;b00 `define SH 2\u0026#39;b01 `define SB 2\u0026#39;b10 `define LW 2\u0026#39;b00 `define LH 2\u0026#39;b01 `define LB 2\u0026#39;b10 module DM( input wire [31:0] pc, input wire [31:0] data, input wire [31:0] addr, input wire [1:0] WE, input wire [1:0] RE, input wire clk, input wire reset, output wire [31:0] out ); reg [31:0] DataMemory [0:3071]; integer i; wire [11:0] word; wire half; wire [1:0] by_te; assign word = addr[13:2]; assign by_te = addr[1:0]; assign half = addr[1]; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 3072; i = i + 1) begin DataMemory[i] \u0026lt;= 32\u0026#39;b0; end end else begin case (WE) `SW: begin DataMemory[word] \u0026lt;= data; $display(\u0026#34;@%h: *%h \u0026lt;= %h\u0026#34;, pc, addr, data); end `SH: begin case (half) 1\u0026#39;b1: begin DataMemory[word] \u0026lt;= {data[15:0], DataMemory[word][15:0]}; end 1\u0026#39;b0: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[15:0]}; end default: begin end endcase end `SB: begin case (by_te) 2\u0026#39;b11: begin DataMemory[word] \u0026lt;= {data[7:0], DataMemory[word][23:0]}; end 2\u0026#39;b10: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:24], data[7:0], DataMemory[word][15:0]}; end 2\u0026#39;b01: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[7:0], DataMemory[word][7:0]}; end 2\u0026#39;b00: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:8], data[7:0]}; end default: begin end endcase end default: begin end endcase end end assign out = (RE == `LW) ? DataMemory[word] : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b1) ? {{16{DataMemory[word][31]}},DataMemory[word][31:16]} : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b0) ? {{16{DataMemory[word][15]}}, DataMemory[word][15:0]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b11) ? {{24{DataMemory[word][31]}}, DataMemory[word][31:24]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b10) ? {{24{DataMemory[word][23]}}, DataMemory[word][23:16]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b01) ? {{24{DataMemory[word][15]}}, DataMemory[word][15:8]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b00) ? {{24{DataMemory[word][7]}}, DataMemory[word][7:0]} : 32\u0026#39;b0; endmodule 控制器的编写 在搭建数据通路的过程中，控制信号的要求也已经浮出水面。\n关键还是由IM到指令，由指令到控制信号的过程\n不过加入了其他操作，使得DMWr,DMRd发生了一定的改变 以及额外添加的Link,J,Jr等控制信号\n相较于P3的BSel,此处本人将其更名为ImmSel,强调其解决的是立即数与寄存器谁参与ALU运算的问题\n名称 位宽 方向 opcode 6 I funct 6 I Br 1 O EXTOp 1 O RFWr 1 O DMWr 2 O DMRd 2 O ALUOp 2 O WrSel 1 O WdSel 1 O ImmSel 1 O Link 1 O J 1 O Jr 1 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 `default_nettype none module CTRL( input wire [5:0] opcode, input wire [5:0] funct, output wire Br, output wire EXTOp, output wire RFWr, output wire [1:0] DMWr, output wire [1:0] DMRd, output wire [1:0] ALUOp, output wire WrSel, output wire WdSel, output wire ImmSel, output wire Link, output wire J, output wire Jr ); wire add; wire sub; wire ori; wire lui; wire sw; wire sh; wire sb; wire lw; wire lh; wire lb; wire beq; wire j; wire jal; wire jr; wire R; assign R = (opcode == 6\u0026#39;b000000); assign add = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100000); assign sub = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100010); assign jr = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b001000); assign j = (opcode == 6\u0026#39;b000010); assign jal = (opcode == 6\u0026#39;b000011); assign ori = (opcode == 6\u0026#39;b001101); assign lui = (opcode == 6\u0026#39;b001111); assign sw = (opcode == 6\u0026#39;b101011); assign sh = (opcode == 6\u0026#39;b101001); assign sb = (opcode == 6\u0026#39;b101000); assign lw = (opcode == 6\u0026#39;b100011); assign lh = (opcode == 6\u0026#39;b100001); assign lb = (opcode == 6\u0026#39;b100000); assign beq = (opcode == 6\u0026#39;b000100); assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign ImmSel = ori || lui || sw || sh || sb || lw || lh || lb; assign EXTOp = sw || sh || sb || lw || lh || lb; assign ALUOp = sub ? 2\u0026#39;b01 : ori ? 2\u0026#39;b10 : lui ? 2\u0026#39;b11 : 2\u0026#39;b00; assign RFWr = add || sub || ori || lui || lw || lb || lh || jal; assign DMRd = lw ? 2\u0026#39;b00 : lh ? 2\u0026#39;b01 : lb ? 2\u0026#39;b10 : 2\u0026#39;b11; assign DMWr = sw ? 2\u0026#39;b00 : sh ? 2\u0026#39;b01 : sb ? 2\u0026#39;b10 : 2\u0026#39;b11; endmodule mips.v 前面说了那么多，其实都是相对独立的结构 那么接下来，才是verilog描述的独特之处 才能更深刻地展示verilog的抽象功能\n接口十分简单，毕竟真正来自外部的信号只有clk和reset\n名称 位宽 方向 clk 1 I reset 1 I 1 2 3 4 5 `default_nettype none module mips( input wire clk, input wire reset ); 接线逻辑 在我书写这一板块的过程中，我曾选用了将所有的wire先定义好，再全部统一赋值，再逐个接接口的方法\n结果这样导致的问题（或者说我曾经出现的bug） 就是你不能确定你需要的信号都得到了定义与赋值\n因此，我秉承了P3的基本思路，对各个部件的外部接线进行分析。\n分析方法：\n先定义所有需要的输出信号 输入信号分为 直接与其他某部件的输出信号直接相连 由其他部件的输出信号相互作用（计算or选择）得到 为这些相互作用进行assign处理 基础信号 名义上如此，其实这是在模拟我没有模块化的Splitter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 基础信号定义 wire [5:0] opcode; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [4:0] shamt; wire [5:0] funct; assign opcode = Instr[31:26]; assign rs = Instr[25:21]; assign rt = Instr[20:16]; assign rd = Instr[15:11]; assign shamt = Instr[10:6]; assign funct = Instr[5:0]; wire [15:0] imm_16; wire [25:0] imm_26; assign imm_16 = Instr[15:0]; assign imm_26 = Instr[25:0]; CTRL 定义大量控制信号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //控制信号定义 wire Br; wire EXTOp; wire RegWrite; wire [1:0] DMWr; wire [1:0] DMRd; wire [1:0] ALUOp; wire WrSel; wire WdSel; wire ImmSel; wire Link; wire J; wire Jr; CTRL Ctrl( .opcode(opcode), .funct(funct), .Br(Br), .EXTOp(EXTOp), .RFWr(RegWrite), .DMWr(DMWr), .DMRd(DMRd), .ALUOp(ALUOp), .WrSel(WrSel), .WdSel(WdSel), .ImmSel(ImmSel), .Link(Link), .J(J), .Jr(Jr) ); PC 定义输出信号pc\n1 2 3 4 5 6 7 8 // PC 输出信号 wire [31:0] pc; PC Pc( .npc(npc), .clk(clk), .reset(reset), .pc(pc) ); IM 定义输出信号Instr\n1 2 3 4 5 6 7 8 9 10 // IM输出信号 wire [31:0] Instr; IM Im( .pc(pc), .Instruction(Instr), .clk(clk), .reset(reset) ); EXT 定义输出信号IMM_32\n1 2 3 4 5 6 7 8 // EXT输出信号 wire [31:0] IMM_32; EXT Ext( .EXTOp(EXTOp), .imm_16(imm_16), .IMM_32(IMM_32) ); NPC 定义输出信号npc和pc_4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // NPC输出信号 wire [31:0] npc; wire [31:0] pc_4; NPC Npc( .br(Br), .zero(zero), .imm_16(imm_16), .imm_26(imm_26), .pc(pc), .reg_ra(RD1), .j(J), .jr(Jr), .pc_4(pc_4), .npc(npc) ); GRF 定义输出信号RD1,RD2 定义输入信号，并给出其assign语句实现赋值 要知道，输入信号一定要从其他部件的输出信号或者外部的clk 与reset中得到 如果盲目定义输入信号，却不予有意义的赋值，就会产生xxxzzz等问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // GRF 输入信号·中间变量 wire [31:0] LinkPC; wire [4:0] A1; wire [4:0] A2; wire [4:0] RegAddr; wire [31:0] RegData; // GRF 中间变量的赋值 assign LinkPC = pc_4; assign A1 = rs; assign A2 = rt; assign RegAddr = Link ? 5\u0026#39;b11111 : WrSel ? rd : rt; assign RegData = Link ? LinkPC : WdSel ? MemReadData : ALUData; // GRF 输出信号 wire [31:0] RD1; wire [31:0] RD2; GRF Grf( .clk(clk), .reset(reset), .WE(RegWrite), .pc(pc), .A1(A1), .A2(A2), .A3(RegAddr), .WD(RegData), .RD1(RD1), .RD2(RD2) ); ALU 输出信号zero和ALUData\n定义输入信号num_1，num_2并给出assign\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ALU 输入信号·中间变量 wire [31:0] num_1; wire [31:0] num_2; // ALU 中间变量的赋值 assign num_1 = RD1; assign num_2 = ImmSel ? IMM_32 : RD2; // ALU 输出信号 wire zero; wire [31:0] ALUData; ALU Alu( .ALUOp(ALUOp), .num_1(num_1), .num_2(num_2), .zero(zero), .out(ALUData) ); DM 这两个输入变量的赋值是否没有意义？\nMemAddr一定是ALUData?\nMemData一定是RD2?\n可能确实如此。 但是这样的命名使得整体逻辑更为清晰，也增强了可扩展性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // DM 输入信号·中间变量 wire [31:0] MemAddr; wire [31:0] MemData; // DM 中间变量的赋值 assign MemAddr = ALUData; assign MemData = RD2; // DM 输出信号 wire [31:0] MemReadData; DM Dm( .pc(pc), .data(MemData), .addr(MemAddr), .WE(DMWr), .RE(DMRd), .clk(clk), .reset(reset), .out(MemReadData) ); endmodule 测试文档 我仍然采用了对拍的方法，并自行构造了一定数据。\n对于新增指令，我着重加强了对jr,jal的测试\n以下是一组测试数据，重点观察$ra取值的改变是否正常\n1 2 3 4 5 6 7 8 9 0c000c06 // jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f301c //ori $ra, $0, 0x0000301c //label: 03e00008 //jr $ra 03fff820 //add $ra, $ra, $ra 可知$ra会在pc+4和0不断跳转\n直到变为0x0000301c后跳转到add语句变为0x00006038\n下面是我的输出结果，与MIPS结果一致\n1 2 3 4 5 6 7 @00003000: $31 \u0026lt;= 00003004 @00003004: $31 \u0026lt;= 00000000 @00003008: $31 \u0026lt;= 0000300c @0000300c: $31 \u0026lt;= 00000000 @00003010: $31 \u0026lt;= 00003014 @00003014: $31 \u0026lt;= 0000301c @0000301c: $31 \u0026lt;= 00006038 思考题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ?\naddr信号来自于ALU的计算，即GRF[base]+sign_ext(offset) 其中addr[11:2]意为取ALU计算结果从第2位开始的12位数字作为address。 其原因在于对于lw指令，第0位和第1位均为0，自第2位起开始计数才是以32bit为单位，才能与DM寄存器堆的寄存器编号相对应。\n思考两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。\n控制信号每种取值所对应的指令： 举例：\n1 2 3 4 5 6 7 assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign EXTOp = sw || sh || sb || lw || lh || lb; 每条指令对应的控制信号取值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 always@(*) begin case (Operation) `ADD : begin Br = 1\u0026#39;b0; Jr = 1\u0026#39;b0; Link = 1\u0026#39;b0; J = 1\u0026#39;b0; WrSel = 1\u0026#39;b1; ... end ... default : begin end end 分析优劣： 由指令确定其控制信号： 优点：考虑全面，不会有漏掉的指令，对每个指令也不会有漏掉的控制信号 上机新增指令时直接对其分析，一个也不会漏 缺点：代码重复冗长 产生新的控制信号时还需要对每个指令都加句话\n对控制信号归纳其生效指令： 优点：本质上是上一种方法的总结归纳，代码量少 缺点：自行归纳时某些控制信号可能会忘记考虑一些指令\nPS：解决方法：对新指令在演草纸上进行所有控制信号枚举，之后再进行归纳，用于代码书写\n在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。\n同步复位：clk优先（还必须得是上升沿） 异步复位：reset优先\nC 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。\n1 2 if temp32 ≠ temp31 then SignalException(IntegerOverflow) 这是add和addu、addi和addiu的唯一区别 u的本意即为不考虑输出 那在忽略输出的前提下自然就等价了。\n","date":"2024-10-31T14:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p4-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/292fa3e8c7e86664cbaefef9ddc7893_hu9110516496620476980.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p4-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/","title":"北航CO P4 单周期CPU的verilog搭建"},{"content":"序列输入之数据特征分析 数据类型 不作介绍 关系 顺序关系 依次赋值 层次关系（赋值的所属对象） 1 2 3 4 5 6 7 8 Scanner scanner = new Scanner(System.in); int i; int n = scanner.nextInt(); for(i = 0; i \u0026lt; n; i++){ id = scanner.nextInt(); name = scanner.next();// id 与 name之间为顺序关系 // 不同组之间形成不同层次 } 结构 硬编码式的解析处理 较为简单，确定的输入方式 缺点：兼容性灵活性差 使用正则表达式的解析处理 可对应一个有穷自动机解析 默认使用贪婪匹配\n\u0026ldquo;.\u0026rdquo; 任意\n\u0026ldquo;*\u0026rdquo; 同一项内容任意项\n\u0026ldquo;+\u0026rdquo; 同一内容一项或多项\n\u0026ldquo;?\u0026rdquo; 同一内容零项或一项\n非贪婪匹配\n```java Pattern = new Pattern.compile(\u0026quot;(\\\\w+?)((good)*)\u0026quot;); // 添加 \\w+? 实现非贪婪 // 注意 \\\\ 编译问题 ``` 弊端：可读性差，技巧性高\n递归下降式解析处理 递归 借助递归进行解析 下降 从顶层到底层 按层解析 文法 终结符 取值不可变的符号，单个字符层级上的元素 非终结符 取值可变，以\u0026lt;\u0026gt;表示 定义规则 L -\u0026gt; R\n定义非终结符的取值方式\n1 2 3 4 5 \u0026lt;Var\u0026gt; -\u0026gt; \u0026lt;digit\u0026gt; | \u0026lt;Const\u0026gt; \u0026lt;Var\u0026gt; //递归下降 无限循环 \u0026lt;Const\u0026gt; -\u0026gt; \u0026lt;op\u0026gt; | \u0026lt;digit\u0026gt; \u0026lt;op\u0026gt; \u0026lt;digit\u0026gt; -\u0026gt; \u0026#39;0\u0026#39;|\u0026#39;1\u0026#39;|\u0026#39;2\u0026#39;|\u0026#39;3\u0026#39;|\u0026#39;4\u0026#39;|\u0026#39;5\u0026#39;|\u0026#39;6\u0026#39;|\u0026#39;7\u0026#39;|\u0026#39;8\u0026#39;|\u0026#39;9\u0026#39; \u0026lt;op\u0026gt; -\u0026gt; \u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;|\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39; // \u0026#39;+\u0026#39;为终结符，\u0026lt;op\u0026gt;,\u0026lt;Const\u0026gt;为非终结符 词法分析：定义Token 1 2 3 4 5 public class Token{ private String name; private Type type; // ... } //实现了一种抽象 语法分析：建立抽象语法树 根据文法所定义的关系\n1 2 3 4 5 public class Var{ private Arraylist\u0026lt;digit\u0026gt;; private Arraylist\u0026lt;op\u0026gt;; // ... } // 在表达树的方面降了一层 由表达式到项，由项到因子\n每一个非终结符都对应一棵局部语法树\n唉唉 只是课上跟着写还是太草率了\n不如PPT\n","date":"2024-10-24T15:30:00+08:00","image":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/15c277c39924c01bcd89e8f7b84de46_hu6067831623915793491.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/","title":"oopre课堂随笔-序列输入"},{"content":" 设计文档 Key Point: 数据通路，控制器及其连接\n要实现的核心指令介绍 add,sub,lui,ori,lw,sw,beq,nop\n数据通路的建立 名称 功能 简写 程序计数器 输出当前指令所在地址 PC 下指令地址 计算下一指令所在地址并传递给PC NPC 寄存器堆 32 个 32 位寄存器 GRF 指令存储器 存储所有的指令 IM 数据存储器 充当内存存储数据 DM 扩展单元 进行位扩展运算 EXT 算术逻辑单元 进行各项基本运算 ALU 下面先对各数据通路进行分析，并在此过程中得到对控制器的需求\n(在每个数据通路中都只考虑自己需要什么！\n输出的东西如何被使用是其他数据通路考虑的事情！！)\nPC 一个 32 位寄存器即可\n输出引脚：输出当前指令所在地址，提供给IM用于取指令\n输入引脚：由NPC算出的下一条指令地址\n作为整个设备中最核心的时序逻辑，在PC层面其本质应为Moore机\n在下一周期上升沿才可输出下一PC\n在输出PC以后，其他数据通路都基本呈现组合逻辑的形态，即时性进行输出内容的改变，即Mealy机\n（ROM和GRF的写入操作还是要等下一上升沿的，但是关于其写入的各项信息都是即时性得到的）\n当然，最后输出PC值的时候要再加上 3000\n若用PC初始化3000的方法，在复位后PC还是会输出 0\nNPC 下一指令的地址可能是PC+4\n对于beq跳转 也可能是PC+4+sign_ext(imm_16 || 00)\n对于j, jal跳转 还可能是PC[31:28] || imm_26 || 00\n输入引脚：输入当前PC值，imm_16, imm_26\n选择信号：br, zero, j\n这里区分br和zero是有原因的。\n详见zero产出地：ALU\n输出引脚：下一条指令PC值\n！！经后续分析，对于XXXAndLink指令，PC+4是被需要的，那就直接从NPC输出\nNPC外部的连接也比较直白\n具体分析：\n控制信号的使用：\n只有br和zero同时为1时才是成功beq跳转 鉴别出j，jal等才使用imm_26直接地址跳转 Tips: 由于jal指令为本人后续添加，因此选择了新增了MUX而不是改变原MUX\n计算过程实现：简单的加法，移位，位扩展，位拼接运算\n要注意位扩展一定是sign_ext，因此完全可以直接使用bit_sign_extender\nIM 采用了4096*32bit的ROM 地址长度选项只需12位\n！！ROM的地址以字为单位，因此PC要右移2位才能传给ROM\n右移之后还需bit_extender到12位\n（一定要先右移再extend，因为实质上就是取PC[13:2]）\n其余的没什么内容了\nSplitter 把这个东西单独拿出来写只是图个方便（）\nSplitter内部的构造就只是一些小splitter\nEXT EXT也是一个相对好说的部件\n根据EXTOp进行不同形式的位扩展\n（缺点（？）是只能用于16bit -\u0026gt; 32bit）\nEXTOp 含义 0 无符号扩展 1 符号扩展 EXTOp具体怎么得到就是Ctrl要考虑的了\n外部构造：\n内部结构：\n好的我刚刚意识到bit_extender本来就可以输入EXTOp\n但是我的EXT更好看（？）那就不改了\nGRF GRF相对来说就复杂多了\n内部结构在P0课下已经搭好了，但其正确性仍需后续测试\n在此仅略加展示：\n而其外部结构也大有文章\n指令 使用数据 add,sub 读rs,rt写ALU到rd ori 读rs写ALU到rt lui 写ALU到rt lw 读rs（即base）求ALU写MemReadData到rt sw 读rs（即base）求ALU但不写Grf beq 读rs,rd求ALU（做减法判zero）但不写Grf jal 不读但写PC+4到$31 因此构造相应的控制信号与多路选择器即可\nWrsel 含义 0 写到rt 1 写到rd Wdsel 含义 0 写ALU的结果 1 写MemReadData 后续添加的jal指令我又使用了控制信号Link\nLink 含义 0 按上述两个选择器行事 1 写PC+4到$31 当然，除此之外还有最重要的写使能信号\n整体外部结构如下图所示：\nALU 首先明确ALU要解决的问题：\n加法，减法，或，左移16位共4种运算\n显然ALUOp需要4种，即需要两位信号\nALUOp 使用指令 00 add，加法 01 sub，beq，减法 10 ori，或运算 11 lui，左移16位 不过，我并没有直接分四种器件进行操作\n采用了gxp老师课上提到的方法：\n加法和减法可使用同一加法器！！\na - b = a + ~b + 1\n而两个数相加再加1正是加法器已经提供的功能！\n最上方的接口即为进位接口\n！但是复用器件的代价就是更多的选择信号\n减法不仅仅要选择进位信号，还要选择参与运算的数\n对于整个ALU还需要区分进行了什么运算\n我们分为如下三个\n使用指令 M1 M1含义 Cin Cin含义 M2 M2含义 加法 0 使用b 0 进位为0 00 加减 减法 1 使用~b 1 进位为1 00 加减 或运算 X X X X 01 或运算 左移16位 X X X X 10 左移 如何根据ALUOp写出这些控制信号也一目了然：\n只需把上面两个表合起来，让ALUOp直接对应控制信号\n用Combinational Analysis给我们写出来就行了\n最终内部结构如下：\n在此解释前文NPC中zero与br都需存在的原因：\nbeq也是对rs,rt的值做减法，但关键在于结果值为0时输出zero信号为1\n因此zero信号也是会被sub甚至add干扰的\n所以在zero==1时必须有br==1才有效\n另一方向显然，br==1时判跳转有效当然离不开zero==1的判定\n关于其外部连接，关键只是两个控制信号：\n我们把GRF处使用的表格稍有侧重点地修改\n指令 使用数据 add,sub rs,rt算ALU（加减） ori rs，imm算ALU（或运算） lui imm算ALU（移位） lw,sw rs，imm算ALU（加法） beq rs,rd算ALU（做减法判zero） 将rs替换成RD1，将rt,rd按照对应法则替换到RD2\n可得到更清晰的表格\n指令 使用数据 add,sub RD1,RD2算ALU（加减） ori RD1，imm算ALU（或运算） lui imm算ALU（移位） lw,sw RD1，imm算ALU（加法） beq RD1,RD2算ALU（做减法判zero） 即可发现控制信号除了ALUOp之外，还有操作数2的选择\n操作数2可选择RD2或imm\n因此构造相应的控制信号与多路选择器即可\nBsel 含义 0 RD2 1 imm 这里的imm都是imm_16经过EXT的结果\n事已至此，可以顺便EXTOp也考虑清楚\n准确来说，只有ori需要无符号（EXTOp == 0）\nEXTOp 指令 0 ori 1 lw,sw X 其他 beq的sign_ext已经在NPC里面确认了\nEXTOp对于beq指令没有意义\n外部连接如下图所示：\nDM 我们采用了3072*32bit的RAM 地址长度选项只需9位\nDM和GRF逻辑类似\n但是由于我们直接使用RAM\n在一些内容的表达上需要按照RAM行事\nRAM 应使用双端口模式，即设置 RAM 的 Data Interface 属性为 Separate load and store ports RAM的ld也需要特别激活，因此需要一个lw信号来控制它 str信号就是普通的写使能信号 clr信号为异步复位信号 和ROM类似，RAM的地址也以字为单位，因此PC要右移2位才能传入 右移之后还需bit_extender到9位 （一定要先右移再extend，因为实质上就是取PC[10:2]）\nDM的A接口是地址，由ALU算出\n要存入的信息则是GRF从rt读出来的RD2\n连接比较简单\n控制器的搭建 在数据通路的苦苦搭建之中，其实控制信号已经都有了自己的定义\n我们发现，这些定义一般都依赖于指令\n那么控制器就可以建起这个桥梁：\n通过opcode和funct得到指令\n再由指令得出控制信号\n由外部信号到指令 得到指令的过程我使用了比较器，因此构建过程非常简单\n由指令到控制信号 由指令到控制信号那可就更简单了\n除了 ALUOp（）\n我们使用OR阵列\n哪条指令需要这个信号，我们就给它或到这个控制信号上\n这种拉线式的写法还是很方便的\nALUOp就只能拜托我们亲爱的Combinational Analysis啦\nCTRL在整个main电路中的书写还是比较简单的\n我把他设计成了一个很富有信息量的样子（）\n搭电路的过程中一些小惬意的时光就是在修改电路外观~\n测试文档 那么至此，我们的基础版CPU算是实现了基本自洽\n接下来，就需要有大量的边界与随机指令去测试它了！\n我首先测试了课程组给出的附件，并翻译为MIPS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 .text ori\t$28, $0, 0 ori\t$29, $0, 0 ori\t$1, $0, 0x3456 add\t$1, $1, $1 lw\t$1, 4($0) sw\t$1, 4($0) lui\t$2, 0x7878 sub\t$3, $2, $1 lui\t$5, 0x1234 ori\t$4, $0, 5 nop sw\t$5, -1($4) lw\t$3, -1($4) beq\t$3, $5, _1 beq\t$0, $0, _13 _1: ori\t$7, $3, 0x404 beq\t$7, $3, _11 nop lui\t$8, 0x7777 ori\t$8, $8, -1 sub\t$0, $0, $8 ori\t0, $0, 0x1100 add\t$10, $7, $6 ori\t$8, $0, 0 ori\t$9, $0, 1 ori\t$10, $0, 1 _minus2: add\t$8, $8, $10 beq\t$8, $9, _minus2 _13: _11: _minus1: beq\t$0, $0, _minus1 # dead continue 寄存器数据及跳转测试 // 本测试的不足之处在于支持了MARS不支持的错误运算 //如最大正数加1，最小负数减1，-1减最小负数等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //记得写v2.0 raw 3c00ffff // 测试`$0` //下面是对低16位赋值 3c01ffff 3c028000 00000000 //nop测试 3c047fff 3c058000 //下面是对低16位赋值 3421ffff // `$1` = -1 34420000 // `$2` = 最小负数 34630001 // `$3` = 1 3484ffff // `$4` = 最大正数 34a50001 // `$5` = 最小负数 + 1 //sw与lw的简单测试 ac64ffff //在0处存 `$4` 测试offset为负 bc200001 //把0处的值给`$0` 测试`$0` 8c040000 //把0处的值给`$4` 测试offset为0 00253020 // `$6` = `$5` + `$1` 10460002 //等于最小负数 跳2句 //跳-8句跳回形成死循环 00643820 //最大正数加一 10e20000 //等于最小负数 跳0句 00a34022 //最小负数+1减一 11020000 //等于最小负数 跳0句 01034822 //最小负数减一 11240000 //等于最大正数 跳0句 00225022 //-1减最小负数 1144fff8 //等于最大正数 跳-8句 检验方法 在保证sw无问题的前提下\n将所有的敏感变量都及时存储\nbe like:\n1 2 3 4 5 6 .macro save(%data) #不保存$t0,$t1 sw %data, 0($t0) # 不能用addi ori $t1, $0, 4 add $t0, $t0, $t1 .end_macro 之后只需要直接比对MARS和DM的存储区即可\n","date":"2024-10-23T12:30:15+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p3-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/88e20704208d17e1fd4372ecfb993c3_hu1946466944430747746.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p3-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/","title":"北航CO P3 单周期CPU的logisim搭建"},{"content":"Welcome!! I feel so excited and interested to create my first blog!\nI plan to name my blog \u0026lsquo;Demiurge\u0026rsquo; just because this song is really astonishing and touching\u0026hellip;\n(By the way, the illustration is also fantastic)\nI am suddenly awared that 我可以说中文\n那么，今后请多多指教！\n","date":"2024-09-24T00:37:20+08:00","image":"https://demiurge-zby.github.io/p/demiurgefirstblog/demiurge_hu5188072458766260427.png","permalink":"https://demiurge-zby.github.io/p/demiurgefirstblog/","title":"DemiurgeFirstBlog"}]