[{"content":"exam 参考往年题总是有帮助的。\n21级 参考博客 (点击查看题面)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 u_int page_perm_stat(Pde *pgdir, struct Page *pp, u_int perm_mask) { u_int count = 0; for (u_int i = 0; i \u0026lt; (1u \u0026lt;\u0026lt; 10); i++) { Pde *pgdir_entryp = pgdir + i; if (*pgdir_entryp \u0026amp; PTE_V) { Pte *pte = (Pte *) KADDR(PTE_ADDR(*pgdir_entryp)); for (u_int j = 0; j \u0026lt; (1u \u0026lt;\u0026lt; 10); j++) { Pte *pte_entryp = pte + j; if ((*pte_entryp \u0026amp; PTE_V) \u0026amp;\u0026amp; (*pte_entryp \u0026amp; perm_mask) == perm_mask) { if (pa2page(PTE_ADDR(*pte_entryp)) == pp) count++; } } } } return count; } 你需要掌握：\n如何对页表进行遍历 一些判断条件的写法（有效性判断、权限位判断、物理页判断） 22级 未找到题面，但内容相对简单，不难看懂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 u_int page_filter(Pde *pgdir, u_int va_lower_limit, u_int va_upper_limit, u_int num) { u_int begin = va_lower_limit; u_int end = va_upper_limit; struct Page *cur_page; u_int count = 0; for (u_int addr = begin; addr \u0026lt; end; addr += PAGE_SIZE) { cur_page = page_lookup(pgdir, addr, NULL); if (cur_page != NULL \u0026amp;\u0026amp; cur_page-\u0026gt;pp_ref \u0026gt;= num) { ++count; } } return count; } 你可以先试着读一读。\n你需要掌握：\n如何遍历某虚拟地址范围内的物理页 注意到page_lookup(pgdir, addr, NULL)中的NULL，思考一下为什么可以用NULL 23级 先来看题面，试着自己想一想！\n实现u_int page_conditional_remove(Pde *pgdir, u_int asid, u_int perm_mask, u_long begin_va, u_long end_va)\n操作：\t在从begin_va到end_va的虚拟地址对应的所有页表项中，删除 权限位与perm_mask交集非空的表项 的映射。\n返回值：\t删除的映射数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 u_int page_conditional_remove(Pde *pgdir, u_int asid, u_int perm_mask, u_long begin_va, u_long end_va) { struct Page *cur_page; Pte *pte_entryp; u_int count = 0; for (u_long addr = begin_va; addr \u0026lt; end_va; addr += PAGE_SIZE) { cur_page = page_lookup(pgdir, addr, \u0026amp;pte_entryp); if (cur_page != NULL \u0026amp;\u0026amp; (*pte_entryp \u0026amp; perm_mask) != 0) { page_decref(cur_page); tlb_invalidate(asid, addr); *pte_entryp = 0; count++; } } return count; } 你问我怎么知道要page_decref(cur_page);,tlb_invalidate(asid, addr);和*pte_entryp = 0;？\n考场是有HINT的！提示你模仿page_remove()函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void page_remove(Pde *pgdir, u_int asid, u_long va) { Pte *pte; /* Step 1: Get the page table entry, and check if the page table entry is valid. */ struct Page *pp = page_lookup(pgdir, va, \u0026amp;pte); if (pp == NULL) { return; } /* Step 2: Decrease reference count on \u0026#39;pp\u0026#39;. */ page_decref(pp); /* Step 3: Flush TLB. */ *pte = 0; tlb_invalidate(asid, va); return; } 笔者第一次提交就是没有认真参考这个函数，导致漏写*pte_entryp = 0;\n那么你应当知道：\tcur_page = page_lookup(pgdir, addr, \u0026amp;pte_entryp); 这时候为什么不是NULL？\t因为你需要用到这个页表项的信息了，仅仅拿到cur_page是不够的。\n经过简单的练习， 相信你应该没有那么畏惧lab2_exam了！\nextra 还是老样子，我直接给出题面和我的代码。\n由于我曾经没能正视lab2上机，认为通过exam就很难了，因此刚开始看到extra这么全新背景且高度系统化的题面，只是抱着尽力做一做，而不是一定要拿下的态度。\t等到发现它并没有那么难时，时间也流逝得差不多了。\n这次extra相较于往年，更多地考查了对宏定义的运用，函数操作过程完全依据题意。\t而往年改写函数的套路则直接用在了exam上。\n往年题extra就像笔者的lab1_extra一样，例如page_alloc改写为buddy_alloc、swap_alloc\n题面 见：\n1 https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab2-%E4%B8%8A%E6%9C%BA/lab2_extra.pdf 解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 void *malloc(size_t size) { /* Your Code Here (1/2) */ size_t true_size = ROUND(size, 8); struct MBlock *cur; LIST_FOREACH(cur, \u0026amp;mblock_list, mb_link) { if (cur-\u0026gt;size \u0026gt;= true_size \u0026amp;\u0026amp; cur-\u0026gt;free == 1) { if (cur-\u0026gt;size - true_size \u0026lt; 32) {\tcur-\u0026gt;free = 0; return cur-\u0026gt;ptr; } size_t leave = cur-\u0026gt;size - true_size - 24; cur-\u0026gt;size = true_size; struct MBlock* newMBlock = (struct MBlock*)(cur-\u0026gt;ptr + true_size); newMBlock-\u0026gt;size = leave; newMBlock-\u0026gt;free = 1; newMBlock-\u0026gt;ptr = (void*) newMBlock-\u0026gt;data; LIST_INSERT_AFTER(cur, newMBlock, mb_link); cur-\u0026gt;free = 0; return cur-\u0026gt;ptr; } } return NULL; } void free(void *p) { /* Your Code Here (2/2) */ if (p \u0026lt; HEAP_BEGIN + MBLOCK_SIZE || p \u0026gt; HEAP_BEGIN + HEAP_SIZE) { return; } void *nowp = p - MBLOCK_SIZE; struct MBlock* now = (struct MBlock*)nowp; if (now-\u0026gt;ptr != now-\u0026gt;data || now-\u0026gt;free == 1) { return; } struct MBlock* next = LIST_NEXT(now, mb_link); if (next != NULL \u0026amp;\u0026amp; next-\u0026gt;free == 1) { now-\u0026gt;size += 24 + next-\u0026gt;size; now-\u0026gt;ptr = now-\u0026gt;data; now-\u0026gt;free = 1; LIST_REMOVE(next, mb_link); } if(now != LIST_FIRST(\u0026amp;mblock_list)) { struct MBlock* prev = MBLOCK_PREV(now, mb_link); if (prev-\u0026gt;free == 1) { LIST_REMOVE(now, mb_link); prev-\u0026gt;size += 24 + now-\u0026gt;size; prev-\u0026gt;ptr = prev-\u0026gt;data; return; } } now-\u0026gt;free = 1; return; } 笔者这次lab2_extra是失败的，上述代码是开放lab2_extra线下评测（不记分数）后经过修改的版本。\n笔者虽然拿了30分，但其实代码的问题很可怕。\n13行的struct MBlock* newMBlock = (struct MBlock*)(cur-\u0026gt;ptr + true_size);\t笔者将true_size误写成了size，也就是没有经过对齐的size\t这看起来很微不足道，但很致命。\n反倒是笔者的室友，只是把mb_link都写成了field导致过不了编译，事后修改完直接满分更显遗憾。\n后记 目前对extra题有一些小小的感受。\t你看往年题的extra是看不懂一点的，\t但是真上机了你又能一点点磨出来。\t我觉得是题目引导+考场氛围共同作用吧\n所以可能确实没必要对着往年的extra深研（？）\n此外，笔者在本周，遭遇了OOhw7的重创。C房要交10次才能拿到base，可是再刀下去可能就会无意形成恶意hack。\n此外，笔者现在正在经历北京13级狂风。但是貌似学校这里的风并不是很大。\n此外，蓝桥杯也顺利延迟了。可是大英赛没有延迟。但是笔者没报大英赛。\n","date":"2025-04-13T11:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab2-%E4%B8%8A%E6%9C%BA/123_hu12266348634778516995.png","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab2-%E4%B8%8A%E6%9C%BA/","title":"北航OS Lab2 上机"},{"content":"实验报告 思考题 Thinking 2.1 在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址。 MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟地址。\n参见实验指导书：\n在计算机组成原理等硬件实验中，CPU 通常直接发送物理地址，这是为了简化内存操作，让大家关注 CPU 内部的计算与控制逻辑。而在实际程序中，访存、跳转等指令以及用于取指的 PC 寄存器中的访存目标地址都是虚拟地址。我们编写的 C 程序中也经常通过对指针解引用来进行访存，其中指针的值也会被视为虚拟地址，经过编译后生成相应的访存指令。\nThinking 2.2 用宏实现链表的好处 首先，在可重用性上自然是能够被多次反复使用，便于代码书写与阅读。 其次，宏相较于函数，其自由度大大增加。它可以支持不同数据类型的链表，因为其本质上只是字符串替换，可操作性更强。 第三，宏不是函数调用，不需额外占用函数栈空间。\n比较单向、双向、循环链表 由于 /usr/include/sys/queue.h 里面的双向链表和我们自己实现的差别不大，因此都使用了/usr/include/sys/queue.h的进行对比分析。\n单向链表： 双向链表： 循环链表： 可以看出，在结构体定义上，单向链表与双向链表都只需要头指针，而循环链表需要头尾两个指针； 在link定义上，单向链表只有next，而双向链表与循环链表都有next与prev。\n需要注意的是：循环链表的next与prev都是数据的指针，而双向链表的prev是前一数据的next指针的指针！\n在功能性上的差异在此不再赘述了，实现的功能越多，效率上可能就会有折损。\n插入 单向链表只能实现插入到某个节点之后，但相应的语句也只有两条。 双向链表能够实现插入到前、后两种位置，但是每个方法都需要四条语句。 循环链表能实现插入到前、后两种位置，需要的语句更加复杂。 此外，循环链表出了插入到HEAD之外，还有独有的插入到TAIL 删除 三种链表在删除上的区别更加显著： 单向链表要想删除某个结点，必须通过遍历来定位好他的位置，才能让它前面的结点链接上它后面的结点。 而双向链表可以直接知晓其前一结点的next指针，因此只需要O(1)的操作 循环链表也是O(1)的，但是对于head指针要特殊处理。 整体来看，双向链表是权衡了时间复杂度与空间复杂度的不错设计，性能优良。\nThinking 2.3 选择C项。\n接下来分析一下Page_list的结构。\nPage_LIST_entry_t 结合 与 得知\n1 2 struct Page *le_next; struct Page **le_prev; 构成了结构体Page_LIST_entry_t。\nPage 接着根据 得知\n1 2 struct Page_LIST_entry_t pp_link; u_short pp_ref; 构成了结构体struct Page。\nPage_list 根据 与 得知\n1 struct Page *lh_first; 构成了结构体struct Page_list。\nAnswer 经过整理总结，也即：\n1 2 3 4 5 6 7 8 9 struct Page_list{ struct { struct { struct Page *le_next; struct Page **le_prev; } pp_link; u_short pp_ref; }* lh_first; } Thinking 2.4 根据任务指导书：\nASID：Address Space IDentifier 用于区分不同的地址空间。 查找 TLB 表项时，除了需要提供 VPN，还需要提供ASID 同一虚拟地址在不同的地址空间中通常映射到不同的物理地址\n在多进程操作系统中，每个进程都有自己独立的虚拟地址空间。ASID 作为唯一的标识符，要用于区分不同进程的地址空间。\nASID通常为8位，即有256种ASID，就可以支持256个不同的地址空间。\nThinking 2.5 调用关系显然： tlb_invalidate函数通过调用tlb_out函数，把va对应的页表项清空。 其中(va \u0026amp; ~GENMASK(PGSHIFT, 0)) | (asid \u0026amp; (NASID - 1)) 是传入的参数，也就是$a0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 LEAF(tlb_out) # 定义为叶函数，这决定了它的栈帧结构 .set noreorder # 确保指令按照代码中的顺序依次执行 # 保存和修改 CP0_ENTRYHI 寄存器 mfc0 t0, CP0_ENTRYHI # 保存 CP0_ENTRYHI 寄存器 mtc0 a0, CP0_ENTRYHI # 修改 CP0_ENTRYHI 寄存器 nop tlbp # 查找与 ENTRYHI 寄存器中值匹配的条目，存入CP0_INDEX nop mfc0 t1, CP0_INDEX # 取出index .set reorder # 即将有分支跳转，允许汇编器对指令进行重新排序 bltz t1, NO_SUCH_ENTRY # index == -1 即不存在对应的tlb .set noreorder # tlb表项存在，继续顺序执行 mtc0 zero, CP0_ENTRYHI # 清空 mtc0 zero, CP0_ENTRYLO0 # 清空 mtc0 zero, CP0_ENTRYLO1 # 清空 nop tlbwi # 把这些值写入tlb，也就是清空该tlb表项 .set reorder # 不管 tlbp 指令是否找到匹配的 TLB 条目 # 执行完 tlbwi 之后 # 程序最终都会恢复 ENTRYHI 寄存器的值 # 并且返回到调用者处 NO_SUCH_ENTRY: mtc0 t0, CP0_ENTRYHI # 恢复CP0_ENTRYHI j ra # 返回到tlb_invalidate函数 END(tlb_out) 参考： Thinking A.1 页面大小4KB，页内偏移为12位。\n一级页表指向512个二级页表，每个二级页表指向512个三级页表。\n若三级页表的基地址为PTbase， 则三级页表页目录的基地址应当是PTbase + PTbase\u0026raquo;9\n映射到页目录自身的页目录项地址为PTbase + PTbase\u0026raquo;9 + PTbase\u0026raquo;18\nThinking 2.6 函数调用需要开启进程，env_init就需要pgdir_alloc为其分配页。 load_icode在加载进程指令代码时，需要page_alloc和page_insert为加载二进制代码到内存而分配物理页并建立映射。 当进程结束或内存区域不再使用时使用env_free，需要page_remove从页表移除相关映射，page_decref减少物理页引用计数。 Thinking 2.7 X86 存在逻辑地址、线性地址和物理地址三种地址。 逻辑地址由段基址和偏移量构成，是程序直接使用的地址。 通过分段机制，逻辑地址转换为线性地址； 再利用分页机制，线性地址转换为物理地址用于实际访存。\n比较来说，X86有分段和分页两层地址转换，先分段后分页； MIPS主要是分页机制，内存管理粒度更统一。\n难点分析 本次实验整体来说看还是蛮大的，从物理内存到虚拟内存再到TLB，形成了综合的一体化架构。\npmap.c pmap.c是本次实验最核心的文件之一。主要函数如下：\nmips_detect_memory: 得知可用物理页数\nalloc：增大freemem，返回申请的物理空间\nmips_vm_init：为两级页表alloc物理空间\npage_init：把物理空间划分为物理页，根据freemem区分已用页与未用页，并将未用页都放进page_free_list\npage_alloc：从page_free_list申请物理页\npage_free：将物理页放回page_free_list\npgdir_walk：得到va对应的二级页表中的对应项的索引\npage_insert：建立pgdir_walk找到的项与物理页的映射\npage_lookup：找到va对应的物理页\npage_decref：降低物理页引用次数，降低到0时自动执行page_free\npage_remove：降低va对应物理页的引用次数，并清空va对应的TLB表项\n其中关于Pde、Pte指针的阅读理解难度比较大，并且涉及到大量的头文件，需要反复阅读pmap.h与queue.h才能解决问题。\nTLB 关于TLB表项的清空与重填，我们主要进行阅读与理解的工作。\n由于TLB miss，do_tlb_refill被触发。 do_tlb_refill为_do_tlb_refill传参 _do_tlb_refill调用tlb_invalidate进行TLB清空 _do_tlb_refill寻找page并进行页表重填 _do_tlb_refill返回值用于do_tlb_refill重填TLB 实验体会 第一次接触这些内容的时候，会感受到一片茫然。不过实验指导书从内到外的引导还是很到位的，跟着指导书读完源代码后，基本上知道内存管理干了什么事，是如何实现的。\n在具体实现代码内容的时候，基本上是被HINT牵着走，没有HINT的话，我也确实不能直接明白该怎么去实现具体的功能。\nLab2只顺着过一遍大抵是会忘光的。如果能够为所有的函数都写上自己的注释，可能理解会更加深入一点。\n近期事务很多很乱，如果能像解决Lab2的诸多函数一样，逐个攻克，希望会有好的结果。\n","date":"2025-04-05T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/jpg_hu9259821900430245864.png","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"北航OS Lab2 内存管理"},{"content":"exam exam难度相较上次已大幅降低，如果lab1本身实现没有问题，再看过一点点学长博客或代码，基本就约等于点击即送了。\n在此统计一下近三年的exam。再往前lab1就主要学习readelf，考核点不在于vprintfmt了。\n近三年的exam均采用了新增%\u0026hellip;[字母]的形式，也不必担心新的字母有什么新的实现，一般就是%d,%s,%c等等的组合罢了。\n21级：%R 21级（2023上机）：\n实现 %...R:\t%...R等价于(%...d,%...d)\n所以只需要\n1 2 3 4 5 6 7 8 case \u0026#39;R\u0026#39;: print_char(out, data, \u0026#39;(\u0026#39;, 0, 0); //... 照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;,\u0026#39;, 0, 0); // width可无脑取0，因为width是最小长度限制，大于此长度不会截断 //... 再次照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;)\u0026#39;, 0, 0); break; 不用畏惧两个参数，无非是两次va_arg，照搬两次case \u0026rsquo;d\u0026rsquo;的内容的时候都是实现了的。\n具体可参见nr的博客 (点击阅读)\n22级：%P 22级堪称与21级一模一样，唯一的改变是读两个参数需要输出三个数：\n%...P等价于(%...d,%...d,%...d)\n读取两个数x,y\t输出三个数x,y,z\t其中z=(x+y)*(x-y)\n记不大清了，反正只是x,y某种简单计算后的结果\n所以也只需要\n1 2 3 4 5 6 7 8 9 10 case \u0026#39;P\u0026#39;: print_char(out, data, \u0026#39;(\u0026#39;, 0, 0); //... 照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;,\u0026#39;, 0, 0); // width可无脑取0，因为width是最小长度限制，大于此长度不会截断 //... 再次照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;,\u0026#39;, 0, 0); //... 再再次照搬case \u0026#39;d\u0026#39;的内容 print_char(out, data, \u0026#39;)\u0026#39;, 0, 0); break; 需要注意的是，第三次照搬就不需要通过va_arg了，而是直接计算出来。\nMYGO!!!!! : %k 我们的上机相较过去有一定的突破，但也不多：\t%...k等价于%...s =\u0026gt; %...d\n但是%...k中的...的属性并不是全部无脑分配给%s与%d了\n这些属性具体给谁按照题意要求即可\n其实也只需要\n1 2 3 4 5 6 case \u0026#39;k\u0026#39;: //... 照搬case \u0026#39;s\u0026#39;的内容 print_str(out, data, \u0026#34; =\u0026gt; \u0026#34;, 0, 0); // 这里width还可以可无脑取0 //... 照搬case \u0026#39;d\u0026#39;的内容 break; 如果lab1不出意外还出这类题的话，相信你看完这些讲解，应当是能直接秒杀了。\n这里给你一点更快的建议：\nnyy可以复制自光标起的n行 p可以实现粘贴 在实验报告中也提到过的，print_char,print_num,print_str之类的函数也可以提前了解一下\textra 本次extra题考验你C语言指针功夫！\n其实和往年题也比较类似的：\t考查你对out函数的理解。\n一般来说都会设置一个比较新的背景，\n21级的sprintf写入到字符串 22级的模仿print写scan 23级的fmemprintf写入到内存信息流 本质上都是仿照着kern/printk.c来书写\nHINT也会提示你去参考这个函数（）\n核心的方法就是写一个新的out函数\n因为调用vprintfmt的时候，最终都是落实到out函数上，vprintfmt主要做的就是格式解析的工作。因此只需要写好自定义out函数，就能实现自定义支持格式的新功能。\n其他的内容在此不愿详细解释，大家根据题面与HINT努力实现就好，都是一些很简单的，功能明确的C函数。（大多数人挂都是这些环节的C语言bug）\n题目背景：\tFILE*结构体：\tchar *base; 基地址（起始地址） char *ptr; 写地址（当前地址） char *end; 末地址\n可以理解为FILE*掌管着一段字符串以及一个用于操作的指针\n下面是实现的五个函数，其中四个函数是明确要求的必需函数，还有一个是实现过程中需要自主实现并调用的。\nfmemopen 笔者debug了30min便在于strcmp前面忘加!\nOS的debug难度实在太大。 当你出现错误，你得不到任何有效信息，有可能就只是make run之后系统卡死\t如果错的不那么错误（例如我这样），也许会返回一个无厘头的错误结果，但事实上这个结果反而误导了我的debug过程\nfmemoutput(此函数为自主命名实现) fmemprintf fseek fclose 后记 在OOU2hw5电梯、冯如杯、lab2等多项繁杂事务的强压之下，居然还能抽出时间点开这篇文章复习OS的lab1，真切希望我的内容可以帮助到你！！！\n大概率很多人是没有怎么看extra的代码的，因为确实没必要看。 在这里放出来，是希望大家能对extra的整体代码量与实现难度有一定基础的认知。\n祝上机顺利！\n","date":"2025-03-28T11:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab1-%E4%B8%8A%E6%9C%BA/123_hu17637424243101368024.png","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab1-%E4%B8%8A%E6%9C%BA/","title":"北航OS Lab1 上机"},{"content":"实验报告 思考题 Thinking 1.1 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 1; int b = 2; int c = a + b; printf(\u0026#34;%d\\n\u0026#34;,c); return 0; } gcc 与 readelf 可以发现readelf在不使用mips交叉编译工具链的时候也可以正确阅读由mips交叉编译工具链编译得到的内容。\nobjdump 用原生x86的objdump反编译gccmain.o结果如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 gccmain.o： 文件格式 elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 83 ec 10 sub $0x10,%rsp c: c7 45 f4 01 00 00 00 movl $0x1,-0xc(%rbp) 13: c7 45 f8 02 00 00 00 movl $0x2,-0x8(%rbp) 1a: 8b 55 f4 mov -0xc(%rbp),%edx 1d: 8b 45 f8 mov -0x8(%rbp),%eax 20: 01 d0 add %edx,%eax 22: 89 45 fc mov %eax,-0x4(%rbp) 25: 8b 45 fc mov -0x4(%rbp),%eax 28: 89 c6 mov %eax,%esi 2a: 48 8d 05 00 00 00 00 lea 0x0(%rip),%rax # 31 \u0026lt;main+0x31\u0026gt; 31: 48 89 c7 mov %rax,%rdi 34: b8 00 00 00 00 mov $0x0,%eax 39: e8 00 00 00 00 call 3e \u0026lt;main+0x3e\u0026gt; 3e: b8 00 00 00 00 mov $0x0,%eax 43: c9 leave 44: c3 ret Disassembly of section .rodata: 0000000000000000 \u0026lt;.rodata\u0026gt;: 0: 25 .byte 0x25 1: 64 0a 00 or %fs:(%rax),%al Disassembly of section .comment: 0000000000000000 \u0026lt;.comment\u0026gt;: 0: 00 47 43 add %al,0x43(%rdi) 3: 43 3a 20 rex.XB cmp (%r8),%spl 6: 28 55 62 sub %dl,0x62(%rbp) 9: 75 6e jne 79 \u0026lt;main+0x79\u0026gt; b: 74 75 je 82 \u0026lt;main+0x82\u0026gt; d: 20 31 and %dh,(%rcx) f: 33 2e xor (%rsi),%ebp 11: 33 2e xor (%rsi),%ebp 13: 30 2d 36 75 62 75 xor %ch,0x75627536(%rip) # 7562754f \u0026lt;main+0x7562754f\u0026gt; 19: 6e outsb %ds:(%rsi),(%dx) 1a: 74 75 je 91 \u0026lt;main+0x91\u0026gt; 1c: 32 7e 32 xor 0x32(%rsi),%bh 1f: 34 2e xor $0x2e,%al 21: 30 34 29 xor %dh,(%rcx,%rbp,1) 24: 20 31 and %dh,(%rcx) 26: 33 2e xor (%rsi),%ebp 28: 33 2e xor (%rsi),%ebp 2a: 30 00 xor %al,(%rax) Disassembly of section .note.gnu.property: 0000000000000000 \u0026lt;.note.gnu.property\u0026gt;: 0: 04 00 add $0x0,%al 2: 00 00 add %al,(%rax) 4: 10 00 adc %al,(%rax) 6: 00 00 add %al,(%rax) 8: 05 00 00 00 47 add $0x47000000,%eax d: 4e 55 rex.WRX push %rbp f: 00 02 add %al,(%rdx) 11: 00 00 add %al,(%rax) 13: c0 04 00 00 rolb $0x0,(%rax,%rax,1) 17: 00 03 add %al,(%rbx) 19: 00 00 add %al,(%rax) 1b: 00 00 add %al,(%rax) 1d: 00 00 add %al,(%rax) ... Disassembly of section .eh_frame: 0000000000000000 \u0026lt;.eh_frame\u0026gt;: 0: 14 00 adc $0x0,%al 2: 00 00 add %al,(%rax) 4: 00 00 add %al,(%rax) 6: 00 00 add %al,(%rax) 8: 01 7a 52 add %edi,0x52(%rdx) b: 00 01 add %al,(%rcx) d: 78 10 js 1f \u0026lt;.eh_frame+0x1f\u0026gt; f: 01 1b add %ebx,(%rbx) 11: 0c 07 or $0x7,%al 13: 08 90 01 00 00 1c or %dl,0x1c000001(%rax) 19: 00 00 add %al,(%rax) 1b: 00 1c 00 add %bl,(%rax,%rax,1) 1e: 00 00 add %al,(%rax) 20: 00 00 add %al,(%rax) 22: 00 00 add %al,(%rax) 24: 45 00 00 add %r8b,(%r8) 27: 00 00 add %al,(%rax) 29: 45 0e rex.RB (bad) 2b: 10 86 02 43 0d 06 adc %al,0x60d4302(%rsi) 31: 7c 0c jl 3f \u0026lt;main+0x3f\u0026gt; 33: 07 (bad) 34: 08 00 or %al,(%rax) ... 用MIPS交叉编译工具链的objdump反编译mipsgccmain.o结果如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 mipsgccmain.o： 文件格式 elf32-tradbigmips Disassembly of section .text: 00000000 \u0026lt;main\u0026gt;: 0: 27bdffd0 addiu sp,sp,-48 4: afbf002c sw ra,44(sp) 8: afbe0028 sw s8,40(sp) c: 03a0f025 move s8,sp 10: 3c1c0000 lui gp,0x0 14: 279c0000 addiu gp,gp,0 18: afbc0010 sw gp,16(sp) 1c: 24020001 li v0,1 20: afc2001c sw v0,28(s8) 24: 24020002 li v0,2 28: afc20020 sw v0,32(s8) 2c: 8fc3001c lw v1,28(s8) 30: 8fc20020 lw v0,32(s8) 34: 00621021 addu v0,v1,v0 38: afc20024 sw v0,36(s8) 3c: 8fc50024 lw a1,36(s8) 40: 3c020000 lui v0,0x0 44: 24440000 addiu a0,v0,0 48: 8f820000 lw v0,0(gp) 4c: 0040c825 move t9,v0 50: 0320f809 jalr t9 54: 00000000 nop 58: 8fdc0010 lw gp,16(s8) 5c: 00001025 move v0,zero 60: 03c0e825 move sp,s8 64: 8fbf002c lw ra,44(sp) 68: 8fbe0028 lw s8,40(sp) 6c: 27bd0030 addiu sp,sp,48 70: 03e00008 jr ra 74: 00000000 nop ... Disassembly of section .reginfo: 00000000 \u0026lt;.reginfo\u0026gt;: 0: f200003c .word 0xf200003c ... Disassembly of section .MIPS.abiflags: 00000000 \u0026lt;.MIPS.abiflags\u0026gt;: 0: 00002002 srl a0,zero,0x0 4: 01010005 lsa zero,t0,at,0x1 ... Disassembly of section .pdr: 00000000 \u0026lt;.pdr\u0026gt;: 0: 00000000 nop 4: c0000000 ll zero,0(zero) 8: fffffffc .word 0xfffffffc ... 14: 00000030 tge zero,zero 18: 0000001e .word 0x1e 1c: 0000001f .word 0x1f Disassembly of section .rodata: 00000000 \u0026lt;.rodata\u0026gt;: 0: 25640a00 addiu a0,t3,2560 ... Disassembly of section .comment: 00000000 \u0026lt;.comment\u0026gt;: 0: 00474343 .word 0x474343 4: 3a202855 xori zero,s1,0x2855 8: 62756e74 .word 0x62756e74 c: 75203132 jalx 480c4c8 \u0026lt;main+0x480c4c8\u0026gt; 10: 2e332e30 sltiu s3,s1,11824 14: 2d313775 sltiu s1,t1,14197 18: 62756e74 .word 0x62756e74 1c: 75312920 jalx 4c4a480 \u0026lt;main+0x4c4a480\u0026gt; 20: 31322e33 andi s2,t1,0x2e33 24: Address 0x24 is out of bounds. Disassembly of section .gnu.attributes: 00000000 \u0026lt;.gnu.attributes\u0026gt;: 0: 41000000 mftc0 zero,c0_index 4: 0f676e75 jal d9db9d4 \u0026lt;main+0xd9db9d4\u0026gt; 8: 00010000 sll zero,at,0x0 c: 00070405 .word 0x70405 由于CO课掌握的MIPS代码基础，本人阅读mips交叉编译工具链的反编译代码时更为流畅。\nobjdump的参数含义 通过阅读man objdump给出的内容，我们可以得知一些参数信息\n下面举出几例简单的：\n参数 作用 -e或-g 显示调试信息 -D 反汇编所有section -r 显示文件的重定位入口 -S 尽可能反汇编出源代码 -z 将0也进行反汇编 我传入的参数-DS便是反编译所有section，并且同时显示反编译代码与源代码\nThinking 1.2 用readelf解析mos 下图是用自己的readelf阅读mos的结果\n用readelf解析文件本身 我们发现运行没有任何输出结果。\n根据hint，我们使用readelf -h来研究文件头。\n下图是可被自己的readelf分析的mos与hello的信息。 下图是不可被自己的readelf分析的readelf.o的信息。 可以发现他们的类别分别是ELF32与ELF64。\n那么问题就迎刃而解了，我们清晰地记得，在完成readelf.c的书写时，我们采用的都是ELF32类型的数据结构。\n因此我们的readelf不能用来解析身为ELF64的readelf.o文件。\nThinking 1.3 指导书上的启动过程：\n为什么操作系统的内核入口并没有放在上电启动地址，还能保证内核入口被正确跳转到？\n因为内核入口和上电启动地址本来就是没有关系的。\n上电启动位置是用于启动bootloader，实现硬件初始化等内容。 而bootloader所加载的内容才决定了内核的入口，也就是说我们在start.S中所写的_start函数即EXPORT(_start)才是mips_init的入口。\n难点分析 本次实验的核心内容：\n认识elf文件 _start函数 printk函数与vprintfmt函数 认识elf文件 什么是elf文件 .elf包含.exe，.o和.so （不过linux对扩展名要求并不严格，扩展名不能用来判断文件类型！） 准确来说应该是： 可执行文件，可重定位文件和共享对象文件。\n也就是说我们可以用readelf来解析我们在tools/readelf里的hello,readelf,readelf.o, main.o等等多种文件。\n在elf.h中，我们对于ELF32的种种内容做出了定义。 具体来说便是Elf32_Ehdr Elf32_Shdr Elf32_Phdr这三个结构体类型\nElf32_Ehdr描述ELF头，Elf32_Shdr描述节(Section)头表，Elf32_Phdr描述段(Segment)头表，又名程序(Program)头表。\n如何实现readelf 我们自己实现的readelf，是只能解析ELF32的section地址的可执行程序。 功能很简单，只需要从elf文件本身拿到我们想要的信息并输出。\n根据代码逻辑，你需要知道sh_entry_count，并通过shdr这一指针去定位到各个section，从而输出其地址。\n现根据ELF头得到节头表的位置、节头数量等信息，然后让sh_table指针去指向节头表第一项的地址:binary + ehdr-\u0026gt;e_shoff。\n接下来循环输出即可，其中得到节头表下项的方法，只需要将sh_table这一指针变为(Elf32_Shdr *)类型，然后加1即可。也可以用上sh_entry_size，直接加上这个数值实现地址空间的移动。\n如何链接elf文件 只需要将所有的section放在一起，尤其是\n.text 代码段 .data 需要被初始化的全局变量与静态变量 .bss 未被初始化的全局变量与静态变量 放在一起的方法： . = 一个地址 .text:{*(.text)} 把所有.text依次放在.的位置，其他section同理\n若不再修改.则继续顺延放置。 若修改，就以新的地址继续顺延放置。\n_start! 读这道题时会发现有很多宏定义的内容。\nasm.h 通过阅读asm/asm.h，其定义了EXPORT()\n发现它真的只是一个标签而已；\n其中又include了asm/cp0regdef.h与asm/regdef.h\ncp0regdef.h CP0寄存器的一些define\nregdef.h 寄存器堆的一些define\n这就解释了很多看似是无厘头的简写，实则都有依据的内容\n当然还有mmu.h为我们的KSTACKTOP提供了define\n而mips_init可以直接使用，则是因为程序经过预处理编译等等后，函数名也会变为标签，并和start.S的.text段组合在一起，那自然就可以访问到了。\nprintk 本次实验代码量最大的一环，核心内容就是书写vprintfmt函数。\n简单了解va变长数组的基本方法后，我们便可以开始了解这一函数。\n了解vprintfmt 首先，vprintfmt的参数是out函数指针，data指针，fmt字符串，ap数组。\nout函数指针能实现在同一函数(vprintfmt)中调用不同形式的out函数\nout函数可以实现输出以buf为起点，长度为len的字符串。\ndata指针指向out紧挨的内存空间，用于存储additional output sink-specific data（尚不知道有何用）\nfmt是格式字符串，ap则是%对应的参数列表，通过va_arg(ap, type)来获取内容\n实现vprintfmt 核心处理当然在于fmt的解析 在printf(\u0026quot;%d + %d = %d\\n\u0026quot;, a, b, c);中我们知道，fmt字符串中的非占位符直接输出，%xxx则要被变量所替换。那么分析的核心就是找到%并解析%后面的内容。\n整体逻辑是一个大循环\n然后需要一个小循环内寻找%，找不到就length++， 找到了就把之前length长的内容全部out出来。\ns的作用是更新起始点到进入当前小循环时的fmt。\n为了避免一直就没有%无法输出，走出小循环后要再执行一次out函数。如果有%的话也不必担心，因为length就已经更新到0了。\n接下来就该结束大循环了。如果到达了\\0，就break。\n如果survive了这次break，说明你找到了%, 那接下来就是通过对%后内容的解析来改变参数。\n后续的内容难度就不大了。\n需要注意，10进制有符号数输出时会改动neg_flag 因为 它用的是unsigned long！\n更基本的函数 也就是print_char print_str 和 print_num，他们是直接由out函数实现的，用于为vprintfmt提供方法，因此也需要简单了解。\n实验体会 整个实验给我的感觉就是浩大，一时间突然接手了这么多文件，会不知道该看什么，谁是重点（因为每个文件都是必要的）\n那么我们容易做到的，就是跟着实验指导书一点点去探索，从表面的应用层逐渐向内挖掘到实现层，从而了解各个文件的内容。\n倘若研究完lab1，可以搞清楚整个目录下的主要文件的功能与服务关系，我想这对于操作系统体系结构的理解应该是有好处的。\n笑传：笔者打完这行字之后自动输入了Esc :wq 丝滑小连招 ","date":"2025-03-19T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab1-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B8%8Eprintk/jpg_hu16008541044371850100.png","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab1-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B8%8Eprintk/","title":"北航OS Lab1 内核、启动与printk"},{"content":"本次作业以解析表达式并简化后输出为核心任务。\n主要的实现过程为： 预处理-\u0026gt;解析-\u0026gt;化简-\u0026gt;输出\n迭代过程综述 预处理的迭代 第一次作业：空白字符与正负号 第二次作业：递推函数 第三次作业：自定义函数\n解析的迭代 第一次作业：常数因子、幂函数因子、表达式因子 第二次作业：三角因子 第三次作业：求导因子\n化简的迭代 第一次作业：多项式的加乘幂 第二次作业：含三角函数的加乘幂及其化简 第三次作业：求导运算\n输出的迭代 第一次作业：输出多项式 第二次作业：输出含三角函数的表达式 第三次作业：无\n第一次作业 刚刚走进面向对象课堂的第一天，就被HW1深刻地击溃了。 不同于其他同学只是担心可扩展性不够强而不肯动笔————我的大脑是完全空白的。\n我知道是这个道理，但是到底怎么写？\n我认为理解递归下降实际运行的关键，在于深刻理解lexer的执行逻辑，lexer作为parser的属性，是唯一确定的，当我解析完成，lexer也就走完了。解析的过程就是lexer的前进过程。\n而我们做的事情，就是根据读取expression，自行出构建一个新的、有结构的Expr。\n接下来的toPoly便也是递归下降的一种体现。我已经知道最小单元Mono与Power有它具体的toPoly()方法，那么我就可以采用递归下降，对每一个类只着眼于它自身的运算过程。\n代码量 可以看出核心代码在于解析Parser与化简Poly这两个类中。\nUML类图 方法数则是Poly类遥遥领先，不过都是加、乘、幂、去零、取反、输出等基本方法\n复杂度 同样的，Parser与Poly的复杂度是远高于其他类的。\n类的设计 PreProcess为预处理类，直接把空格与连续正负号解决掉，简化Parser的处理。\nMono类与Power类则对应了最小解析单元（因子中的常数，幂函数与表达式因子），这里将常数与幂函数都归为Mono类是很方便的。\n第二次作业 如果说第一次作业是从零到一的突破，那么第二次作业可能就是从1到x的蜕变。 三角因子本身的复杂性太强，不能像之前一样简单的归类，更没有统一的计算方法。\n曾经Poly里的加与乘，如今全部都复杂起来了！ 我们只能进行重构。\n对于加法，我们没有曾经直接看x的幂次来进行合并同类项的简单解法， 因此只有写出同类项判别方法，才能实现加法的简化\n对于乘法，我们需要先实现最小单元之间幂函数幂次与三角因子幂次的累积 再进行所有乘积项的求和\n代码量 较上次作业新增了近800行，其中parser变化不大，而Mono与Poly代码量激增 此外还有新增的类: 递归函数RecursiveFunc\nUML类图 我调整了类的相对位置使之更加清晰。\n图片从上到下分别是函数预处理，表达式解析，表达式化简运算与输出\n复杂度 Parser与Poly不出意外的高复杂度。 但是递推函数类的复杂度异常的高，我承认我当时采用的方法过于粗暴。 后续果然发现了bug，只是到了第三次作业的环境中才得以体现出来。\n类的设计 Mono类秉承着原来解析的最小单元的地位，现在的它，是一个除了表达式因子以外可以包罗万象的Factor,含有常数，幂函数的幂次，三角函数的HashMap\u0026lt;Poly, BigInteger\u0026gt;。\n因此，他也仍然是最终运算的最小单位，充当最终表达式中的项（Term）。\nPoly则是所有Mono的和，用ArrayList实现。\n接下来是RecursiveFunc类。我将函数翻译作为了预处理操作的一部分，实现了在解析开始之前就解决掉了所有的函数问题。这个类的核心作用就是根据已知信息，直接获得一个从0到5的函数Map。\n接着process类也将被重写，并增添替换操作。\n第三次作业 经历了HW1的无力茫然与HW2的大刀阔斧 站在HW3面前的你， 应当充满了决心！\n代码量 代码行数增加的并不多\n主要内容是新类的添加，更多的函数代入操作以及求导计算\nUML类图 相较于hw2，在Factor上新增了求导因子，在预处理上新增了NormalFunc以及一个数据功能类Func。\n复杂度 类的设计 Derivation类作为一个Factor，需要toPoly()方法，只需要将expr先toPoly，在调用Poly()的derive方法。\nNormalFunc类的设计与RecursiveFunc的思路基本一致，只是少了递推这一步。\n可扩展性 函数的扩展： exp函数，只需对Mono类添加一个Poly属性，用于记录指数。 ln函数，同理，只需记录真数。 变元的扩展： 只需Mono的power变为power1和power2，分别作为两个变元的幂指数 BUG 第一次作业 0 bug\n第二次作业 强测 0 bug 互测 2 bugs 错因是在截止前20min才意识到忘记处理sin(0)与cos(0)，这会对性能产生极大的损害。 而在优化了这一点之后，由于从未对数字0 ^ 0有过定义，sin(0)^0就变为了0 而在时间紧迫的情况下，我也没来得及用评测机进行评测。提交截止之后，评测机很快就跑出了该问题。\n另一处bug是犯了很多次的二重循环初始化错误，修改了之后还是遗漏了一个地方。\n正如教程所说，这两个点都是高行与圈复杂度的类（Mono与Poly）所出现的问题，耦合性强，不易被发现。\n若想降低复杂度，也就是解耦合，就需要做好一些预先的规划，将谁该做什么事分清楚。不过Poly与Mono的耦合度高，个人认为是较难避免的。因为Poly里会用到Mono的同类项判别方法，这个方法中又会涉及会Poly(三角函数内)的equal方法，这一equal方法又会归结于Mono\n或者说，Poly跟Mono的关系，就很有一种Expr与Factor的感觉。\n第三次作业 0 bug\n评测机搭建 这三周以来很有成就感的一件事，就是我终于主动尝试着搭出了自己的评测机！\ncheck.py比对 利用了sympy库中的函数 python库就是神通广大（）\ndata.exe数据生成 核心内容\n我使用的是随机暴力生成的方法\n构建的逻辑就是递归下降咯\nprintExpr-\u0026gt;printTerm-\u0026gt;printFactor\nbat批处理程序运行 学习了一些基本运行语句： java -jar .jar python .py .exe\n利用了一些基础的重定向。\nBUG分析 首先是评测机暴力跑数据，通过简化数据点抓住核心问题数据，再定位到代码的具体漏洞位置。这一招在hw2中就大杀四方，获得了5个不同质的bug。\n其次便是手动构造边界数据，尤其是0,0次幂，1次幂等特殊情况，多加测试。\n遗憾的是，由于代码阅读能力不够强，我常常没有心力去认真观察他人的代码来寻找bug。\n优化 输出符号优化 hw1便涉及到的，存在正项则提前\nsin cos正负号优化 对于因子内部全为负的三角因子，我会直接对该Poly使用negate方法，使其含有正项，从而缩短长度\n这一处理在某种程度上也统一了一些格式，便于同类项的判断\n不足之处在于还是不能用于全面的判断两个Poly是Opposite的，例如1-x与x-1，便不会经过处理，从而后续不会被判定为同类项\n改进： 我们可以采用相加等于0的方法来判断Poly的isOpposite\nsin^ 2+cos^ 2 sin^ 2-cos^ 2 sin^ 4-cos^ 4 为了能够处理嵌套括号内的该类内容，我选择了在每次addPoly()时都加以判断，并且提取了公因式（不过无法处理幂次的公因式，比如sin(x)^ 3+cos(x)^ 2*sin(x)）。\n一处问题：在二倍角过程中，我改变了三角因子的Poly。这一行为决定了我们必须使用深克隆！\n另一处问题：过于频繁与紧急的匹配会导致贪心，例如sin(x)^ 2 - cos(x) ^2 + cos(x) ^2, 便会被我使用二倍角，从而闹出笑话。\n改进：在最后再处理化简工作，至于嵌套，可选择遍历内部嵌套进行化简。\n心得体会 作为第一章，面向对象的思想已经比较清晰地发散开来了。递归下降这一算法，本身就是十分符合面向对象的思维方式，每个类做好自己的算法，问题一定能得到解决。\nhw2是很不错的一次体验，虽然是最辛苦的一周，但是无畏地向前探索，不合适就重构的勇气是很宝贵的。\n搭建评测机也是很奇妙的一次体验。自主学习的收获总是刻骨铭心。\n未来方向 个人认为递归下降的内容如果能在理论课上详细结合代码来讲解运行逻辑，可能hw1就不会显得那么痛苦（）\n但是这种痛苦也是有益的，至少它让我从懵懂的第一周里清醒过来：\n面向对象的挑战，已然开始。\n","date":"2025-03-18T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAoou1-%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/123_hu6378763551609642095.png","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAoou1-%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/","title":"北航OOU1 单元总结"},{"content":"exam 不错的exam。考核内容完全来自于指导书与作业，并且足够全面。 这在lab上机中是很好的设计，掌握不那么牢固的可以通过花费一点时间阅读指导书拿到exam这一主要分数，提升掌握水平 而相对熟练的同学则可以更快地解决exam去攻克extra了。\n另外，一定要认真读前言里的要求！本次exam题就需要先bash init.sh才能得到所需文件\n题目有两道：Makefile与Shell\nMakefile Makefile考的仍然是gcc,run和clean三件套\n1 2 3 4 5 6 7 8 9 10 11 .PHONY: clean all: check.o make check gcc -I ./src/include ./src/main.c ./src/output.c -o ./out/main check: check.c gcc -c check.o check.c run: out/main ./out/main clean: rm -rf check.o rm -rf ./out/main 不过这次在gcc上的考点比较新：\n编译不链接 gcc -c 非标准库头文件 gcc -I 头文件目录 此外，还考查了make A任务内调用make B的内容\n也可以考察跨目录make调用\n即 cd 目录 \u0026amp;\u0026amp; make\nShell 本题一共有九问，也就是九个功能， 比较惹人烦的点在于这九个功能要在9个脚本中分别实现\n如果你足够熟悉， 你可以直接 sed -i '1i#!/bin/bash' exam_*.sh 来为每一行开头加上#!/bin/bash\n九个脚本的内容是：\n在指定目录下新建目录 grep指令 mv指令 cp -r指令 循环语句与sed 替换 通配符* 2\u0026raquo; chmod 条件语句 需要注意的一些点：\n双引号，单引号 取决你是否要解析引号内的内容\n对于awk中$1有特殊含义，便需要单引号处理\n而sed中如果需要$1参数，那当然是要用双引号的\n$符号作为尾行，又是参数解析符号，若要从$1到$进行p，如果写成sed -n \u0026lsquo;$1,$p\u0026rsquo;的话，$1不能解析；写成sed -n \u0026ldquo;$1,$p\u0026quot;的话，p又会被解析。 那么我们可以用空格分隔开。即sed -n \u0026ldquo;$1,$ p\u0026rdquo;\n脚本内加减运算的写法，if,for,while,case的写法\nextra 接下来来到万恶的extra 其本身的难度可能也不能直接称之为高，但是我还是认为应该明确地表示充分利用hint的内容\n因为hint中的内容，不仅太多，而且太重要，太必要！\n对于第二问ln -s的超链接写法，这显然是回去看hint的，因为完全没有听说过\n但是第一问不仅hint很晚才更新，另外还伪装成不用hint也能解决的问题，使很多同学花费了很多时间去用man来看已知指令的参数\n其次，后置测试点依赖前置测试点。虽然他确实对于评测是更方便的，但是偏偏在第一问出现hint的缺失，从而影响到整个题目的得分，给人的体验还是不太好的。\ngenCode 第一问的主要任务是： 对于指定目录下的所有.sh文件，将其经过一些简单的sed文件处理后，以原名称(不含.sh).c的新名字存放在新的指定目录。\n其他的都不难，最难的就在于怎么实现获取文件名与文件重命名\n大多数同学都尝试过sed xxxxxx *.sy \u0026gt; *.c 然后意外的发现只生成了一个名为'*.c'的文件\u0026hellip;\u0026hellip;\n笔者找了找mv的man\nmv是笔者知道的唯一的重命名指令\n然后找到了-S, \u0026ndash;suffix=[后缀名]这样的东西。\n当然并没能实现功能。\n后来助教说extra内容更新了。我看了眼题面，感觉没变，以为是第四第五题改了，就没在意。实际上发布的正是第一题的hint,能够实现对一个目录下所有文件都访问，并获取其文件名。\n那么本题的考点就是awk指令 awk -F.并取$1来获得.sy前面的内容\nselectCode 若存在则删除xxx\n考察的其实是rm -f强制执行（若不存在则自动忽视）\nln -s （hint 超链接操作）\ngcc -I -o\nselectData 本小问需要实现将所有的xx_yy.in与xx_yy.out文件根据参数进行复制。(xx与yy都是随机的)\n若参数为all，则全部复制到指定目录 否则，仅复制参数_yy.in与参数_yy.out到指定目录\n这里可以使用case语句\n1 2 3 4 5 6 7 8 #!/bin/bash mkdir dataSet case $1 in all ) cp -r ./data ./dataSet;; * ) cp ./data/$1* ./dataSet;; esac 注意好格式。\n未知 很遗憾，在我做完二三问，并发现有测试点依赖后，就全力研究第一问了。没能获得第四、五问的题目。同学们可以参考其它博客。\n后记 不同于往年，今年的题目难度确实是大。大多数人都extra都喜提0分（或者未提交） 倘若第一问hint能够正常给出，本次lab的体验感应该还是不错的。\n笔者给extra留了一整个小时还攻不下第一问，可见该hint的重要性（）\n现在想起自己实验报告里写OS多温和什么的，，，\nOS的磨难才刚刚开始。\n","date":"2025-03-14T11:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab0-%E4%B8%8A%E6%9C%BA/123_hu15367369478727297293.png","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab0-%E4%B8%8A%E6%9C%BA/","title":"北航OS Lab0 上机"},{"content":"作业实现 预处理 replaceAll()函数 解决空白符与连续正负号\n表达式解析（递归下降） 递归下降的特点是下降和递归。 下降实现了功能的独立性。 而递归是由要解析的表达式的结构决定的。\nLexer的作用 核心作用是处理数字，将连续的数字字符变为一个token单位\n其他保持不变\n提供方法：\n当前token是什么 peek() 去下一个token next() 其实就相当于C语言字符串中的\nstr[i] i++ 只是我们需要的信息没那么多，就不采用先把式子变成token的ArrayList再去解析的方法 而是在解析的时候利用lexer作为移动和识别的工具\nparseExpr Expr是Term的和\n通过加减符号实现Term的分割\n判加减 (用peek()判内容 用next()进入下一token) parseTerm() addTerm() 循环： 判加减 (用peek()判内容 用next()进入下一token) parseTerm() addTerm()\nparseTerm Term是Factor的积 通过乘号实现Factor的分割（其中第一个Factor可有额外正负号）\n判加减 (用peek()判内容 用next()进入下一token) parseFactor() addFactor()\n循环： 判乘号 (用peek()判内容 用next()进入下一token) parseFactor() addFactor()\nparseFactor Factor约等于解析最底层\n分为三类，需要建立接口\n常数因子与幂函数因子可以用 A*x^b统一 表达式因子分为(Expr)与(Expr)^n\n所以Expr类，Mono类A*x^b和Power类(Expr)^n都需要Factor接口，以在解析完成时返回Factor类型的结果\n其中Expr还能下降为A*x^b，(Expr)与(Expr)^n 因此最小单位就是Mono类A*x^b和Power类(Expr)^n\n解析方法：\n先判一下加减 (用peek()判内容 用next()进入下一token)\n判到左括号 (用peek()判内容 用next()进入下一token) parseExpr(); 把右括号跳过 next() 判^ (用peek()判内容 用next()进入下一token) 有^ : （若有正号先next()掉）peek()读取指数 再next() 指数是0 ： return Mono类 1*x^0 否则： return Power类 无^ ：直接return Expr类 判到数字 (用peek()判内容 用next()进入下一token) Mono类 数字*x^0 判到x Mono类 1*x^n 无^时n=1特殊处理 关于正负：传参 我在解析过程中将正负号落实到了Mono类与Power类 这样，Factor之间只是乘，Term之间只是加，相对简单\n落实的方法: 传参 isNeg 初始参数值，即MainClass调用时是parseExpr(false) 改变的规则：\n根据传入参数，在解析方法定义内部变量isNegative，用于传递给下级 遇到负号，isNegative = !isNegative 对于Expr到Term符号的继承，每一项isNegative的初始值都是isNeg 对于Term到Factor符号的继承，只有第一项isNegative的初始值是isNeg，其余初始值为False 特别的，对于Power类型，其Expr由于先被解析，所以正负号已经落实到内部，这时候Power的正负性就应该做出调整： 若符号为正，则无影响 若符号为负，且指数为奇数，则Power类型应当必须为正数，因为负属性已经在Expr中展现了 若符号为负，且指数为偶数，则Expr的负属性不能展现，Power类型需要为负 最终正负就落实到Mono与Power上，这两个类有isNeg属性\n表达式求值 最终结果为多项式，而Mono和Power也可变为多项式。 只需先转化为多项式，再实现多项式的加与乘即可。\nPoly类 只是有一个TreeMap，里面放着键值对\u0026lt;指数，系数\u0026gt; TreeMap的优势在于merge()方法和有序 merge方法在加入一个键值对可以实现合并同类项的作用\nMono的toPoly() 先处理Negate(),直接系数取负 然后直接new一个Poly，让其TreeMap去put(指数，系数)\nPower的toPoly() 需要有Expr的toPoly(),再使用Poly的幂运算，再实施Negate()\nExpr,Term,Factor的toPoly() Expr就是Term的toPoly()的和 Term就是Factor的toPoly()的积 Factor的toPoly()借助接口就是Mono,Expr与Power的toPoly()\nPoly的加，乘，幂 加法直接merge进去 乘法双重循环一项项merge进去（需注意只有一个因子时，另一个因子应变为\u0026lt;0,1\u0026gt;） 幂可用快速幂，也可直接循环乘。同样注意上述问题。\n当然三种运算最后都应去除系数为0的单项式\n结果的输出 由于结果是多项式，输出相对简单。\n需要注意：\n空Tree要输出0 若存在单项式系数为正，应将其提前并省略正号 指数为0的项只输出数字，指数为1的项只输出x，指数为-1的项只输出-x 中间的正项需额外输出+ 评测机实现 DataMaker 使用c程序，同样使用递归下降的方法去生成表达式\nprintExpr() -\u0026gt; printTerm() -\u0026gt; printFactor() -\u0026gt; \u0026hellip; 用rand()随机项数，因子数，正负号，以及因子的种类等等\nCheck 由于Python库的强大，这里使用了Python的sympy库 检测两个表达式化简结果是否相等，实现了对拍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import sympy x = sympy.symbols(\u0026#39;x\u0026#39;) with open(\u0026#39;./outA.txt\u0026#39;,\u0026#39;r\u0026#39;) as fileA: e1 = fileA.read().replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;) expr1 = e1.replace(\u0026#34;^\u0026#34;,\u0026#34;**\u0026#34;) with open(\u0026#39;./outB.txt\u0026#39;,\u0026#39;r\u0026#39;) as fileB: e2 = fileB.read().replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;) expr2 = e2.replace(\u0026#34;^\u0026#34;,\u0026#34;**\u0026#34;) expr1 = sympy.simplify(expr1, ratio=10) expr2 = sympy.simplify(expr2, ratio=10) if (sympy.simplify(expr1 - expr2) == 0) : print (\u0026#34;True\\n\u0026#34;) else : print (\u0026#34;False\u0026#34;) print (\u0026#34;data:\u0026#34;) with open(\u0026#39;./in.txt\u0026#39;,\u0026#39;r\u0026#39;) as filein: data = filein.read() print (data) print (\u0026#34;right:\u0026#34;) print (e1) print (\u0026#34;yours:\u0026#34;) print (e2) print (\u0026#34;\\n\u0026#34;) 运行脚本 Windows系统的bat脚本和OS学习的Linux脚本异曲同工\n主要使用了这些操作\n指令 作用 REM 注释 java -jar 名称.jar 运行jar包 名称.exe 运行.exe文件 python 名称.py 运行python程序 \u0026lt; ，\u0026gt; 实现重定向 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @echo off for /l %%i in (1,1,100) do ( normaldata.exe \u0026gt; in.txt java -jar oo_homework_2025_xxxxxxxx_hw_1.jar \u0026lt; in.txt \u0026gt; outA.txt java -jar 1.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 2.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 3.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 4.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 5.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 6.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py java -jar 7.jar \u0026lt; in.txt \u0026gt; outB.txt python check.py echo ------------------------------------------------------- ) cmd 如何制作jar包 具体流程可自行搜索。\n文件-\u0026gt;项目结构-\u0026gt;工件-\u0026gt; + -\u0026gt; JAR -\u0026gt; \u0026hellip;\n构建-\u0026gt;构建工件\n","date":"2025-03-03T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAoou1-hw1-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/123_hu15596244839450331959.png","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAoou1-hw1-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","title":"北航OOU1 HW1 表达式解析"},{"content":"实验报告 思考题 Thinking 0.1 文本内容如下图：\n刚刚创建文件后，文件处于未跟踪状态，即Untracked。\n文件被git add之后，被建立跟踪并且进入Staged状态。\n当文件被git commit后，进入未修改状态Unmodified，若增加修改，则变为Modified状态。\n因此结果并不一样。因为第一次add之前，文件尚未被跟踪，文件作出修改也仍会处于Untracked状态。\n而在add与commit之后，文件被跟踪，提交过后的修改会被记录为Modified。\nThinking 0.2 add the file对应git add （第一次add文件） stage the file对应git add （已跟踪的文件经过修改后进行的add，添加到暂存区） commit对应git commit (把暂存区里的内容commit)\nThinking 0.3 代码文件print.c被错误删除时，应当使用什么命令将其恢复？\n应当使用git restore print.c\nprint.c仍然在暂存区，只是在工作区被删除，只需将工作区恢复到暂存区状态即可。\n代码文件print.c被错误删除后，执行了git rm print.c命令，此时应当 使用什么命令将其恢复？\n应当先后使用git reset HEAD print.c与git restore print.c\n因为执行了git rm print.c，暂存区已被改动，所以需要先恢复暂存区的内容。\n无关文件hello.txt已经被添加到暂存区时，如何在不删除此文件的前提下 将其移出暂存区？\n应当使用git rm -cached hello.txt\nThinking 0.4 git log结果如下图：\n版本回退后git log结果如下图：\n版本切换的结果：\n可以看出git reset --hard HEAD^执行后，git log结果并不是1-2-3-2，而是直接变为1-2\ngit reset --hard \u0026lt;hash\u0026gt;对于版本的控制也并不改变目录树，而是在原有的目录树上切换结点。\nThinking 0.5 运行结果如下：\n\u0026gt; 的重定向是覆盖，而\u0026gt;\u0026gt;的重定向是追加。\nThinking 0.6 command内容为：\nresult内容为：\n解释说明：\n为了原样输出test，command每一行的内容为： echo \u0026rsquo; Content \u0026rsquo; \u0026raquo; test (第一行是\u0026gt;)\n其中单引号的目的是保证原样输出，不触发文本中的任何$符号与\u0026gt;符号\nresult的内容有两部分， 一是test运行的输出结果会重定向到result， 二是test文件本身也有重定向到result的代码\n思考问题：\n若把echo echo Shell Start的echo Shell Start用反引号引起来 则会将反引号内指令的运算结果变为一个字符串\u0026quot;Shell Start\u0026quot; 最终整条指令结果为Shell Start\n而echo echo Shell Start的结果是echo Shell Start\necho echo $c\u0026gt;file1则同理，加上反引号后指令会输出3 而不加反引号应输出echo $c\u0026gt;file1，结果不同。\n难点分析 Lab0作为大家走向OS的过渡课程，其思维难度不高，重难点在于对各种指令的运用。\n如sed awk grep等方法的运用，单引号、双引号与反引号的灵活使用等等\n实验体会 目前尚未进行上机的限时测试，而日常实验的训练，很像我第一次搭建OO评测机时，一点点探索与学习的过程。\n感性的话不必多说，但是to be honest, OS的lab0相较于CO的P0-P2以及OO的U1，已然是非常温和了。\n","date":"2025-02-27T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/Ark_hu14773038926689544259.png","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAos-lab0-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","title":"北航OS Lab0 预备知识"},{"content":"技术是中立的吗？为什么？ 技术中立这个观点是一个复杂且具有争议性的话题。 从某种纯粹的工具论角度来看，技术可以被认为是中立的。 技术就像一个空白的容器，本身没有内在的道德或价值取向。 以互联网技术为例，它仅仅是一系列协议、代码和硬件设施的组合。 在其最基础的层面，它只是实现信息传输的工具。 从这个意义上说，技术本身不会主动地产生好或者坏的影响。 再以电为例，它可以驱动医疗设备拯救生命，也可以在被错误使用时导致触电事故致人死亡。 这种中立性在于技术的本质是一种手段，它等待着人类的使用和赋予意义。\n然而，技术进入社会应用领域，具有社会性，便不再是中立的。 首先，技术的研发动因就不是中立的。 技术研发往往受到社会、经济、政治和文化等诸多因素的影响。例如，军事技术的研发通常是基于国家的战略需求和安全考虑，这其中就蕴含着国家利益、地缘政治等非中立因素。而且，研发资金的来源也会对技术的走向产生影响。如果技术研发主要由追求利润最大化的商业公司资助，那么这些技术很可能会朝着有利于商业利益的方向发展，而不是以社会公益为首要目标。\n技术的设计过程不中立。 工程师在进行技术设计时会有意或无意地将自己的价值观念嵌入其中。 人工智能系统的训练数据选择、算法的设计都会受到开发者价值观的影响。 这使得技术产品本身就带有某种价值倾向。\n技术的应用效果不中立。 社交媒体平台的算法推荐系统就是一个很好的例子。这些算法根据用户的浏览历史、点赞、评论等行为来推荐内容。 从技术实现角度看，这是通过复杂的数据分析和机器学习算法完成的， 但在实际应用中，这种推荐系统可能会导致信息茧房的形成。 因为算法会倾向于推送用户感兴趣的内容， 而用户可能会逐渐只接触到符合自己既有观点的信息， 这对社会的多元交流和民主进程可能会产生负面影响。\n技术的传播和普及也不是中立的。 不同的社会群体对技术的接受程度和使用方式是不同的，这可能会加剧社会的不平等。 例如，在数字技术时代，那些能够熟练掌握信息技术的人更容易获取信息、教育资源和工作机会， 而缺乏数字技能的人群则可能被边缘化。 技术往往会强化既有的社会权力结构。掌握先进技术的群体往往能获得更大的社会影响力， 而技术鸿沟则可能加剧社会不平等。 这种数字鸿沟现象表明技术在社会中的应用会受到社会结构和权力关系的影响。\n技术的长期影响也难以被简单地归结为中立。 以核能技术为例，核电站可以提供大量的清洁能源，减少对传统化石燃料的依赖。但是，核废料的处理以及核电站事故的潜在风险（如切尔诺贝利和福岛核事故）给生态环境和人类健康带来了巨大的威胁。这种长期的、复杂的影响使得我们不能简单地将核能技术视为一个中立的工具。\n综上所述，虽然技术在最基本的工具属性层面可以被看作是中立的， 但在研发、应用、传播和长期影响等各个环节， 技术都与社会、经济、政治和文化等因素相互交织，很难再维持完全中立的立场。 监控资本主义是一个不可避免的趋势吗？我们有什么办法改变它？ 监控资本主义目前呈现出一种较为强劲的发展态势，但它并不是不可避免的趋势。 监控资本主义的兴起是多种因素共同作用的结果。 在数字经济时代，数据被视为新的石油。 企业为了追求经济利益，有强烈的动机去收集用户数据。 互联网公司通过提供免费的服务， 如社交媒体平台、搜索引擎等，吸引用户， 然后利用用户数据进行精准广告投放、市场调研等活动来获取利润。 随着技术的不断进步，数据收集的手段越来越多样化和隐蔽化。 例如，通过物联网设备收集用户的生活习惯数据，从智能家居系统到可穿戴设备，这些数据的价值不断被挖掘。\n然而，这种趋势并不是不可避免的。 从社会意识角度来看，公众对数据隐私的关注度在不断提高。 随着一些数据泄露事件的曝光和隐私侵犯问题的凸显，人们开始意识到自己的数据被滥用的风险。 消费者逐渐要求企业对数据的收集和使用更加透明，并加强数据保护。 这种社会意识的觉醒为改变监控资本主义提供了动力。\n在法律层面，政府可以通过加强立法来限制监控资本主义的过度发展。 例如，制定严格的数据保护法规，明确企业在数据收集、存储、使用和共享等环节的责任和义务。 欧盟的《通用数据保护条例》（GDPR）就是一个很好的例子。 它赋予了用户对自己数据的更多控制权，如数据访问权、被遗忘权等， 同时对违规企业处以高额罚款。 这使得企业在收集和处理欧洲用户数据时必须更加谨慎。\n技术手段也可以用来对抗监控资本主义。 隐私增强技术的发展为用户提供了保护自己数据的工具。 例如，加密技术可以确保数据在传输和存储过程中的安全性。 差分隐私技术可以在不泄露个体隐私的情况下进行数据分析。 此外，去中心化的数据存储和管理方案，如区块链技术，也可以减少企业对用户数据的集中控制。\n从企业社会责任角度来看，企业本身也可以进行自我约束。 一些有远见的企业已经意识到，长期的信任关系建立在对用户隐私的尊重上。 通过建立合理的数据治理框架，企业可以在获取商业利益的同时，保护用户的隐私权益。 例如，苹果公司在数据隐私保护方面采取了一系列措施，如端到端加密等，赢得了用户的信任。\n改变监控资本主义还需要加强国际合作。 由于互联网和数据的跨境流动，单个国家的法律和措施可能效果有限。 国际组织和各国政府需要共同制定全球统一的隐私保护标准和数据治理规则，共同打击跨境数据滥用行为。 同时，推动数据伦理的研究和教育，让人们从道德层面认识到监控资本主义的危害，也是改变这一趋势的重要途径。\n学校是否有权使用人脸识别对学生进行考勤？为什么？ 学校是否有权使用人脸识别进行考勤是一个涉及到多方面权益平衡的复杂问题。 学校管理的角度来看，学校有一定的理由使用人脸识别考勤。 学校是一个有组织的教育机构，需要对学生的出勤情况进行有效的管理。\n人脸识别考勤系统可以提高考勤的效率和准确性。 相比于传统的考勤方式，如点名或者刷卡，人脸识别可以在短时间内快速识别大量学生，减少人工考勤的时间和误差。 这有助于学校更好地掌握学生的出勤动态，及时发现学生的异常出勤情况，如旷课、迟到等， 从而可以采取相应的措施，如与家长沟通、进行教育辅导等，保障学生的正常学习秩序。\n在校园安全方面，人脸识别考勤系统也可以发挥一定的作用。 通过对进出校园人员的识别，可以有效防止外来人员未经许可进入校园，保障师生的人身安全和学校的财产安全。 特别是在一些安全形势较为复杂的地区，这种安全保障功能显得尤为重要。\n从学生隐私的角度来看，人脸识别考勤的使用存在诸多争议。 学生的人脸信息属于个人敏感信息，涉及到个人隐私。 学校收集和使用这些信息可能会侵犯学生的隐私权。\n人脸识别技术的准确性虽然在不断提高，但仍然存在一定的误差。 例如，可能会出现误识别的情况，将一个学生错误地识别为另一个学生，这可能会对学生的正常学习生活造成不必要的干扰。\n人脸信息一旦被收集，就存在数据泄露的风险。 学校的信息管理系统可能会受到网络攻击，导致学生人脸信息被盗用。 这些信息如果落入不法分子手中，可能会被用于身份盗窃、诈骗等违法犯罪活动。 而且，学生作为未成年人，其对自己的隐私权益的认知和保护能力相对较弱，学校更应该谨慎对待他们的隐私信息。\n从法律层面来看，目前关于学校使用人脸识别技术的法律规定还不够完善。 在不同的国家和地区，对于个人数据保护和学校管理权限的界定存在差异。 在一些地方，法律要求在收集和使用个人敏感信息时，必须获得学生本人或者其监护人的明确同意。 这意味着学校不能随意使用人脸识别考勤系统，而需要遵循法律程序，尊重学生和家长的意愿。\n为了平衡学校管理和学生隐私保护，学校如果要使用人脸识别考勤系统，应该采取一系列措施。 学校需要向学生和家长充分说明 充分说明人脸识别考勤系统的目的、用途和数据安全保障措施，获得他们的书面同意。\n学校应该建立严格的数据管理制度 确保学生人脸信息的存储安全，如采用加密存储、限制数据访问权限等措施。\n学校要定期对考勤系统进行评估 确保其准确性和安全性，及时处理出现的问题，如误识别和数据泄露风险。\n非必要情境避免使用 如果学校仅仅为了提高管理效率而使用人脸识别技术， 则应考虑是否可以通过其他较为低风险的方法（如二维码签到、指纹识别等）代替。\n什么是自动驾驶的电车难题？自动驾驶系统应该如何应对电车难题？ 自动驾驶的电车难题是一个极具挑战性的伦理困境，它源于经典的哲学“电车难题”。 在自动驾驶场景中，电车难题可以这样描述： 假设一辆自动驾驶汽车在行驶过程中遇到了不可避免的碰撞情况， 例如前方突然出现了一群行人闯红灯，而汽车的制动系统无法及时避免碰撞， 同时车辆旁边是一个坚固的障碍物， 汽车有两个选择，要么直接撞向行人， 要么转向撞向障碍物，而这样可能会对车内乘客造成严重伤害。\n这种情况引发了深刻的伦理和道德争议。\n从功利主义的角度来看，可能会认为应该选择牺牲车内乘客或者少数人的利益来保护多数人的生命安全 也就是撞向障碍物避免撞到更多的行人。 但这种观点忽略了车内乘客的权益，他们购买了汽车服务并且期望汽车能够保障他们的安全。\n优先保护车内乘客也有其合理性 因为汽车是由乘客购买和使用的服务，而且乘客本身并没有过错。\n对于自动驾驶系统如何应对电车难题，目前有多种不同的观点和方案。 设计一种能够避免做出伤害生命决策的自动驾驶系统。 例如，通过改进汽车的传感器和制动技术，尽可能地避免出现电车难题这种极端情况。 当检测到可能出现碰撞风险时，汽车可以提前发出警报，同时采取紧急制动或者避让措施， 如降低车速、转向到相对安全的区域等，以最大程度地减少伤害。 这种方案强调技术改进来避免伦理困境，但是技术的发展可能无法完全消除所有的风险情况。\n按照预先设定的道德和法律规则来应对。 例如，可以通过立法或者行业标准制定出一套统一的决策规则。 比如在遇到上述电车难题场景时，规定自动驾驶汽车应该优先保护多数人的生命安全。 然而，这种方案也面临着巨大的挑战。 首先，道德和法律规则很难达成完全一致的共识。 不同的文化、宗教和社会群体可能对这种生死抉择有不同的看法。 其次，一旦通过立法确定了这样的规则，可能会引发一系列社会问题。 例如消费者对自动驾驶汽车安全性的担忧，导致他们不愿意购买和使用自动驾驶汽车。\n采用随机化策略。 即当遇到电车难题这种不可避免的碰撞情况时，自动驾驶系统随机做出决策，不设定固定的优先保护对象。 这种方法的优点是避免了预先设定规则可能带来的争议，因为它没有对生命的价值进行明确的排序。 但是，随机化策略也很难被社会所接受，因为人们很难接受自己的生命安全或者他人的生命安全是由随机因素决定的。\n可以将决策权交给用户。 在购买自动驾驶汽车时，用户可以根据自己的价值观和意愿选择不同的碰撞应对策略。 然而，这种做法可能会导致混乱的交通规则和不一致的决策， 而且用户可能在没有充分考虑的情况下做出选择，或者在事故发生后改变主意。\n自动驾驶的电车难题是一个复杂的伦理和技术问题，需要综合考虑道德、法律、社会和技术等多个因素来寻找合适的应对方案。\n是否应该禁止或限制性爱机器人的研发、生产与销售？为什么？ 关于是否应该禁止或限制性爱机器人的研发、生产与销售，这是一个充满争议的伦理和社会问题。\n从伦理角度来看，有观点认为应该禁止或限制。 性爱机器人可能会改变人类的情感观念和性观念。 人类的情感和性是建立在人与人之间的互动基础上的，涉及到复杂的心理、生理和社会因素 。性爱机器人的出现可能会导致人们对真实的人际关系产生扭曲的理解。 例如，使用者可能会过度依赖机器人来满足性需求，从而减少对真实人类伴侣的情感投入和沟通。 这可能会对传统的婚姻和家庭观念产生冲击，引发一系列社会问题，如婚姻关系的不稳定、家庭凝聚力的下降等。\n性爱机器人的存在可能会引发道德争议，特别是在涉及到机器人的权利和地位问题上。 如果性爱机器人被设计得过于逼真，人们可能会对其产生类似对待人类的情感。 那么，是否应该给予机器人某种形式的“权利”，如不被虐待的权利等，这是一个尚未有定论的伦理困境。 此外，性爱机器人的研发和使用也可能会导致人类性观念的进一步开放和混乱，使得社会的性道德标准变得模糊不清。\n从社会影响角度看，性爱机器人可能会被用于非法和不道德的用途。 例如，容易成为传播色情内容的工具，尤其是当机器人的形象涉及儿童或被用于模拟非法的性场景时， 这会对社会的公序良俗和未成年人的身心健康造成严重的损害。 而且，大规模的性爱机器人的存在可能会改变社会的性别观念和性别关系。 如果机器人被设计成具有特定的性别特征，可能会强化社会中的性别刻板印象，或者导致对某些性别群体的不公正对待。\n根据主奴辩证法，依赖性爱机器人会形成虚假自由与自我奴役 在主奴辩证法中，主人虽然看似掌握权力，但实际上依赖奴隶的劳动维持其主导地位。这种依赖使得主人的自由是虚假的。 同样地，性爱机器人对使用者提供的“顺从”和“服从”可能让使用者感到掌控一切， 但由于这些互动是单向的、非自主的，使用者的满足感和自我认同可能是浅薄的。 性爱机器人的“服务”并没有通过相互承认的对话建立真实的主体性，因此使用者的自由和主体性也是不完整的。\n此外，人类成为了自己创造的技术的奴隶。这种依赖不仅局限于身体需求，还涉及情感和心理层面。 过度依赖性爱机器人可能削弱个体的情感自主性和社会互动能力，使得人类失去了通过复杂的关系获得自我提升的机会。\n也有观点认为不应该禁止。 从科技发展和商业角度来说，性爱机器人的研发是科技进步的一种体现。 机器人技术的发展可以带来许多创新的应用，性爱机器人只是其中之一。 在合理的监管下，这种研发可以推动机器人技术在材料、人工智能、机械设计等多个领域的进步。 例如，研发更加逼真的触感材料和自然语言处理技术可以用于提高性爱机器人的性能， 而这些技术也可以被应用到医疗康复机器人、服务机器人等其他有益的领域。\n从性健康角度来看 对于一些特殊人群，如性压抑人群或者残疾人群体，性爱机器人可能会提供一种相对安全和私密的性满足方式。 只要能够确保这种使用不会对他人和社会造成伤害，并且符合伦理道德标准， 例如通过严格的身份认证和使用场景限制，那么它也可以被视为一种解决方案。\n为了平衡这些不同的观点和利益，在不禁止的情况下，需要建立严格的监管机制。 对性爱机器人的研发设计进行伦理审查 确保机器人的形象、功能和使用场景不会违反社会道德和法律规定。\n在销售环节，要严格限制购买者的年龄和身份 防止其被用于非法目的。\n加强社会教育，引导人们正确看待性爱机器人 避免其对社会伦理观念和人际关系产生不良影响。\n什么是致命性自主武器？是否应该禁止或限制致命性自主武器的研发和使用？为什么？ 致命性自主武器是指能够在没有人类干预的情况下自主选择和攻击目标的武器系统。 这些武器通常利用先进的传感器、人工智能算法和武器技术来实现自主作战。 例如，一些军事无人机可以通过预先编程的算法和传感器探测系统，在识别目标后自动发射武器进行攻击。\n从伦理道德的角度来看 应该禁止或限制致命性自主武器的研发和使用。\n致命性自主武器的使用可能会导致责任归属的模糊。 当这些武器自主做出攻击决策并造成伤害时，很难确定责任是在于武器的编程者、使用者还是武器系统本身。 这种责任的不明确性违反了基本的道德原则，即人类应该对自己的行为和造成的后果负责。 在传统的战争和军事行动中，人类战士在做出攻击决策时会考虑到道德、法律和伦理因素， 如区分战斗人员和平民、评估攻击的必要性和比例性等。 而致命性自主武器可能无法像人类一样进行复杂的道德判断，从而增加了无辜人员伤亡的风险。\n致命性自主武器可能会降低发动战争的门槛。 如果一个国家可以通过使用致命性自主武器来进行军事行动， 而不需要承担太多的人员伤亡风险， 那么战争可能会变得更加容易被发起。 这会对国际和平与安全秩序造成严重的威胁，引发军备竞赛。 各国为了保持军事优势，可能会竞相研发和部署更先进的致命性自主武器，导致军事紧张局势不断升级。\n从法律层面来看 目前的国际人道法和战争法是基于人类的行为和决策制定的。 这些法律在面对致命性自主武器时存在明显的滞后性。 例如，在区分合法与非法目标、进行攻击的比例性评估等方面， 现有的法律框架很难适用于自主武器系统。 这就需要对法律进行更新和完善，但这是一个复杂且漫长的过程。 在法律尚未完善的情况下，禁止或限制致命性自主武器的研发和使用可以避免出现法律空白和滥用武器的情况。\n从技术风险角度看 致命性自主武器也存在诸多问题。人工智能算法的可靠性和安全性是一个关键问题 。算法可能会出现错误、被黑客攻击或者受到数据偏差的影响。 例如，一个被篡改的算法可能会导致武器系统攻击错误的目标， 或者在不需要攻击的时候发动攻击。 这种技术上的不确定性和风险使得致命性自主武器的使用变得极其危险。\n在一定程度上可以对致命性自主武器进行研究，但需要严格的限制和监管。 支持者认为，这些武器的某些技术，如先进的传感器和目标识别技术，可以用于非致命性的军事防御目的， 如边境监控、反海盗等。但这种观点也面临着巨大的挑战， 因为很难确保这些技术不会被用于致命性自主武器的研发和升级。\n综上所述，考虑到伦理道德、法律、国际安全和技术风险等多方面因素，禁止或限制致命性自主武器的研发和使用是十分必要的。\n什么是算法歧视？形成的原因是什么？如果解决算法歧视问题？ 算法歧视是指算法在决策过程中，由于数据偏差或算法设计等原因，偏向特定群体或不公平地对待某些群体的现象。 例如，在招聘算法中，如果算法是基于过去的招聘数据进行训练， 而过去的招聘数据本身存在对女性或者少数族裔的偏见， 那么这个算法在筛选简历时就可能会倾向于选择男性或者主流族裔的候选人， 从而对女性和少数族裔产生歧视。\n算法歧视形成的原因主要有以下几个方面。 数据偏差。 训练算法的数据往往是从现实世界中收集的， 而现实世界的数据可能本身就存在各种偏见。 例如，在犯罪预测算法中，如果用于训练的数据是基于过去的犯罪记录， 而过去的犯罪记录由于执法过程中的种族偏见等因素， 对某些种族群体的数据记录过多，那么算法在预测时就可能会高估这些群体的犯罪概率。\n设计偏见。 算法的规则和目标设定可能会无意中导致歧视。 例如，一个简单的信用评分算法可能只考虑了收入和资产等因素， 而忽略了一些弱势群体可能由于社会结构原因导致收入较低， 但实际上他们的信用风险并不高。 算法开发者在设计过程中如果没有充分考虑到公平性问题， 就容易产生歧视性的结果。\n反馈循环。 在一些推荐算法中，用户的行为数据会不断反馈到算法中，形成“反馈循环”。 这种反馈循环可能会逐渐放大原本的偏见。\n要解决算法歧视问题，可以从以下几个方面入手。 改进数据质量。 在收集和整理数据时，要确保数据的多样性和代表性，避免使用带有明显偏见的数据。 例如，在招聘算法中，要对过去的招聘数据进行清洗， 去除可能存在的性别、种族等方面的偏见信息， 并且主动收集不同群体的数据来平衡数据集。\n引入算法公平性评估。 在算法开发过程中，引入公平性约束条件。 例如，采用公平机器学习算法，这些算法在优化目标函数时， 除了考虑准确性外，还会考虑公平性指标。 同时，在算法设计阶段，要进行充分的公平性测试， 通过模拟不同场景和不同群体的数据输入， 检查算法是否会产生歧视性的输出。\n引入算法偏差测试。 定期对算法进行审计，评估算法是否存在歧视问题。 算法审计可以由内部的审查团队或者外部的独立机构来进行。 通过对算法的输入输出数据进行分析，检查是否存在对某些群体的不公平对待。 如果发现歧视问题，及时对算法进行调整和优化。\n提高算法的透明度与解释性。 让算法的决策过程更加透明，使得用户和监管者能够理解算法是如何做出决策的。 例如，对于一些影响重大的算法， 如信贷审批和司法量刑算法，要求提供决策的解释， 这样可以帮助发现潜在的歧视因素。\n用户反馈和持续优化。 允许用户标记算法的不公平现象，以便于追踪和优化。 通过收集用户反馈不断更新算法，确保其适应多样化的需求。 实行定期评估和调整，避免算法逐渐偏向某类用户或群体。\n在人工智能和大数据时代，个人隐私还存在吗？如何才能更好地保护隐私？ 在人工智能和大数据时代，个人隐私依然存在，但面临着前所未有的挑战。 现状 随着人工智能和大数据技术的发展，个人数据的收集和处理变得更加广泛和精细。 人工智能依赖于大量的数据，尤其是用户的个人数据、行为数据等，用以训练模型和进行预测分析。 大数据技术使得我们能够从海量的数据中提取出与个人行为和偏好相关的信息， 这些信息一旦泄露或滥用，将对个人隐私构成严重威胁。\n例如，许多社交媒体平台和搜索引擎会通过收集用户的浏览历史、搜索记录、地理位置等数据来推送定制广告。 这些数据的收集和使用往往是在用户未完全意识到的情况下发生的， 造成了隐私泄露的风险。 此外，数据泄露事件频发，许多公司由于保护不当而导致用户数据的大规模泄露，给个人隐私带来了极大风险。\n然而，虽然技术和社会环境的变化让隐私面临压力， 但通过法律保护、技术创新以及公众意识的提高，个人隐私仍然可以得到有效的保护。\n隐私保护 法律法规不断完善来保护个人数据权益。 隐私保护首先要依靠法律。在许多国家和地区，隐私保护法律正在逐步完善。 例如，欧盟的《通用数据保护条例》（GDPR）规定了对个人数据的严格保护， 要求企业必须获得用户同意才能收集其数据，并且允许用户要求删除或更正个人数据。 各国应尽快制定类似法律，加强隐私保护的力度，确保数据收集和使用符合公平和透明的原则。\n隐私保护技术不断发展。 加密技术是保护隐私的关键手段之一。 通过对数据进行加密，即使数据在传输过程中被截取或者在存储过程中被非法访问， 没有解密密钥，数据也无法被读取。 例如，端到端加密技术在即时通讯应用中得到广泛应用，确保只有通讯双方能够读取消息内容。\n差分隐私技术也是一种新兴的隐私保护技术。 它通过在数据集中添加噪声的方式来进行数据分析， 使得在不泄露个体隐私的情况下仍然能够获取有价值的总体数据信息。 例如，在统计某种疾病的发病率时， 通过差分隐私技术可以在不暴露个体是否患病的情况下 得到准确的发病率统计数据。\n个人也需要增强隐私保护意识。 在使用各种数字产品和服务时，要仔细阅读隐私政策， 了解自己的数据是如何被收集、使用和共享的。 并且，要谨慎授予应用程序各种权限，如位置权限、通讯录权限等，只授予必要的权限。\n企业作为数据收集者和使用者，也有责任保护用户隐私。 企业应该建立完善的数据安全管理体系，加强数据安全防护措施，防止数据泄露。 同时，要提高数据处理的透明度，向用户明确说明数据的用途和处理方式。\n加强教育和宣传，提高全社会对隐私保护的重视程度也是非常重要的。 通过开展隐私保护知识培训和宣传活动， 让人们了解隐私的重要性和隐私保护的方法，营造一个良好的隐私保护社会环境。\n作为计算机专业的学生，你如何看待人工智能的未来？ 作为计算机专业的学生，我认为人工智能的未来充满了机遇和挑战。 从机遇方面来看，人工智能将推动各个领域的技术创新和产业升级。 在医疗领域，人工智能可以帮助医生进行疾病诊断。 例如，通过对大量的医学影像（如X光、CT等）进行分析， 人工智能算法能够快速准确地发现病变特征，辅助医生做出更精准的诊断， 提高诊断效率和准确性。同时，人工智能还可以用于药物研发， 通过对药物分子结构和疾病靶点的模拟分析，加速新药的研发过程。\n在交通领域，自动驾驶技术是人工智能的一个重要应用方向。 它有望提高交通效率，减少交通事故。 通过传感器和复杂的算法， 汽车能够感知周围环境并做出智能决策，实现自动行驶。 这不仅可以缓解交通拥堵，还能为人们提供更加舒适和安全的出行体验。\n在教育领域，人工智能可以实现个性化学习。 通过对学生学习数据的分析，如学习进度、知识掌握程度等， 人工智能可以为每个学生量身定制学习计划， 提供针对性的学习内容和辅导，提高学习效果。\n在工业制造领域，人工智能驱动的智能制造可以提高生产效率和产品质量。 机器人可以在人工智能的控制下进行复杂的生产操作， 通过对生产数据的实时监测和分析，及时发现生产过程中的问题并进行调整。\n人工智能的未来也面临着诸多挑战。 算法偏见问题 这可能会导致不公平的决策。 如前面提到的在招聘、信贷等领域， 由于训练数据的偏见或者算法设计的缺陷， 可能会对某些群体产生歧视性的结果。 解决算法偏见问题是人工智能健康发展的关键。\n伦理问题。 例如，人工智能在军事领域的应用可能会引发人道危机， 如致命性自主武器的研发和使用。 在日常生活中，人工智能也会涉及到隐私侵犯、数据滥用等伦理问题。 如何在发展人工智能的同时，遵循伦理道德原则，是需要深入思考的问题。\n失业问题。 随着人工智能技术的发展， 一些重复性、规律性强的工作可能会被人工智能系统和机器人所取代。 例如，一些数据录入员、客服代表等岗位可能会受到影响。 这就需要社会建立完善的职业培训和再就业体系，帮助人们适应新的就业环境。\n作为计算机专业的学生 我们要积极参与到人工智能的研发中，致力于开发更安全、公平、符合伦理的人工智能系统。\n在算法设计阶段，要充分考虑公平性和安全性，避免算法偏见。 作为计算机专业的学生，我们应关注AI伦理问题，从数据采集到算法设计， 都要考虑如何避免偏见、保护隐私、保证公平性，确保AI技术符合道德规范。\n要加强与其他领域的合作，共同制定人工智能的发展规则和伦理准则。 如伦理学、法学等，推动人工智能健康、可持续地发展。\n","date":"2025-01-09T10:30:30+08:00","permalink":"https://demiurge-zby.github.io/p/%E6%B3%95%E5%BE%8B%E7%A7%91%E6%8A%80%E4%B8%8E%E7%A4%BE%E4%BC%9A/","title":"法律、科技与社会"},{"content":" 说在前面 本系列从P6上机结束开始制作，因此靠前的一些P可能记不清楚 本系列主观色彩较强，不过尚有一定准确信息 作者在P6献出首挂，并玉玉了一周（？） 接下来，就以我的吐槽为主了\nPre上机 考三道题，分别为logisim,verilog,MIPS\n原120min延时到180min\nlogisim考查：\n同步复位：不能使用clk和reset的与（clk在上升沿与clk == 1是两个概念！）\n正确的方法：1. 用reset，MUX控制输入数据，再把修正后的数据传给寄存器 2. 不使用MUX，而是将reset取反（再位拓展）后与Data与起来(reset==1时，结果为0\u0026amp;Data=0)，这样来控制输入数据 实质上两种方法都是保证给要写入寄存器的值做一个实时修正 保证只有上升沿那一瞬间，才能决定是否进行复位\n状态机： 已经很久远了，个人认为把斐波那契这种高阶的弄会就好\n加入An传进寄存器1，再传进寄存器2，再传进寄存器3, 那么当寄存器3为An时，寄存器2即为A(n+1)，寄存器1为A(n+2) 这就是logisim里暂时保留数据若干个时钟周期的途径\nverilog和MIPS考得都很水\n建议一定要学好verilog的组合逻辑循环怎么写 或者你能够熟练地打表 让你求32位的和，你就用C写出来一个a[0]+a[1]+\u0026hellip;倒也未尝不可\n1 2 3 4 5 always@（*）使用说明 0.全使用= 1.初始化（所有变量） 2.全是reg型和integer型 3.有用的东西最后再assign到某个wire变量上去 P0上机 三道题，logisim练习\n原120min延时到180min\n是谁国庆前一晚还在上机啊\n但是贴心的助教们出了一次极水极水的题！\n考察内容：善于封装子模块、Mealy(米利)机和Moore(摩尔)机的判别\n大家都是一路AC\n我WA了一次，比较器要设置成Unsigned！！！\nP1上机 三道题，verilog练习\n原120min延时到180min\n一般是一个简单的组合逻辑加两个状态机\n本来以为没有延时，差点以为要挂了，所以第二题做出来就开始摆了\n错因没有什么价值，纯粹打错符号了\n第三题是一个很复杂的状态机 难度堪比cpu_checker(笑)\n最后搭出来WA了几个点，也没弄明白WA在哪\nP2上机 三道题，MIPS练习\n原120min延时到180min\nT1 未给出C代码 题面如下：\n已知b,m,n，在[m,n]中找出一个整数a，使得a%b最小，输出a%b 看起来还唬唬人，但是真从m循环到n不动一点脑子肯定是会TLE的\n这东西他让你输出的是余数，那可就太简单了 要么是0，要么是m%b 如果是0，说明m到n存在b的倍数，那么n/b就不等于m/b 所以其实就是考察div,mfhi,mflo的使用 伪代码如下\n1 2 3 4 5 6 if (m / b != n / b) { printf(\u0026#34;0\u0026#34;); } else { printf(\u0026#34;%d\u0026#34;, m % b); } 有没有\\n我忘了（）\nT2考循环T3考递归 都有C语言代码，静静翻译就好，一般不会有bug 如果有，着重检查你的bgt,blt,beq,bne等等是否写反\n递归就着重两个字“保护” 保护的时间是jal前和jal后（物理意义，不是代码执行顺序） jal前表示进入递归之前做好现场保护 jal后则是退出上一层递归回到jal的PC+4的位置,恢复当时现场\nP3上机 终于来到我们的CPU阶段！ 以及闯关制的开始。\n最后一次使用logisim\n自此开始，课上是否通过基本等价于课下搭的CPU是否有误\n三道题，新指令添加\n原120min延时到150min（这个不同届不一样）\n本次没有明显感受，难度不太高 课下的记忆点更充实些\nP4上机 三道题，新指令添加\n120min 无延时。\n题目也不难，和T3难度相当\n作者没能AK。\n因为有课下bug!!!!!\n但是这个bug太小了。 jr $rs而非jr$31\n玉玉随笔：\n历经了轮轮评测， 也从未想过要在课上debug。 但我看到了完全与题意无关的报错信息， 我意识到了课下着实存在着的bug， 我惊惶，但又或是接受，接受我真的会在P4倒下，会在这条闯关路上走得一坨烂泥。 在课上最终de出了bug，确是万幸。 只是那瞬间，无休止的荒诞涌进一触即破的思绪， 畏惧后怕质疑庆幸猛地迸发开来， 只留呆滞的躯体挪动着不太灵光的鼠标， 看着界面的圆圈转着转着，拉着我去和P4说再见了。 P5上机 120min 无延时。\n课上过一题 = 课下没问题 = P5必通过！\n前两题顺风顺水 第三题做的悠哉悠哉不知不觉只剩10min\n交了一发 10个点过9个 挂了个TLE\n意识到这题卡时间 阻塞条件再细化 但是始终没有落实到寄存器冲突上 再交还是TLE 只剩下2min了 那 就交卷吧\n越是静下来，越是容易意识到问题关键 为什么当时不把那17个寄存器都排除呢？ 阻塞条件一定要细化！！ 只是担心于它的不确定性，怎么不去研究他的变化范围。\n2min很漫长。等了很久，等考试结束， 等未通过的同学都离开考场， 等问答环节来临， 我问助教究竟要优化到什么等级： 答案显然。 对于一定不被写的15个寄存器，不会有转发当然不必阻塞。\nP6上机 —— 1 史上最惊为天人的一集\n真的有人课下没bug课上还能全挂？！！\nT1时序逻辑掺组合逻辑 在乘除模块里求最高位1最低位0结果一直输出xxxx 结果是因为没初始化 一de就是80min\nT2更是荒谬 32位累加没有设置位宽 这么简单的问题在当时混乱的大脑下藏了40min\n后续又做了一堆无用功，漫无目的地构造测试数据，感动自己地打表等等。。\n最终以0题通过幸终。\nP6上机 —— 2 时隔一个月的90min AK\n怀揣着极度的不安与不满，\n因为我真的不能保证我的课下确无问题。\n就这样 踏入了大家都在P7gap的空旷的考场\nT1已经退化成add类指令了。。 只是写入的值换成add结果的最高位1\n最高位1？这我可太熟了（苦笑 这不上周给我绊死的那位嘛 这周周中好好地跟他清算了一波 没想到还能见面，那就再也不见了\nT2一看条件存储，我先跳了\nT3经典跳转类 完成基础功能TLE最后一个点 乘除模块偷跑却又超速一个点 意识到不能暗改乘除 但是我也不知道怎么做\n此时我智慧的大脑居然认为测试点出错了 肯定有死循环 不然我有的点过快了这个点还能过慢？\n然后去做P2了 大致扫一眼：什么条件跳转。。原来是标题欺诈。 再定睛一看：啊？又是最高位1？ 只是把DM写的地址加上了一个与最高位1有关的数\n最麻烦的事大抵也就是DMWr的位扩展 但是还好我提前改成三位了\nT2过关，我开始回去看T3\n诶诶 这个T3一个点TLE 这不就是我的P5吗？？\n我P5的反思居然还派上用场了 我开始去思考我的阻塞\u0026hellip;\u0026hellip; 用不到，不需转发就不阻塞！！ 又写了四行优化阻塞逻辑 交了一发终于AC。\n最后，还是喷一下上周。 课下无bug课上全挂真是神人了。\n另外，如果感觉自己课下没bug还课上全挂的别担心 你的课下可能确无bug 考场上的蠢度永远是自己无法想象的。\nP7上机 —— 1 紧接上文，考场外的蠢度你也无法想象。\n四道强测： 功能强测 异常强测 中断强测 冒险强测\n一道附加指令：Withdraw\n120min\n刚开始交前四题，全挂。\n我有点崩溃，但是看到大家也是一片红，我深深感觉到强测之强。\n（其实很多人都一遍过，只是我没看见）\n直到\u0026hellip;\u0026hellip;zzy 60min交卷 zjy 70min交卷\n我开始怀疑自己是不是真的写的太烂了。\n一直到我看到ALE里面没引入Instr，我终于意识到： 我最新版没提交！！！\n一瞬间，像是通过了一束电流，整个人呆住了。\n急忙地改回代码，中间还改错了一次，漏写了一个接口，让我期待落空了几分钟。。\n不过当我把新版本改好，漫长的排队等待\u0026hellip;\u0026hellip;\n绿了，绿了，红了？绿了？ 还差一个中断异常，有2个点挂了。\n中断区别于异常，我觉得比较易错的是空泡的处理，琢磨了一段时间，我好像意识到自己应当采用两种不同的流水方式。\n但是这时已经8:55了。如果我提交并通过，我将没有机会再去不通过。\n我迟迟没有提交。\n我只顾着懊悔为什么没提交最新版，却没想到其实我可以先把前面一道题弄错，从而能够判断这题能不能过的同时顺利不通过。\n希望能给大家一点启发吧。\nUpdate 12.3\n没想到中测就能测出来这个问题。\n我特意交了一版没修改nop流水方式的，居然挂掉了一个点，和当时中断强测的点略有类似。\n而且修改之后便通过了。\n那可能，就是这样了？\n我好像安定下来了，但又诚惶诚恐。\n跟P6好像啊，一场考试下来还不知道自己课下还有没有问题。\n据说加指令的题也不简单。2h能拿下吗？\n紧张，紧张。\nP7上机 —— 2 在开考前进行了龙芯杯的宣讲。 考试时间7:40-9:40，注意时间把控。\n其实对自己的MIPS还是略带自信的，因为我确实不相信他会加强测试点。\n建议下载压缩包后直接速提交，不要再做解压，或是装进ISE等事项。你要提交的就是源代码。\n否则就会喜提20min的gap，心神不宁地排300余人的队\n强测过了之后，完全不可懈怠！一定要严谨严肃。\n本次题目为： 添加异常WATCH 触发方式有二：IMWATCH与DMWATCH\nPC0添加18号寄存器与19号寄存器（支持正常读写）\n19号寄存器为异常判断使能 18号寄存器高16位是IM敏感值，低16位是DM敏感值\n异常逻辑就是 当前pc与IM敏感值相同时且19号寄存器使能满足要求时触发IMWATCH DM敏感值在sl指令读写地址范围内时且19号寄存器使能满足要求时触发DMWATCH\n几个注意点：\n异常优先级。以往的异常是不会同时出现的，而如今IMWATCH随时可触发，DMWATCH可以与ADEL,ADES同时触发 IMWATCH优先级低于取指异常，高于其他异常。 DMWATCH优先级低于ADES,ADEL（对于同时出现的异常） 范围内。对于DMWATCH注意要匹配的是在范围内，如sw，DM敏感值是四个值中的一个即可。 这里我们可以大胆用ADDR\u0026lt;= watchaddr \u0026lt;=ADDR+3, 他一定字对齐，否则会出现优先级更高的ADES异常。\n乘除槽。IMWATCH可以在任何指令上触发，因此乘除法也可能是异常指令，不能等到他走到M级在检测出来，此时为时已晚，乘除槽停不下来。 因此需要提前判断好IMWATCH异常，将其加入MDALU模块。 阻塞。mtc0 18和19都是危险的，会直接影响WATCH的判断，因此必须阻塞。 这决定了IMWATCH不能在F级判断，因为这样会使D级为mfc0 18,19也需要阻塞，而这会导致死循环，因为我们的阻塞逻辑就是在D级实现的，那么mtc0就被卡在D级不得动弹。\n在D级判断IMWATCH是较为正确的选择。\n作者其实没有一交即过。 让我以为这个测试很强。\n其实是因为写成了CP018号寄存器31:16 == pc[31:16]\u0026hellip;\n应该是CP018号寄存器31:16 == pc[15:0]， 或者{16\u0026rsquo;b0,CP018号寄存器31:16} == pc.\n改完没想到就直接过了。 一瞬间，惊喜而释然。\n说在最后 计组上机就这样圆满结束了。\n在提问环节，助教问我： 你觉得你在计组闯关的收获是什么？\n回首，一路走来实在坎坷。\nPre的茫然 P1的无力 P4的惊愕 P5的懊悔 P6的愚钝 P7的畏惧\n平稳，或是激荡地 每一个Project都有着课上课下的呐喊\n从第一个单周期CPU 到封装流水线CPU可支持中断支持外设支持异常处理支持30余条指令的MIPS微系统 诞辰不久的博客也日渐丰满\n这像是一种高压下的凝聚 引领着我们去稳健处理庞大的项目\n从形象框架到代码实现 从独立执行到高效流水 从单一指令到复杂延时 从固定运行到异常中断\n不同的Project把步骤分离 并予以较强的正确性检查 使得P5不必担心P4部件的实现 P6不必担心P5转发阻塞的实现 P7不必担心P6CPU本身的实现\u0026hellip;\n未来的项目倘若没有这些具象的规划 根本不敢想有多困难。\n当然，感谢每一位同行者的帮助与支持。非常感谢。\nCO上机结束，我也终于可以好好躺下，大脑放得很空很空，吸入又呼出些跳动的空气，悄悄捕捉又一颗充满爱与自由的心。\n","date":"2024-12-10T12:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E4%B8%8A%E6%9C%BA/3c7fe802fe677d02b6b3708d9f40249_hu9209242832316334602.png","permalink":"https://demiurge-zby.github.io/p/%E4%B8%8A%E6%9C%BA/","title":"上机"},{"content":" 说在前面 还得是设计文档。 每次一旦盯着理论看，又想看全又想做细，就会陷入P5当时的茫然 总是想一针见血地写出最有远见卓识的代码，当然会踌躇，更何况还未必能写出来。 但是一步一步走出来，也就走出来了。\n设计文档 在对P7的整体内容有了把握之后，我们可以知道，本次P7主要要完成的任务是：\n更改流水线各级使之可以产生异常 添加 CP0 与 异常处理 添加 Bridge 与两个外设（计时器）交互 ExcCode的产生与流水 根据教程的表格，我们可以得到：\n异常与中断码 助记符与名称 指令与指令类型 描述 0 Int （外部中断） 所有指令 中断请求，来源于计时器与外部中断。 4 AdEL （取指异常） 所有指令 PC 地址未字对齐。 4 AdEL （取指异常） 所有指令 PC 地址超过 0x3000 ~ 0x6ffc。 4 AdEL （取数异常） lw 取数地址未与 4 字节对齐。 4 AdEL （取数异常） lh 取数地址未与 2 字节对齐。 4 AdEL （取数异常） lh, lb 取 Timer 寄存器的值。 4 AdEL （取数异常） load 型指令 计算地址时加法溢出。 4 AdEL （取数异常） load 型指令 取数地址超出 DM、Timer0、Timer1、中断发生器的范围。 5 AdES （存数异常） sw 存数地址未 4 字节对齐。 5 AdES （存数异常） sh 存数地址未 2 字节对齐。 5 AdES （存数异常） sh, sb 存 Timer 寄存器的值。 5 AdES （存数异常） store 型指令 计算地址加法溢出。 5 AdES （存数异常） store 型指令 向计时器的 Count 寄存器存值。 5 AdES （存数异常） store 型指令 存数地址超出 DM、Timer0、Timer1、中断发生器的范围。 8 Syscall （系统调用） syscall 系统调用。 10 RI（未知指令） 未知指令 未知的指令码。 12 Ov（溢出异常） add, addi, sub 算术溢出。 根据教程的要求，我们容易知道，只需分析好每一个部位可能产生的异常，然后随着流水线流水即可。 同一条指令在某一个阶段不会产生多种异常。（这由异常的划分方式确定） 但是一个阶段可能存在多个异常。其处理顺序为先来后到。也就是处理最老的指令，执行到最后面的指令的新错误。\n有人说，你这样做就是只处理最新的错误啊，怎么保证处理了最新的错误还能处理旧的错误呢？\n这是因为处理异常的方法是把句子变成nop，并重新从受害指令下一条开始执行。 这样，未被处理的指令的错误就会重新展现出来，再次被处理。\n我们决定，传入流水线的ExcCode，是要经过一个有优先级的多路选择器的。 为了区分，我们命名为\nExcCode_X(本阶段产生的) 和ExcCode_X_true(实际传入流水线的) 以及ExcCode_X_last(流水线传进来的)\n接下来就来判断异常吧。 我打算根据流水级来进行分类处理。\n注意： Int表示外部中断，更表示此处无异常。因此ExcCode可以大胆赋0，具体是否中断还要看外部信号。\n附一个可能用到的表格：\n条目 地址或地址范围 备注 数据存储器 0x0000_0000∼0x0000_2FFF 指令存储器 0x0000_3000∼0x0000_6FFF PC 初始值 0x0000_3000 异常处理程序入口地址 0x0000_4180 计时器 0 寄存器地址 0x0000_7F00∼0x0000_7F0B 计时器 0 的 3 个寄存器 计时器 1 寄存器地址 0x0000_7F10∼0x0000_7F1B 计时器 1 的 3 个寄存器 中断发生器响应地址 0x0000_7F20∼0x0000_7F23 我们使用以下宏定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 `define Exc_AdEL 5\u0026#39;d4 `define Exc_AdES 5\u0026#39;d5 `define Exc_Syscall 5\u0026#39;d8 `define Exc_RI 5\u0026#39;d10 `define Exc_Ov 5\u0026#39;d12 `define IM_start 32\u0026#39;h3000 `define IM_end 32\u0026#39;h6fff `define DM_start 32\u0026#39;h0000 `define DM_end 32\u0026#39;h2fff `define T0_start 32\u0026#39;h7f00 `define T0_end 32\u0026#39;h7f0b `define T1_start 32\u0026#39;h7f10 `define T1_end 32\u0026#39;h7f1b `define T0_count_start 32\u0026#39;h7f08 `define T0_count_end 32\u0026#39;h7f0b `define T1_count_start 32\u0026#39;h7f18 `define T1_count_end 32\u0026#39;h7f1b `define Int_generator_start 32\u0026#39;h7f20 `define Int_generator_end 32\u0026#39;h7f23 ExcCode_F 我们发现只能发生： AdEL: PC未字对齐或PC超界\n1 2 3 assign ExcCode_F = ((pc_F[1:0] != 2\u0026#39;b0) || pc_F \u0026lt; `IM_start || pc_F \u0026gt; `IM_end) ? `Exc_AdEL : 0; assign ExcCode_F_true = ExcCode_F; ExcCode_D D级的核心工作是译码。\nRI：未知指令 Syscall: 系统调用\nRI与Syscall信号也由Ctrl译码时顺带产生。\n1 2 3 4 5 6 assign RI = !(nop || add || sub || And || Or || slt || sltu || lui || addi || andi || ori || lb || lh || lw || sb || sh || sw || mult || multu || div || divu || mfhi || mflo || mthi || mtlo || beq || bne || jal || jr || mfc0 || mtc0 || eret || syscall); assign Syscall = syscall; 1 2 3 4 5 assign ExcCode_D = (Syscall) ? `Exc_Syscall : (RI) ? `Exc_RI : 0; //此处虽然有优先级，但是两者是不会同时发生的 assign ExcCode_D_true = (ExcCode_D_last) ? ExcCode_D_last : ExcCode_D; //优先级，同一指令按最老的错误来 ExcCode_E AdEL: 计算load地址时加法溢出\nAdES：计算store地址时加法溢出 Ov:add,addi,sub的算数溢出\n这些信号利用ALU模块得出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 wire overflow_add; wire overflow_sub; wire [32:0] ext_num_1; wire [32:0] ext_num_2; wire [32:0] ext_add; wire [32:0] ext_sub; assign ext_num_1 = {num_1[31], num_1}; assign ext_num_2 = {num_2[31], num_2}; assign ext_add = ext_num_1 + ext_num_2; assign ext_sub = ext_num_1 - ext_num_2; assign overflow_add = ext_add[32] ^ ext_add[31]; assign overflow_sub = ext_sub[32] ^ ext_sub[31]; assign Ov = ((add || addi) \u0026amp;\u0026amp; overflow_add) || (sub \u0026amp;\u0026amp; overflow_sub); assign AdEL_E = (DMRd_E) \u0026amp;\u0026amp; overflow_add; assign AdES_E = (DMWr_E) \u0026amp;\u0026amp; overflow_add; 大错特错！大错特错！！！\n1 2 assign Ov = (((ALUOp == `ADD) || (ALUOp == `ADDI)) \u0026amp;\u0026amp; !DMRd_E \u0026amp;\u0026amp; !DMWr_E \u0026amp;\u0026amp; overflow_add) || ((ALUOp == `SUB) \u0026amp;\u0026amp; overflow_sub); de出这个bug真费了不少功夫。 第一次de出来是意识到ALUOp是ADD,未必指令就是ADD, 还有可能是store与load指令！！\n结果还没过。。\n这次很随便一个数据居然de出来了 因为一条ori指令出现了Ov!!!\n这让我感到极为震惊。我就看了看Ov的所有相关信号———— 当我看到add,并发现它是一个32位数时\u0026hellip;\u0026hellip;\n太抽象了！！！！！ add原来是数据信号啊不是控制信号！！！ 控制信号是ALUOp！！！！！\nUpdate 12.1: 这也太抽象了！！！ 感谢COKiller!!! 没想到能在这里de三次。。\n第一次是因为sw犯了Ov 第二次是因为ori犯了Ov 第三次是因为div犯了Ov!!!!!!!\n天打五雷轰。\nmultu,divu乃至于mfc0，mfhi都在ALUOp对应ADD！！！\n所以我老实了。 我直接把Instr传到E级，由Instr指导is_ADD。\n1 2 3 4 assign is_ADD = (Instr_E[31:26] == 6\u0026#39;b000000) \u0026amp;\u0026amp; (Instr_E[5:0] == 6\u0026#39;b100000); assign Ov = ((is_ADD || (ALUOp == `ADDI)) \u0026amp;\u0026amp; overflow_add) || ((ALUOp == `SUB) \u0026amp;\u0026amp; overflow_sub); 这样应该就没有问题了罢。。\n1 2 3 4 5 assign ExcCode_E = (AdEL_E) ? `Exc_AdEL : (AdES_E) ? `Exc_AdES : (Ov) ? `Exc_Ov : 0; assign ExcCode_E_true = (ExcCode_E_last) ? ExcCode_E_last : ExcCode_E; ExcCode_M AdEL:\nlw,lh字对齐 lh,lb取Timer 超范围 AdES:\nsw,sh字对齐 sh,sb写Timer 所有store写Count寄存器 超范围 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 assign AdEL_M = (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMRd_M == `LW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end)) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); assign AdES_M = (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMWr_M == `SW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_count_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_count_end) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end)) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end)) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end)) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); assign ExcCode_M = (AdEL_M) ? `Exc_AdEL : (AdES_M) ? `Exc_AdES : 0; assign ExcCode_M_true = (ExcCode_M_last) ? ExcCode_M_last : ExcCode_M; 好嘞笑死了，已经被自己蠢死了\n应当改为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 assign AdEL_M = (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMRd_M == `LW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMRd_M == `LB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMRd_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); assign AdES_M = (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M[0]) || (DMWr_M == `SW \u0026amp;\u0026amp; MemAddr_M[1:0]) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SH \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_end) || (DMWr_M == `SB \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T0_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T0_count_end) || (DMWr_M \u0026amp;\u0026amp; MemAddr_M \u0026gt;= `T1_count_start \u0026amp;\u0026amp; MemAddr_M \u0026lt;= `T1_count_end) || (DMWr_M \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `DM_start || MemAddr_M \u0026gt; `DM_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T0_start || MemAddr_M \u0026gt; `T0_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `T1_start || MemAddr_M \u0026gt; `T1_end) \u0026amp;\u0026amp; (MemAddr_M \u0026lt; `Int_generator_start || MemAddr_M \u0026gt; `Int_generator_end)); 不同的异常类型确实应该或起来，但是地址越界是一种异常！！ 必须同时满足在所有区域之外！内部表述应使用与\nW级不产生异常。 至此，我们貌似写完了所有异常。\nCP0及异常处理 我们一般将CP0放进M级。 这意味着指令异常在M级进行处理。\n这形成了单周期CPU的封装： 一般认为M级指令为正在执行的指令。 一般认为PC_M即为宏观PC。 一般认为W级处的指令是已完成的指令。 一般认为F,D,E级的指令都是未开始执行的指令。\n一旦有这样单周期的认知，那么 出现异常就是指M级指令出现异常; 受害PC即为M级PC。 或者说，任何指令在某一流水级产生的异常， 都要等待该指令进入M级才可被处理。\nCP0基础信息 课程组给出的接口表格：\n端口 方向 位数 解释 clk I 1 时钟信号 reset I 1 复位信号 en I 1 写使能信号 CP0Addr I 5 寄存器地址 CP0In I 32 CP0 CP0Out O 32 CP0 VPC I 32 受害PC BDIn I 1 是否是延迟槽指令 ExcCodeIn I 5 记录异常类型 HWInt I 6 输入中断信号 EXLClr I 1 用来复位 EXL EPCOut O 32 EPC 的值 Req O 1 进入处理程序请求 课程组给出的关键寄存器信息：\n寄存器 编号 功能 SR 12 配置异常的功能 Cause 13 记录异常发生的原因和情况 EPC 14 记录异常处理结束后需要返回的PC 课程组给出的关键功能域：\n寄存器 功能域 位域 解释 SR（State Register） IM（Interrupt Mask） 15:10 分别对应六个外部中断，相应位置1表示允许中断，置0表示禁止中断。这是一个被动的功能，只能通过mtc0这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。 SR（State Register） EXL（Exception Level） 1 任何异常发生时置1，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。 SR（State Register） IE（Interrupt Enable） 0 全局中断使能，该位置1表示允许中断，置0表示禁止中断。 Cause BD（Branch Delay） 31 当该位置1时，EPC指向当前指令的前一条指令（一定为跳转），否则指向当前指令。 Cause IP（Interrupt Pending） 15:10 6位待决的中断位，分别对应6个外部中断，相应位置1表示有中断，置0表示无中断。每个周期将会被修改一次，修改的内容来自计时器和外部中断。 Cause ExcCode 6:2 异常编码，记录当前发生的是什么异常。 EPC - - 记录异常处理结束后需要返回的PC。 对于关键域，我们使用宏定义以方便书写：\n1 2 3 4 5 6 `define IM SR[15:10] `define EXL SR[1] `define IE SR[0] `define BD Cause[31] `define IP Cause[15:10] `define ExcCode Cause[6:2] 对于CP0，它的主要功能即为 存储异常中断的相关信息，表征异常中断的开始与结束， 引导转向异常中断模块处理与退回原指令。\n判断异常中断的发生 1 2 3 4 5 6 7 wire Exc_req; wire Int_req; assign Exc_req = (ExcCodeIn != 5\u0026#39;b0) \u0026amp;\u0026amp; (`EXL == 1\u0026#39;b0); //我们不太确定EXL为1时能否触发异常。但是其实我是把EXL==1当成全局异常判断使能看待的 assign Int_req = (|(HWInt \u0026amp; `IM)) \u0026amp;\u0026amp; `IE \u0026amp;\u0026amp; (`EXL == 1\u0026#39;b0); assign req = Exc_req || Int_req; 这里比较巧妙的是 (|(HWInt \u0026amp; `IM)) 这一语句\n巧妙使用了按位与，先得到各个信号是否中断且中断是否被允许 然后再把这6位或起来（不或也可以）\n当然最后不能忘了全局使能与EXL限制\n存储异常中断的相关信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 always @(posedge clk) begin if (reset) begin SR \u0026lt;= 0; Cause \u0026lt;= 0; EPC \u0026lt;= 0; end else begin `IP \u0026lt;= HWInt; if (req) begin `EXL \u0026lt;= 1\u0026#39;b1; EPC \u0026lt;= (BDIn) ? (VPC - 32\u0026#39;d4) : VPC; `ExcCode \u0026lt;= (Int_req) ? 5\u0026#39;b0 : ExcCodeIn; `BD \u0026lt;= BDIn; end if (EXLCLr) begin `EXL \u0026lt;= 1\u0026#39;b0; end end end `ExcCode \u0026lt;= (Int_req) ? 5\u0026rsquo;b0 : ExcCodeIn; 这句话是表明优先级的，Int与Exc的区别，在CP0中就是靠Cause寄存器来展现。 如果同时发生Int与Exc，如何保证Int优先？ 只需一个三目运算符，先判断中断。\nEPC \u0026lt;= (BDIn) ? (VPC - 32\u0026rsquo;d4) : VPC;\n这句话体现了BDIn的功能。 如果这句话是延迟槽语句，那么你应当保证跳转指令正常进行。如果你只重新执行延迟槽，跳转指令就不能实现。 那么此时我们就不采用直接重新执行受害指令的方法，而是采用执行受害指令前一句的分支跳转。\n但是为什么可以选择执行受害指令上一句？ 这样的做法无疑是执行了两遍这一指令。\n但是正因为它是跳转指令，它并没有累加效应。 就连唯一有写功能的jal也只会写他对应的那一个值。\n那就有人说，你这不是钻空子吗？万一添加个新跳转指令，让你给$ra写当前$ra的值加4，这不就完了吗？\n新指令在W级，延迟槽在M级判出问题（或中断）。这样的话你完全来得及让第一次的写入无效，只需把W级写使能修改一下，把BDIn和req引出去，并说明这个时候不能写入。\n诶诶，那又有人问了，你这么写不就说明你的写使能是可能最后突然改变的，那你之前要是执行过转发怎么办？\n这就不得不说咱们的单周期思想了。在异常中断面前，M级以前的指令都相当于没有执行。转发给你啥都无所谓。\n那就又有人问了，M级本身要是被转发了怎么办？\n害，M级如果发生异常中断了，那就也需要重新执行，也相当于未执行指令。\n好，一段小思考结束了。\n写入关键寄存器 这一操作也应在CP0中完成 其实也只是添加了如下内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /*always @(posedge clk) begin if (reset) begin SR \u0026lt;= 0; Cause \u0026lt;= 0; EPC \u0026lt;= 0; end else begin `IP \u0026lt;= HWInt; if (req) begin `EXL \u0026lt;= 1\u0026#39;b1; EPC \u0026lt;= (BDIn) ? (VPC - 32\u0026#39;d4) : VPC; `ExcCode \u0026lt;= (Int_req) ? 5\u0026#39;b0 : ExcCodeIn; `BD \u0026lt;= BDIn; end if (EXLCLr) begin `EXL \u0026lt;= 1\u0026#39;b0; end*/ if (en \u0026amp;\u0026amp; !req) begin //执行mtc0时发生中断，则不予写入 case (CP0Addr) 5\u0026#39;d12 : begin SR \u0026lt;= CP0In; end 5\u0026#39;d14 : begin EPC \u0026lt;= CP0In; end default: begin end endcase end/* end end*/ 但是具体en，CP0Addr，CP0In怎么得到，那就是CP0外部的事了。\n在这里我还是打算直接写好。因为这确实是一块很小的，而且与下一部分关系不大的内容。\n核心就是添加mtc0,mfc0指令，放进流水线等等。\n这个和mfhi,mthi的逻辑几乎完全相同。\n先分析mtc0吧，只需要在M级给CP0的en接口接上Mtc0_M 写的地址是rd_M 写的内容是MemData_M\n注意控制信号Tuse_rt = 2\nmfc0要注意RFWr置1，Tnew = 2 写的地址是rt 写的内容是RegData\n1 2 assign RegData = Mfc0_W ? CP0Out_W : WdSel_W ? MemReadData_W : ALUData_W; 可以发现CP0Addr始终为rd,所以直接让该端口接rd_M。\n整体来说是这个样子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CP0 Cp0( .clk(clk), .reset(reset), .en(Mtc0_M), .CP0Addr(rd_M), .CP0In(MemData_M), .VPC(pc_M), .BDIn(PCSel_W), // 如果上一句是跳转，那么这一句是延迟槽 .ExcCodeIn(ExcCode_M_true), .HWInt(HWInt), .EXLCLr(EXLClr), .CP0Out(CP0Out_M), .EPCOut(EPC), .req(req) ); CPU进行异常处理 语句跳转 遇到异常时进入Exception Handler 0x00004180 在异常处理程序结束时会执行指令eret回到EPC\n语句清空 利用CP0生成的req信号对所有流水线寄存器进行清空。 （因为CP0在M级，那么此时W级的操作在本时钟周期已完成，由于同步复位，清空寄存器只会影响下一周期的内容，这样下一周期所有指令都已完成，不受干扰。）\n（注意精确异常，认真阅读教程中关于乘除槽精确异常的讲述。 ）\n这里有很重要的一点在于eret没有延迟槽。因此执行完eret后，下一条指令应当是EPC。\neret在D级，此时eret的下一条指令（物理层面）在F级\n我们需要F级的指令是EPC而非eret的下一条指令\n以下内容看乐子就行\n我们采用一种奇妙的做法：\n当eret在F级时，我们直接进行检测该指令是否是eret。\n如果是，那么NPC为EPC。\n1 2 3 4 5 6 wire Eret_F; assign Eret_F = (Instr_F == 32\u0026#39;d01000010000000000000000000011000); assign _npc = Eret_F ? EPC : PCSel_D ? npc : (pc_F + 32\u0026#39;d4); 解释一下之前的定义： _npc为真正的NPC PCSel_D是判断D级是否为跳转指令 npc是跳转指令算出来的npc\n这里要注意EPC它并不是一个定值，他可能被mtc0改变！！ 因此有一套转发与阻塞逻辑： 我现在需要一个正确的pc\n1 2 3 4 assign _EPC = (Mtc0_D \u0026amp;\u0026amp; rd_D == 5\u0026#39;d14) ? V2_D : (Mtc0_E \u0026amp;\u0026amp; rd_E == 5\u0026#39;d14) ? V2_E_Data : (Mtc0_M \u0026amp;\u0026amp; rd_M == 5\u0026#39;d14) ? CP0In : EPC; 这样的转发足够吗？ 不够！必须阻塞！！\nmtc0不被阻塞的前提是mtc0认为自己能在写CP0之前拿到对的值 所以他在没有到达CP0的时候的值都有可能不对\nEPC的值是在mtc0到达W级的时候被传送到F级供eret使用\n在mtc0在M级的时候，它的CP0In肯定也是对的，可以转发。\n在mtc0在D,E级的时候，都可以考虑阻塞。\n1 2 3 4 5 6 7 /*assign stall = start_busy || (busy \u0026amp;\u0026amp; MDALUOp_D) ||*/ ((Eret_F \u0026amp;\u0026amp; Mtc0_D \u0026amp;\u0026amp; rd_D == 5\u0026#39;d14)) || ((Eret_F \u0026amp;\u0026amp; Mtc0_E \u0026amp;\u0026amp; rd_E == 5\u0026#39;d14)) ||/* ((A1 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_E)) || ((A1 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_M)) || ((A2 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_E)) || ((A2 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_M));*/ 我们看似用的是D级的阻塞，但这样也能起到阻塞F级eret的作用\n这一段的写法过于创新。我们不得不有把这种设计毁掉的打算。\nUpdate 12.1: 我很抱歉。在没有de出真正的bug之前，我选择把这一种方法全部删去。采用了大家普遍使用的D级执行。\n当然，在修改之后当时并没能解决任何问题。\n这里要注意一点： eret严格意义上在M级才能视为被执行。 因此EXLClr需要在Eret信号传到M级时才置1。\n至于eret的清空延迟槽，就不再多说了，需要注意它的BD应为0。 在阻塞上我也是正常全力阻塞，转发也不想写了。。\n逻辑就是eret在D级，mtc0在E,M级且要写的内容是EPC时直接大胆阻塞。\n对于异常跳转，监测标志为req req置1时，pc需变为0x00004180\n1 2 3 4 5 6 7 8 9 10 11 /*always @(posedge clk) begin if (reset) begin PCreg \u0026lt;= 32\u0026#39;h00003000; end*/ else if (req) begin PCreg \u0026lt;= 32\u0026#39;h00004180; end/* else if (En_pc) begin PCreg \u0026lt;= npc; end end*/ req优先级需注意，低于reset，位于第二高的地位。\n紧接着，我们解决req对寄存器的清空。\n本来很简单的一件事情，由于阻塞而变得复杂。 阻塞，产生了空泡，但这个空泡不应是全空的。\n这个空泡应当是上一条指令生命的延续。\n尤其是PC信息与Bd信息。 对于阻塞型清空，应保持不变。\n如D_E流水线寄存器中：\n1 2 3 pc_E \u0026lt;= reset ? 32\u0026#39;h00003000 : req ? 32\u0026#39;h0000_4180 : pc_D; PCSel_E \u0026lt;= (reset || req) ? 0 : PCSel_D; 真的是这样吗？？\nUpdate 12.2 上机debug\n空泡要存的信息究竟是谁？\n是被阻塞指令的pc和跳转指令的PCSel\n因此\n1 2 3 4 pc_E \u0026lt;= reset ? 32\u0026#39;h00003000 : req ? 32\u0026#39;h00004180 : pc_D; ExcCode_E_last \u0026lt;= 0; PCSel_E \u0026lt;= (reset || req) ? 0 : PCSel_E; 两种继承方式！ PCSel直接继承，pc流水继承。\n其次我已做了改动，eret不再是PCSel指令了。\n为什么要这么做呢？\neret他要起到修正PCSel的作用这确实，但是他还有很多自己的特别作用！\n你不能对它进行额外的流水处理！\n你总不能让一句nop拥有eret性质吧，我们EXLClr可是跟eret很有关系的。\n外设及其交互 其实整体来说，外设的作用就只有信息存储与中断产生。\n中断信号的导入 中断信号相对简单，只需要传递给HWInt接口。\nTimer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。\n1 2 wire [5:0] HWInt; assign HWInt = {3\u0026#39;b0, interrupt, IRQ_1, IRQ_0}; 系统桥与信息存储 我们在此构建一个新模块Bridge\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 module BRIDGE( input wire [31:0] addr, input wire [3 :0] byteen, input wire [31:0] Rd_T0, input wire [31:0] Rd_T1, input wire [31:0] Rd_DM, output wire [31:0] Rd, output wire [3:0] m_data_byteen, output wire [3:0] m_int_byteen, output wire hit_T0, output wire hit_T1 ); wire hit_DM; wire hit_Int; assign hit_T0 = (byteen == 4\u0026#39;b1111) \u0026amp;\u0026amp; (addr \u0026lt;= `T0_end) \u0026amp;\u0026amp; (addr \u0026gt;= `T0_start); assign hit_T1 = (byteen == 4\u0026#39;b1111) \u0026amp;\u0026amp; (addr \u0026lt;= `T1_end) \u0026amp;\u0026amp; (addr \u0026gt;= `T1_start); assign hit_DM = (addr \u0026lt;= `DM_end) \u0026amp;\u0026amp; (addr \u0026gt;= `DM_start); assign hit_Int = (addr \u0026lt;= `Int_generator_end) \u0026amp;\u0026amp; (addr \u0026gt;= `Int_generator_start); assign m_data_byteen = (hit_DM) ? byteen : 0; assign m_int_byteen = (hit_Int) ? byteen : 0; assign Rd = (hit_T0) ? Rd_T0 : (hit_T1) ? Rd_T1 : (hit_DM) ? Rd_DM : 0; endmodule 我们可以看出，它无非是\n根据addr和byteen得出新的字节使能信号 对各方面的读取进行选择，得出真正的读入内容 这样，我们就可以顺利搭建顶层模块：\n无非是两个Timer，还有一些信息处理与传输嘛，最后还是给CPU使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 wire hit_T0; wire hit_T1; wire [31:0] Rd; BRIDGE bridge( .addr(addr), .byteen(byteen), .Rd_T0(Rd_T0), .Rd_T1(Rd_T1), .Rd_DM(m_data_rdata), .Rd(Rd), .m_data_byteen(m_data_byteen), .m_int_byteen(m_int_byteen), .hit_T0(hit_T0), .hit_T1(hit_T1) ); wire IRQ_0; wire [31:0] Rd_T0; TC Timer_0( .clk(clk), .reset(reset), .Addr(addr[31:2]), .WE(hit_T0), .Din(m_data_wdata), .Dout(Rd_T0), .IRQ(IRQ_0) ); wire IRQ_1; wire [31:0] Rd_T1; TC Timer_1( .clk(clk), .reset(reset), .Addr(addr[31:2]), .WE(hit_T1), .Din(m_data_wdata), .Dout(Rd_T1), .IRQ(IRQ_1) ); endmodule 注意一下TC传的地址是[31:2]\n连完顶层模块，P7好像就，结束了？\n通过ISE把语法错误搞完，然后\u0026hellip;\n陷入无尽的debug之中了。\n测试文档 P6既然过了，P7的无异常情况基本是不需要考虑的。\n基本处理模式 测试首先从简单的异常开始，比如简单的Ov\n认真观察波形图，分析一下进入异常处理程序后各寄存器的情况，以及是怎么跳转回去的，跳转回去各寄存器的情况又如何。\n此时的异常处理程序还比较简单，比如可以只有4条语句：\n取EPC，EPC+4，存EPC，eret\n(这个还能顺便测测阻塞)\n1 2 3 4 5 6 .ktext 0x4180 mfc0\t$k0, $14 addu\t$k0, $k0, 4 mtc0\t$k0, $14 eret 99999999 (一条无效指令，测一测延迟槽清空) 防止漏判 构造出所有引发异常的组合。\n你只需要对着你那个表格，一种种地敲，一种种检验。\n关键是看好ExcCode，这个最简单，但也往往是大量错误出现的地方。\n防止误判 这个是比较难发现的，在使用COKiller之前，我碰运气确实找到了一些样例误判，但是用了COKiller我才发现div触发Ov没有被我发现。\n我的建议就是多用评测机，多测点数据，认真看代码。\n其他细节谬误 这些我觉得可以对着各种学长博客所强调的点先检查是否实现，再写测试程序来看写的是否正确。\n例如空泡的信息继承，乘除槽的执行与否等等。\n思考题 请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？\n鼠标和键盘等都属于外设，外设与CPU的时钟频率可谓是天差地别。中间必须要有一个接口，实现两者之间的信息交流。\n这个接口往往有硬件的控制信号，更有软件的处理程序，能够使这些信号变为CPU接受的形式。\n请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）\n因为我们的异常处理程序是统一放在这里的，你要执行异常处理程序就是要到达这个pc。\n不过用户自己实现处理异常中断应该也不会有大的问题，毕竟我们自己搭CPU测试的时候不就是自己写处理中断的程序嘛，写得很烂就是了。。\n但是0x4180本身位置的控制一定是经过慎重考虑的，有其空间分配的优越性。\n为何与外设通信需要 Bridge？\n高内聚，低耦合。\n外设可以添加，但是CPU不应为之改变。 这时候，系统桥就能起到分析处理双方信息的作用。\n当我们添加新外设，只需改动Bridge来控制要读谁，要写谁的问题。\n请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并针对每一种模式绘制状态移图。\n整个流程两种模式十分类似，差别在于是否具有周期性。\n对于IDLE，ctrl[0]为0转为状态LOAD，并把IRQ置0，接下来，无条件进入计时阶段，如果中途ctrl[0]为1就终止，进入IDLE，否则就计数完成时进入INT，发送中断。\n到了INT阶段， if(`ctrl[2:1] == 2\u0026rsquo;b00)，那么就一直中断，进入IDLE继续循环。 否则，IRQ置0，即只中断这一个周期，然后进入IDLE重新循环。\n不过共同之处在于，ctrl[0]对中断的产生都有明显的控制作用。\n倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？\n会发生EPC为0的问题。这个问题在设计文档已经提到过，还是那句话：\n空泡应当是上一条指令生命的延续。\n我们处理的核心问题是EPC，所以说空泡要着重继承与之有关的PC值与Bd值。\n空泡要存的信息究竟是谁？\n是被阻塞指令的pc和跳转指令的PCSel\n为什么 jalr 指令为什么不能写成 jalr $31,$31？\n这也是我的设计文档中所提到的一个问题。\nBd为1而是用重复执行跳转指令的方法确实有潜在问题，正如jalr $31, $31的情况：\n这是一个有累加效应的写指令。两次执行jalr的写效果是不同的。\n解决方案文中也有讨论到： 异常中断在延迟槽发生，那么就屏蔽req时的写GRF，让此时W级的写指令无效。\n下一次回到这句话的时候才是真正执行。\n倘若延迟槽又出现问题，那就再让此时W级写使能无效即可。\n","date":"2024-11-26T20:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p7-mips%E5%BE%AE%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/destruction321_hu5083056439175028234.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p7-mips%E5%BE%AE%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/","title":"北航CO P7 MIPS微系统搭建"},{"content":" 说在前面 能通过P5实在是很好的一件事。 在我第一道题直接AC确定课下无bug，在我很快做出前两道题确定自己能通过后，我真的如释重负。 题目并不难，在课下提交截止前找出bug并修复真的是我能通过P5的重要原因。 反思前两题，还可以做得更快。思路清晰，才能更精准更利索。\n上次也说到了，咱们的P6要实现30条指令了！\n具体地说： add, sub, and, or, slt, sltu, lui, addi, andi, ori, lb, lh, lw, sb, sh, sw, mult, multu, div, divu, mfhi, mflo, mthi, mtlo, beq, bne, j, jal, jr, nop\n接下来，我们就开始吧！\n设计文档 本次P6搭建，我还是选择采用边搭建边写设计文档的方法。\n通过记录设计文档来记录我的每一步更改进度，对于P6这种考验严谨性的工程是较有益的。\nP6的主要任务，是在一个相对完善的架构上去增添大量的同类型新指令和少量的特殊指令。\nadd, sub, and, or, slt, sltu, lui,\naddi, andi, ori,\nlb, lh, lw, sb, sh, sw,\nmult, multu, div, divu, mfhi, mflo, mthi, mtlo,\nbeq, bne, j, jal, jr,\nnop\n比较新鲜的指令有set型，字节访存，还有最特别的乘除模块指令！\n我的搭建逻辑是最后处理乘除模块，先搭简单的，或者说白了，先搭非乘除模块（）\n顶层模块的改装 由于P6修改了IM和DM模块，在外部接入指令存储器与数据存储器，并在外部实现写入内容的输出\n对于这些新的接口，\n1 2 3 4 5 6 7 8 9 10 11 input [31:0] i_inst_rdata, input [31:0] m_data_rdata, output [31:0] i_inst_addr, output [31:0] m_data_addr, output [31:0] m_data_wdata, output [3 :0] m_data_byteen, output [31:0] m_inst_addr, output w_grf_we, output [4:0] w_grf_addr, output [31:0] w_grf_wdata, output [31:0] w_inst_addr 为了较少地改动我们的原版CPU，我们采用 assign 顶层输出信号 = 部件输入信号 assign 部件输出信号 = 顶层输入信号 的方式进行书写。\n相当于：本来传给IM,DM部件的信号现在要作为顶层输出信号传给外部IM,DM、 而本来从IM和DM部件得到的数据现在要由外部IM,DM通过顶层输入信号进行赋值。\n其中只有m_data_byteen这一信号是我们从未出现过的，它涉及到了lh,lb,sh,sb四条新指令。\nDM的写 不难设计一个STORE模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 `timescale 1ns / 1ps `define SW 2\u0026#39;b01 `define SH 2\u0026#39;b10 `define SB 2\u0026#39;b11 `default_nettype none module STORE( input wire [1:0] DMWr_M, input wire [31:0] MemAddr_M, output wire [3:0] byteen ); wire half; wire [1:0] by_te; assign half = MemAddr_M[1]; assign by_te = MemAddr_M[1:0]; assign byteen = { ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b1))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b11))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b1))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b10))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b0))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b01))), ((DMWr_M == `SW)||((DMWr_M == `SH)\u0026amp;\u0026amp;(half == 1\u0026#39;b0))||((DMWr_M == `SB)\u0026amp;\u0026amp;(by_te == 2\u0026#39;b00)))}; endmodule 在顶层,我们可以直接将m_data_byteen与byteen接口相连 也可以新建信号以提高可扩展性\nDM不需要读使能，它始终会读出该地址存储的值，只是后续再通过WdSel来判断你用不用这个信号罢了 而且DM的写使能也很方便实现： |byteen ,将它的各位或起来就可以作为写使能，即存在1就要写。 byteen本身又是控制信号，即哪是1哪被写。\nDM的写就基本完成了 （毕竟功能本身已经由testbench全权负责了）\n! 这样的执行逻辑与MARS是不同的！经过和学长的交流，m_data_wdata跟MemData显然应当是不同的。\n在此加入对MemData做处理的语句，也不难写\n1 2 3 4 5 assign m_data_wdata = (DMWr_M == `LW) ? MemData_M : (DMWr_M == `LH) ? {MemData_M[15:0], MemData_M[15:0]} : (DMWr_M == `LB) ? {MemData_M[7:0], MemData_M[7:0], MemData_M[7:0], MemData_M[7:0]} : 32\u0026#39;b0; DM的读 前文也说到，DM一直会读，但是lw,lh,lb就需要你来处理了。 根据读出的整个字和控制信号，我们可以实现把MemReadData变成正确的值。 相应地，我们需要通过一个模块将m_data_rdata变为MemRead 再将MemRead赋值给MemReadData（同样是为了可扩展性）\n这个模块也很好写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 `timescale 1ns / 1ps `define LW 2\u0026#39;b01 `define LH 2\u0026#39;b10 `define LB 2\u0026#39;b11 `default_nettype none module LOAD( input wire [1:0] DMRd_M, input wire [31:0] m_data_rdata, input wire [31:0] MemAddr_M, output wire [31:0] MemRead ); wire half; wire [1:0] by_te; assign half = MemAddr_M[1]; assign by_te = MemAddr_M[1:0]; assign MemRead = (DMRd_M == `LW) ? m_data_rdata : (DMRd_M == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b1) ? {{16{m_data_rdata[31]}}, m_data_rdata[31:16]} : (DMRd_M == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b0) ? {{16{m_data_rdata[15]}}, m_data_rdata[15:0]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b11) ? {{24{m_data_rdata[31]}}, m_data_rdata[31:24]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b10) ? {{24{m_data_rdata[23]}}, m_data_rdata[23:16]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b01) ? {{24{m_data_rdata[15]}}, m_data_rdata[15:8]} : (DMRd_M == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b00) ? {{24{m_data_rdata[7]}}, m_data_rdata[7:0]} : 32\u0026#39;b0; endmodule IM 这个就不用说了，两句话的事\n1 2 assign i_inst_addr = pc_F; assign Instr_F = i_inst_rdata; sh,sb,lh,lb 做事做到底，就把他们直接都写完吧\n书写逻辑： 1.CTRL各项控制信号添加 (和lw，sw完全对应一致) 2.CTRL中Tuse,Tnew (和lw，sw完全对应一致) 3.具体实现（已完成）\n简单的E级ALU写数指令 这类指令也很简单，在此也只有两类： add型: add, sub, and, or ori型：addi, andi, ori （在此add型再添加：slt, sltu 原因在下一小节\n读两个数 算一个数 也就是add型指令 把它归为同一类的原因，主要是控制信号过于相似： 相同调控（置相同的数）的信号有：WrSel, RFWr, Tuse_rs, Tuse_rt, Tnew_D 特异性的信号是ALUOp,用宏定义增强可读性\n书写时要额外注意slt和sltu\n1 2 3 assign slt = ($signed(num_1) \u0026lt; $signed(num_2)) ? $signed(1) : $signed(0); // 1和0是有符号数。但我还是保险起见 assign sltu = (num_1 \u0026lt; num_2) ? 32\u0026#39;b1 : 32\u0026#39;b0; // 32\u0026#39;b1和32\u0026#39;b0都是无符号数 读一个数 拿一个立即数 算一个数 也就是ori型指令 其实和上一类很像，不过区别在于： num_2是IMM_32而非V2 写的寄存器是rt而非rd 相同调控（置相同的数）的信号有：RFWr, ImmSel, Tuse_rs, Tuse_rt, Tnew_D ！特异性： ADDI是符号扩展 ,ORI,ANDI是零扩展\nD级算数指令 真的要在D级算数？ 这是我之前从未触及的一个点。在此，为提高效率，我将冒险进行优化： 这类指令有slt, sltu, lui, jal 把它们前移至D级改变了两件事：Tnew降低、Tuse降低 我之前并没有写过E-D转发，使得lui和jal的Tnew均为1 经过优化，他们的Tnew可以变成0，从而避免后续指令被阻塞 但他们也有风险：风险就是Tuse降低使得他们本身的操之过急可能会使自己被阻塞\n事实上，lui和jal是直接对立即数操作，因此并没有Tuse的风险问题。 而slt和sltu则有风险。\n因此我将slt和sltu放回了简单的E级ALU写数指令。\nlui 和 jal 的 E-\u0026gt;D转发 接下来先说说我对lui和jal的改进吧。 首先，jal的转发十分简单，只要当A1(A2)等于31且Link_E时把pc+8传过去而已。 jal在后面把这个值选择赋给了ALUData_E_True,即\n1 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : ALUData_E; 那么相应地，lui的转发也可以很简单。 真正要写入寄存器的lui的值当然还是ALU算出来的，相当于节省了把这个值选择赋给ALUData_E_True的过程。 lui未曾有的，是他的独特信号，即Lui lui要转发的值，就是{IMM32_E[15:0], 16\u0026rsquo;b0} 由于后续由ALU承包，Lui信号只需要坚持到E-\u0026gt;D转发就够了 可知我们需要改动CTRL，D_E这两个子模块。\n那么咱们的成效就要显露出来了： 那就是减少阻塞！Tnew降为0！\n在CTRL中更改Tnew信号后，这一段路，也算是走完了。\n跳转指令 增添的新指令是bne 已经可以称得上和beq完全一致了吧\u0026hellip;\n主要差别只在于zero和!zero 相同调控（置相同的数）的信号有：PCSel, Tuse_rs, Tuse_rt, (Tnew都不存在)\n不过bne和beq要区分，所以还是需要有控制信号传出来。\n主要就是NPC引入新接口bne,参与了npc的计算罢了\n1 ((beq \u0026amp;\u0026amp; zero) || (bne \u0026amp;\u0026amp; !zero)) ? br_pc : pc_D + 32\u0026#39;d8; 接下来，剩下的8个乘除模块指令，就要从零建起了。\n乘除模块 乘除模块共8条指令 mult, multu, div, divu, mfhi, mflo, mthi, mtlo\nMDALU模块 我们可以构建模块MDALU 接口如下所示：\n名称 位宽 方向 clk 1 I reset 1 I MDALUOp 4 I num_1 32 I num_2 32 I start_busy 1 O busy 1 O HI 32 O LO 32 O clk和reset的功能就不多说了，要清空所有寄存器 start_busy:得知指令为 mult,multu,div,divu，引发运算，阻塞与busy （在start_busy的时候就要为下一周期阻塞了，再不阻塞E级就要进来新指令了）\nMDALUOp:控制信号\n1 2 3 4 5 6 7 8 assign MDALUOp = mult ? `MULT : multu ? `MULTU : div ? `DIV : divu ? `DIVU : mfhi ? `MFHI : mflo ? `MFLO : mthi ? `MTHI : mtlo ? `MTLO : `NONE; busy：这个可以说是最重要的一个点。 在busy状态下，我们要进行阻塞，Pc、F_D级不动，D_E级清空，E级及以后顺延运算。 问题的关键在于： 如何控制busy时间？\n以乘法为例： 每个时钟上升沿，start_busy信号为1时，给cnt归0，给busy赋1，算出LO，HI要被赋的值（现在再不算，等会阻塞的时候E级都清空了） (由于非阻塞赋值，在下一时钟上升沿cnt = 0, busy = 1)\nbusy为1时，\n若cnt == 4，busy和cnt清零，并对regHI，regLO赋值 (由于非阻塞赋值，第五个时钟周期开始时cnt刚被赋值为4， 那么下一个时钟上升沿是busy和cnt都清零，regHI和regLO被赋值， assign语句的即时性使得HI与LO直接出值) 否则cnt++ 指令的控制信号 这八条指令除了MDALUOp以外，也有其对应的控制信号要处理。\nmult,multu,div,divu是完全同质的指令。 特点是读GRF，直接写HI,LO，不写GRF和DM 可以归纳其控制信号RFWr = DMWr = DMRd = 0; ImmSel = 0;运算数都是寄存器\nTuse_rs = Tuse_rt = 3\u0026rsquo;b1;\n乘除法的Tnew不必担心： 得出结果就直接塞到寄存器里了 新指令一旦进来，就说明我的regHI和regLO已经写好了 转发都不用，更别说阻塞了\n再说了，乘除法不差你这一点阻塞，本身阻塞的也够多了（）\nmfhi,mflo是一个访存指令。 要读HI,LO，写GRF 这考虑的就要多了。\n首先，它写GRF，就决定了它需要去转发： 指令的Tnew = 1,可进行M-\u0026gt;D,M-\u0026gt;E的转发。 我们当然可以直接把它加入ALUData_E_true(像当初pc+8那样)\n其次，写要写到哪：rd 那么WrSel要置1\n另外，写当然需要写使能：RFWr = 1\nmthi,mtlo要对HI和LO进行写 要读GRF 写HI,LO\n那么其实这和第一类指令很相似 不写GRF和DM，控制信号RFWr = DMWr = DMRd = 0; ImmSel = 0;运算数都是寄存器 特点是Tuse_rs = 3\u0026rsquo;b1; 但是不需要读GRF[rt]\n同样类似地，它的值也是即拿即写 不需要转发与阻塞\n指令在模块内的书写 前四条已经较详细地描述过了 但在实际书写上，还是存在一定问题： 1. 在阻塞之后，什么值都丢了，那么你就必须有自己预先存好的Op，预先存好的计算结果，才能使得你这个周期还能按着原来的指令的轨迹去走。 但是，op你应该怎么存？ 这至少需要一个时钟周期去存它，那么如果你只根据Op判断，你就已经丢失了一个时钟周期。不仅如此，对于一个周期就能完成的mf,ml指令而言，这更是荒唐。 因此，我目前的写法是不仅对Op写case语句，还对MDALUOp写case语句。 那么，Op的控制也应更加严格，即执行完语句后，应把Op置为`NONE。 （注意：default的情况不要对Op处理！因为default可能是还没来得及赋值的Op,这下好了，同一上升沿两次赋值）\n符号乘法要怎么写？ 鉴于曾经在这里WA过一发，我在此直接给出写法：\n1 {tempHI, tempLO} \u0026lt;= $signed(num_1) * $signed(num_2); 就这么简单。不要担心位宽不一致。它会自动扩展。\nmf指令是一个读HI，LO指令，而我们的HI与LO本就一直在输出。 只需要MDALUOp的控制信号管理一下ALUData_E_true的选择即可。\nmt指令为写HI，LO指令，直接在case语句里面写寄存器就行。 ！！这里要注意，我们写HI，LO寄存器其实是在下一时钟周期才完成的 因此有人会担心，如果下一条指令就要读HI，LO会不会出错误？ 答案是不会。因为我们的assign一直在输出，HI,LO被写之后拿出来的数肯定是对的。\n曾经又在这里WA过一发：mt指令读的都是rs!!!\n模块在顶层的书写 作为少有的要改动顶层模块的设计 首先要注意先前所提到的 mf指令涉及到的写寄存器与转发的问题，都需要靠ALUData_E_true来解决\n1 2 3 4 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : (MDALUOp_E == `MFHI) ? HI : (MDALUOp_E == `MFLO) ? LO : ALUData_E; 当然还有模块本身的接口及其信息传递\n另外要注意的就是阻塞： 阻塞实际上也就是多或上了两个信号start_busy和busy信号 并非如此！ 阻塞应该或上start_busy信号清空E级倒没错（防止ALUOp不变回0引发两个case语句都被执行） 但是busy信号应当与MDALUOp_E与起来再或 因为乘除的结果放进HI，LO里是不影响其他指令的进行的，只有遇到与HI,LO相关的语句，我们才有阻塞的必要。 通过这样优化，大大降低了阻塞率。\n那么接下来的，就是大量指令引发的巨量测试。\n测试文档 单个指令的测试 对于新加入的指令本身，我们需要进行一次较为彻底的测试。\n一是功能本身的基础是否实现，二是一些特殊情况需要验证。\n首先是lh,lb,sh,sb指令： 侧重对符号扩展的测试\n对于add, sub, and, or, slt, sltu, lui, addi, andi, ori 要注意addi的符号扩展是否做到\n对于bne就正常测试成功or失败跳转即可\n对于乘除法模块则也要注意符号问题\n这一层次的测试基本上是用于debug的，因为只涉及自身功能，不涉及冒险，课下的弱测强度基本足够了。\n当然还是建议自行做足测试的。\n指令之间的冲突处理 利用思考题处的表格自行构造样例，再结合评测机进行测试。\n我决定写多个小型测试，对各种转发与阻塞的情况编写特别代码来检测结果。在此不便展示。\n思考题 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？\n因为乘除法部件的运算逻辑与读写数据都与ALU截然不同。 首先，乘除法的高强度阻塞与特别的时序逻辑决定了他不能和组合逻辑直接混用。\n乘除法模块中计算指令就不说了，mf指令是组合逻辑assign，mt指令是写寄存器的时序逻辑。这和原ALU是不太兼容的。\n其次，HI，LO寄存器也只有MDALU能用到，和ALU混用，就提高了内部耦合度，显得混乱。\n这么做，把计算分为ALU和MDALU，最后再进行选择，其实相当于是形成了一个更大的ALU，含有原ALU和MDALU。因此，单独的乘除法部件更好地做到了“高内聚，低耦合”。\n最大的好处：先前没有理解好乘除法的阻塞，事实上，只要乘除法运算过程中没有与乘除类有关的指令，就不需要阻塞。那咱们的效率可谓是大大提升了。\n独立的HI,LO： 首先，HI,LO有其自身特殊性，不能被直接读，只能靠mf指令读。 其次，把HI，LO放在E区，与其他寄存器分离开来，能够实现即出即写，避免了读写冲突。\n真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。\n经过资料查阅，在真实的流水线CPU中，32位乘法是分部分计算的，一个周期可以32位对8位数的乘法（？），然后4个周期能算完。 除法据说是用试商法，一次试4位，8个周期做完除法。\n请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？\nstart可以引发busy，而start和busy都能导致阻塞。 通过计数器控制阻塞周期数，在最后一周期，清空busy,cnt，并完成寄存器赋值。 由于阻塞清空了E寄存器，我将MDALUOp和运算结果进行了及时存储。当然，在最后一周期，这些存储的信号也要清空。\n请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）\n清晰性： 提前将DMWr和addr共同作用的结果算出来，清晰明了地表达了究竟要写哪些字节，对每个字节执行独立的赋值。\n统一性： sw,sh,sb都能用同样的按字节赋值的逻辑来执行。 不过需要被写数据要进行一些预处理：\n1 2 3 4 5 assign m_data_wdata = (DMWr_M == `LW) ? MemData_M : (DMWr_M == `LH) ? {MemData_M[15:0], MemData_M[15:0]} : (DMWr_M == `LB) ? {MemData_M[7:0], MemData_M[7:0], MemData_M[7:0], MemData_M[7:0]} : 32\u0026#39;b0; 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？\n写入DM的确实只写了一个字节 但从DM获取的是一整个字，要经过后续处理\n执行lw和sw时当然还是按字读写更快 但是执行对半字与字节的操作时，按字节读写效率更高\n为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？\n抽象： 我对指令进行了归类，如设计文档所示。并按类地添加和处理指令 最显著的作用如DMRd,DMWr,ALUOp,MDALUOp等等，单个多位信号传入流水线寄存器，相较于多个单位信号是更方便的。\n规范： 对于同一类指令，可以对其先归为一类，再统一为控制信号赋值 （其实也没简单太多，比如addi这种符号扩展，还要单独写）\n帮助： 在译码和处理数据冲突的时候也就是在CTRL内，按类调整控制信号与T信号，省时省力\n在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？\n新的冲突只有数据冒险。处理方法也别无二致。\n阻塞： 我在修改CTRL的时候，已经为各个指令赋好了Tuse_rs,Tuse_rt,Tnew，阻塞正常进行\n转发：\n新添的所有指令中，需要的位点没有改变：V1_D,V2_D,num_1,num_2（此处忽略lh,lb.sh,sb） 新添的所有指令中，写寄存器的内容：大多都还是原来的路径，除了M级有新数据：即来自LO,HI的新数据。（要知道乘除运算指令本身是不写GRF的） 对于这个的处理前文也有提及：\n1 2 3 4 assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : (MDALUOp_E == `MFHI) ? HI : (MDALUOp_E == `MFLO) ? LO : ALUData_E; 对于这个改动的测试样例：\n1 2 3 4 5 6 7 8 9 10 11 ... mult $s1, $s2 mfhi $t0 ## 写$t0 add $t1, $t0, $t0 ## 读$t0，M-\u0026gt;E需转发，写$t1 mtlo $t1 ## 读$t1，M-\u0026gt;E需转发 mflo $t2 ## 写$t2 add $t3 $t2 $t2 ## 读$t2，M-\u0026gt;E需转发，写$t3 mthi $t3 ## 读$t3，M-\u0026gt;E需转发 mfhi $t4 ## 写$t4 sw $t4 0($0) ## 读$t4，M-\u0026gt;E需转发 lw $t5 0($0) ## 写$t5 这个样例过多测试了M-\u0026gt;E转发，下面补充一个M-\u0026gt;D转发\n1 2 3 4 5 6 mtlo $t5 ## 读$t5 mflo $t6 ## 写$t6 label: or $t6 $t6 $0 ## 表示正在死循环 bne $0 $t6 label ## M-\u0026gt;D转发 nop 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。\n我采用了手动构造法。 通过建立策略矩阵，按照T的关系来进行构造 具体分类方式如下图所示：\n这两张图还需添加关于lui和mf指令的测试，单独对这两个指令构造测试也是可行的。\n","date":"2024-11-14T14:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p6-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA2/Der_Richter_hu1678884075292437805.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p6-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA2/","title":"北航CO P6 流水线CPU搭建（2）"},{"content":" 说在前面 这周真的太忙了。 不说流水线和数竞这两块大骨头，硬控两小时的党课，硬控两小时的挑战杯志愿者，硬控一小时的组会，硬控五小时的毛概PPT\u0026hellip;\n虽说这周还买了曲包摘了星\n但是流水线CPU真难写。 读者可以看看我写设计文档心境的变化。\n（提交截止前2h突然发现bug。。5点半硬控到7点去上党课）\n为什么说这是流水线的（1）呢？ 因为目前还只有10条指令。流水线（2）是P6，30条指令的事了。\n那么，请君观之。\n设计文档 流水线的设计与单周期的区别主要是两点：\n流水线寄存器的插入 冒险的处理 这两点说起来轻轻松松，但实操起来实在繁杂。\n在漫无目的地发愣了很久之后，我决心要先写出一篇设计文档，把思路理清了再去书写。\n发愣的核心原因在于总感觉自己处理不好寄存器要放什么，谁应该在哪个区（浅显的思考当然不能处理好）\n有的时候更是连第一步没想好就忙着转发阻塞什么的\n哪怕后续转发的时候再优化，现在把需求理清，车间划好，才能想下一步迈进。\n流水线寄存器 要将原来的单周期分割为五个小阶段，具体是什么样呢？\n哪些阶段有什么部件？又要干些什么？\nF pc出值给IM\nIM出指令\npc+4得更新到pc\n这里已经涉及到pc的问题了，我不得不现在想清楚延迟槽。\n所有不是pc+4的npc，都是经过跳转的；所有要跳转的，都要用延迟槽\n所有用延迟槽的，都要先执行pc+4，因为跳转结果在第二周期才得出来（哪怕你提前得出来了你也得等延迟槽！！）\n所以跳转结果是在下一个周期才赋值，是一种特殊的赋值！\npc应当默认使用pc+4，除非有NPC算出的东西进来\n这需要一个控制信号，并且应当是任何跳转语句都能引发，我称之为not_pc_4\n这个信号作用于PC，所以还是称它为PCSel吧 PCSel为1的条件就是所有跳转语句\n这个信号在什么时候产生呢？ 肯定已经到D阶段了\nbeq在F阶段，此时PCSel仍为0 （因为跳转语句不在延迟槽，这一句不是延迟槽，则上一句不是跳转，则PCSel为0）\nbeq在D阶段，延迟槽语句在F阶段 这时候PCSel为1\n因此下一个pc将是跳转的结果，没有问题！\nPCSel产生即使用，不经过流水线（虽然他其实能够在F阶段就拿出来，但是拿出来也要流水到下一周期才能用。此外译码一般都放在D级）\n顺便谈到zero\nzero经过提前到D级后，也是即拿即用，不需要经过流水线\npc，Instr都给 F_D\nF_D拿到指令\nF_D 存储PC和Instr,实现流水。\n一个流水线寄存器是要干什么？\n暂存信息（时钟、复位信号与其他信息） 从寄存器出信息 搞明白这一点，后面的流水线寄存器都大同小异了。\nD 好，接下来看一条指令在D阶段要干些什么\nD阶段最核心莫过于GRF\n但是其他内容也都同等重要\n首先是先前提到过的 NPC和CMP\n单独搞一个CMP出来据说是为了解决P6大量branch语句\n这个阶段要给imm_16变成IMM_32, imm_16已经没用了吗？要把它加入流水吗？\n为了可扩展性，要不要把他一直存着呢？\n但到时候哪怕用imm_16，直接从IMM_32里面取就行了。完全没必要存。\nimm_26是j型指令用的，存着也没用，毕竟即拿即用，得赶快给PC送过去呢！\n好的，那这个阶段把imm_16也解决掉了\n剩下最后一个，就是GRF了！\n读什么？根据rs,rt读呗。\n这个阶段又不写。所以rd目前也没什么用。\n是不是要注意GRF的A3选择的时候是rd_W,rt_W这些？写的时候那个pc也得是pc_W？关于W阶段啥东西都应该是W？\n那就是W阶段的事。看似是一个部件，不同的功能要分开考虑。不能想着GRF在D级，就一口气把GRF接口都连好。 现在只考虑D级！\nD_E 存储很多很多东西 还有用的控制信号（EXT，J，Jr当场使用了） 还有用的数据（imm_16和imm_26都没用了） 当然还有pc\n多存点，说不定会有用的。\nE 好嘞，该读的信息都读了，该处理的信息也处理了\n下面就是执行操作了\n关键的内容还是ALU\n而ALU的核心就是各个东西都是E\n（这个模块异常的简单？）\nE_M 还是一个基本问题，后面需要什么\n要传递一脉相承的信号，也要传递新生成的数据\npc是当然的 后面有Mem取数和Write回写 需要Mem写的地址，写的内容，GRF写的地址，写的内容 还有他们的读写使能\n别忘了还要传递ALUData信息\nM 整体和单周期也基本没有区别，只有这一个模块在工作而已。\nM_W 添加MemReadData_M MemData_M和Mem_Addr_M也带上吧\nW 回到GRF\n该用W的都用上W即可\n意外地快。 不处理冒险的数据通路搭好了？？\n冒险处理 我自己也没想到已经走到了这一步。 这一基础性的工作就这样被我搁置了这么久。\n你也能够发现，上面的无非是添加接口，新建流水级的体力活。 接下来才是头脑风暴的核心。\n转发和阻塞！！！\n转发 首先要构建好转发的所有路径 转发的核心矛盾，是读了还没写的东西 （一定要注意0号寄存器！写进去了也还是0，因此不能转发）\n我在这里直接考虑所有路径\n指令 F D E M W add,sub 取指令 取rs,rt 算数 得到数据进行转发rd 写数rd ori,lui 取指令,扩展imm 取rs 算数 得到数据转发rt 写数rt lw 取指令，扩展imm 取base，rt 算数 寻址取数 得到数据转发rt，写数rt sw 取指令，扩展imm 取base，rt 算数 寻址存数 无 j 取指令，扩展imm 算出NPC延迟槽后用 无 无 无 jal 取指令，扩展imm 算出NPC延迟槽后用，算出PC_8 可转发（但没人需要） 可转发 可转发，写数$31 jr 取指令 读rs并给NPC 无 无 无 举个例子add 例如我们add读寄存器值的时候可能数据还没出来，但是真正要用到的时候其实在ALU 因此使用时间在E级。\n在此诠释Tnew的定义：最早的可转发时间。也就是正确数据已产出，且存在转发通路。\n我在此分如下几类指令：\nR型读2求1型 rs与rt要读，正常转发 Tuse_rs = 1（ALU的时候有就行） Tuse_rt = 1（ALU的时候有就行） Tnew 初始（即相对于E）= 1 (M才能开转) RegAddr 现场算\nI型拿1读1求1型 rs 要读，正常转发 Tuse_rs = 1（ALU的时候有就行） Tuse_rt = inf imm正常传，传到了num_2,因此rt的值在E级要额外存为V2_E_Data\nTnew 初始 = 1 (M才能开转)\n读寄存器跳转型 说白了就是jr（） Tuse_rs = 0 !!! Tuse_rt = inf 所有跳转的特点都在于其必须在D级得出跳转结果。 而jr就必须从V1_D拿到完全正确的值 因此E-\u0026gt;D的转发是有益的 （但从E开始的转发需要是在D级就得出结果的指令（不经过ALU）） 符合条件的并不多。 我暂时采用阻塞。\n直接跳转型 j不必多说 Tuse_rs = inf Tuse_rt = inf\nRFWr = 0\n条件跳转型 beq。关键在于br和zero两个指令。 其中zero同样要保证在D级算对！必须拿到对的值。 拿不到？我也先采用阻塞。\nTuse_rs = 0 Tuse_rt = 0 RFWr = 0\nLink型 典例jal Tnew = 0 !!!!!(不过我还是把它当做Tnew = 1来用) Tuse_rs = inf Tuse_rt = inf\nE级就能用。因此E-\u0026gt;D这条转发路径是有益的。我目前先用了阻塞。 写$ra太慢了！必须转发！ 该怎么转？能在M和W转。（E也能转） 一定要注意：一旦选择转它，你要拿他去覆盖转的值！！\n1 2 wire [31:0] ALUData_E_true; assign ALUData_E_true = (Link_E) ? pc_E + 32\u0026#39;d8 : ALUData_E; 这个ALUData_E_true直接传进流水线E_M和M_W， 即如果本指令为Link型，你就只能读到这一个$31数！\n条件跳转Link型 最关键的便是不跳转，就不Link！ 比如beqal，其link信号应为beqal\u0026amp;\u0026amp;zero(传Link信号的时候就控制好)\nL型 rs rt 正常获取转发 Tuse_rs = 1 Tuse_rt = inf(看题意新指令会不会特殊条件使用rt) imm正常扩展\nALU算的值会在M级被转发！！ 但是在W级正确的值还会被转发过去。\n准确来说，阻塞逻辑就是为了保证你要用的时候一定能拿到正确的值，无论这中间发生过什么。\n因为你的Tnew就是正确数据生成时间，Tuse就是使用时间。\n如果传过去被使用的是错误数据，那就说明正确数据还没被生成，也就是说这条指令是满足阻塞条件的。所以根本不会出现这种情况。\nTnew = 2 最慢！！！（一直到M级取出来，W级才能用）\nS型 Tuse_rs = 1, 在E级需要算对数rs， Tuse_rt = 2，在M级需要有正确的寄存器值rt RFWr = 0 Tnew = 0，不对寄存器进行写\n转发路径共四条：\n转发方向 数据 判断 M-\u0026gt;D 传ALUData_M(经过pc+4和ALUData的选择) RegAddr_M跟A1A2比 W-\u0026gt;D 传RegData(经过MemReadData_W和ALUData_W的选择) RegAdde_W跟A1A2比 M-\u0026gt;E 传ALUData_M(经过pc+4和ALUData的选择) RegAddr_M跟rs_E rt_E比 W-\u0026gt;E 传RegData(经过MemReadData_W和ALUData_W的选择) RegAddr_W跟rs_E rt_E比 为什么没有到M的转发？ 因为M级使用即Tuse = 2,而Tnew没有大于2的（Tnew = 3即W级才产出数据。这显然是荒谬的？）\n事实上，W-\u0026gt;M 是必要的！！ 要知道，Tnew从来不是产出时间，而是最早转发时间！ 如果你写了Tnew=2，那你就表明了自己能在W级转发数据，怎么能不写W级转发通路呢？ 咱们在编写Tnew的时候，一定要和我们能实现的转发通路一一对应。 只有在你做到能转则转的情况下，你才能说Tnew是正确数据的最早生成时间。 否则，你的效率会更低，且你需要修改你的Tnew表。 为什么没有E-\u0026gt;D的转发？ E-\u0026gt;D 即 Tnew = 0 且 Tuse = 0，满足需求只有jal（lui也可以。但是我已经把他塞进ALU了） 但是我还没写。 因此Tnew = 1，要阻塞。\n从这里也能看出来Tnew和转发通路的关系\n阻塞 我们采用把阻塞控制在D阶段完成的方法。 Tuse:在D级的时候，读寄存器的最晚周期与D级的差 Tnew_X:X周期的指令要写的内容能够转发出去的最早周期与E级的差 （在周期A算出来，则可以在周期A+1转发）\n我们需要考虑D与E关系，D与M关系 为什么不考虑D与W关系？？ 因为Tnew_W一定为0了（谁家指令在W级还没算出来数（笑））\n对于两个阻塞的关系，我们采用暴力地或起来 一条通道可能不通就阻塞。\n这可能确实有点暴力，但我也确实没什么精力去优化描述，以更好地处理例如 lw $31, 0($0) jal label add $t0, $31, $31 这样的情况。这种情况原则上jal转发优先级更高，他还更快，所以如果他有正确的值且寄存器匹配且不为0且T关系等等就可以不管lw的感受。 我没管那么多。\n阻塞只需满足:\n确实发生读写冲突且来不及转发（Tuse \u0026lt; Tnew） 我们先分为rs冲突与rt冲突\n1 assign stall = stall_rs || stall_rt; 然后以rs为例：\nstall_rs = stall_rs_DE || stall_rs_DM\n以stall_rs_DE为例：\n确实发生读写冲突： (rs_D（即A1）== RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026rsquo;b0) 且 \u0026amp;\u0026amp; 来不及转发： (Tuse_rs \u0026lt; Tnew_E)\n所以\n1 2 3 4 stall = ((A1 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_E)) || ((A1 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A1 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rs \u0026lt; Tnew_M)) || ((A2 == RegAddr_E) \u0026amp;\u0026amp; (RFWr_E) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_E)) || ((A2 == RegAddr_M) \u0026amp;\u0026amp; (RFWr_M) \u0026amp;\u0026amp; (A2 != 5\u0026#39;b0) \u0026amp;\u0026amp; (Tuse_rt \u0026lt; Tnew_M)); 接下来，只需对 Tuse 和 Tnew_X 下定义：\n功能还在CTRL中实现: 因为我要用指令来描绘 Tnew 和 Tuse_rs 和 Tuse_rt\n指令 Tnew Tuse_rs Tuse_rt add 1 1 1 sub 1 1 1 ori 1 1 5 lui 1(个人原因) 5 5 beq 无(0) 0 0 jr 无(0) 0 5 jal 1(不转发导致的) 5 5 lw 2 1 无(5) sw 无(0) 1 2 Tuse 直接生成 Tnew_X 初值生成，递减操作\n递减操作的实现： 放进流水线嘛，过个周期减一下\n测试文档 刚搭完流水线寄存器，出来一堆compile bug 或多或少的少加控制信号，打错字什么的。。 然后运行了充斥着nop的代码，没什么问题。\n然后就向Hazard进军了！\nHazard测试的编写很有针对性。 前提是你要针对好所有的代码情况，事先分析好Tnew,Tuse关系 才能模拟出所有的冒险。 所有的转发，所有的阻塞，都要到位。\n思考题 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。\nbeq提前使得其Tuse降为0，这无疑提高了阻塞率。 当这条指令前面是Tnew = 1的add,sub,ori等等均阻塞\n用原来的方法，虽有可能损失更大，但是也存在很多无损失的情况。提前分支判断则是较为稳定的损失。\n举例：\n1 2 add $16 $16 $16 beq $16 $0 label 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？\n正因题意所说，因为延迟槽的存在，jal语句后的那条指令是已被执行的，跳转回来时当然要跨过延迟槽这句话\n我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？\n功能部件本就耗时，如果再加上转发逻辑，二者必定是顺序关系，导致时钟周期长度增长，频率上限降低，效率也就低了。 但是如果在下一周期，转发操作和下一周期的操作是独立并行的，不影响执行速度。\n我们为什么要使用 GPR 内部转发？该如何实现？\nGRF内部转发本质上是W到D的转发，只是W和D用了同一个部件 有同学使用了negedge的办法进行W，这样posedge读的时候就一定已经被新值写入。\n我采用了传统转发。无非转发的值是RegData_W,参与判断的是RegAddr_W罢了。\n我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？\n需求者严格意义上有很多，不过他们是可以合并的。 所有需要使用或传递的部件，都是需求者。 但是我们可以先进行转发，再把结果给需求者们。 总体来说，需求者可以是CMP的两个数，ALU的两个数，D_E和E_M流水线寄存器。\n需求者还有M级 sw时RD2的值！！！！！需要换上最新数据！！！\n供给者我们都安排到流水线寄存器的输出。 M级的数据可以是ALUData,Pc+8 W级的数据可以是MemReadData,ALUData,Pc+8\n前文也提到了，E到D的转发尚未考虑。\n因此，共有M-\u0026gt;D，M-\u0026gt;E，W-\u0026gt;D，W-\u0026gt;E，W-\u0026gt;M五种。 （以及E-\u0026gt;D）（6种）\n!!刚de出的bug!!!还有W-\u0026gt;M转发！！！！\n再总结一下所有被转发：\nRD1\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V1_D\u0026mdash;\u0026gt;V1_E\u0026ndash;ME,WE转发\u0026ndash;\u0026gt;num_1\u0026mdash;\u0026gt;运算\nRD2\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V2_D\u0026mdash;\u0026gt;V2_E\u0026ndash;ME,WE转发\u0026ndash;\u0026gt;V2_E_Data\u0026mdash;\u0026gt;V2_M_Data\u0026ndash;WM转发\u0026ndash;\u0026gt;MemData_M\u0026mdash;\u0026gt;被写入\nRD2\u0026ndash;MD,WD转发\u0026ndash;\u0026gt;V2_D\u0026mdash;\u0026gt;V2_E\u0026ndash;ME,WE转发、选择\u0026ndash;\u0026gt;num_2\u0026mdash;\u0026gt;运算\n总结一下所有转发：\nM级为ALUData,Pc+8经过选择变为ALUData_true的转发 W级为MemReadData,ALUData,Pc+8经过选择变为RegData的转发\n转发地址为RegAddr已各自计算\n在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。\n这一问题在前文已有谈论。 总结起来，关键还是处理好Tnew,Tuse,读谁，写谁这四个问题 （其中，读谁，写谁都是需要控制信号的） 以及最核心，最有不确定性的“处理”这一部分\n确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。\n我使用的是对控制信号找相关指令的方式。 先由opcode和funct得出结果，再得出指令；接下来由指令得到控制信号。 优势是简洁，不足是容易漏写，错写。 加指令时一定要分析好所有相关信号，再书写。\n","date":"2024-11-10T22:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p5-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA1/292fa3e8c7e86664cbaefef9ddc7893_hu11389104909499974286.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p5-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%90%AD%E5%BB%BA1/","title":"北航CO P5 流水线CPU搭建（1）"},{"content":"作业最终的架构设计 经过轮轮迭代，面向对象先导课程也终于走向了尾声。\n关于类 本次迭代任务中，共有24个类被创建：\n他们分别是：\nMainClass: 程序入口，实现数据读入操作和大量核心方法。 Adventurer: 核心操作对象，内含有关Bottle，Equipment，Frag，Employ类的相关容器 Bottle：内设三个子类，HpBottle，AtkBottle，DefBottle Equipment：内设三个子类，Axe，Blade，Sword Frag：表达碎片的相关属性与方法 Employ：表达雇佣关系相关属性与方法 Guard，Treasure及其Factory：秘境探险操作中的新对象 具体属性就不详细说了\n关于容器 在容器上的考虑，值得一提的便是CarriedEquipment。它使用了以name为索引的HashMap，这一方法十分契合题设要求。可惜的是，在处处以id为核心标识的情境，使用以name为索引的方法不可避免地要处理好在carry操作之外的重名问题。\n那便是deleteEquipment()方法在第三次迭代强测中带来的惨痛教训\n关于迭代 迭代式开发的课程，着实是令我耳目一新的。\n第一次迭代 OMG，it\u0026rsquo;s LLM! 从第一次迭代时拙劣地模仿IDEA的LLM，到现在理解较为成熟地模仿LLM，大家每个人的进步都是肉眼可见的。\n第二次迭代\n添加了carry指令。当时没有想太多，直接为装备添加了isCarried属性（谁能想到后面装备还能援助给别人呢（） deleteCommodity()让我开始考虑将Bottle和Equipment结合起来，但其差异仍将大于其共性。 第三次迭代 这次迭代是让我最印象深刻的一次迭代，痛失40分（苦笑 核心要点主要是： 容器重构，carry，frag，fight\n删掉了所有find函数，用上了高效简洁的HashMap carry方法重写，建立了专属容器以存放Carried的物品。关于carriedEquipment以name为索引的潜在问题前面已经提到了。 frag的处理。就忽略id属性这一问题，我认为是合理的。frag的最核心属性就应该是name和count，以同名frag作为一个对象基本单元，在获取数量，消耗数量等操作上都是合理的。不过把id忽略掉这种行为本身，对于整个项目来说，可能还是有一定隐患的。 fight较为简单。强测错因是getAtk()误写成getCe()。 第四次迭代 迭代任务确实一次比一次重\n雇佣关系：建立Employ类，对于一个雇佣关系对象本身管理它的各项属性。这种思想让我缓了很久，万物皆为对象！曾经室友写了一个Fight类，让我懵懂地理解了一下什么是过程对象，如今自己写的时候又更明白何为关系对象。把一场战斗（函数(函数其实也是关系，关系就是有序对)）当作一个对象，它有它的属性，有它的方法；把雇佣关系（有序偶对）作为对象，同样有自己的属性与方法。 递归攻击：倒是一个很容易克服的难点。 秘境探险：更多的是一种思想认知的改变，在具体实现上让我对接口有了新的认识。不同的类可以借助接口同一调用不同内容的方法，确实便利了很多 中测de了半天bug原来错在getComprehensiveCe()也是没谁了（）\n使用JUnit的心得体会 覆盖率是一项任务 起初，我确实没有意识到JUnit的功能。能在运行中构造样例运行出来的结果，为什么还要搞那么复杂去专门去测？我对各个方法进行了无意义的测试，完成了基础任务。\n覆盖率赋予每一行代码意义 自第三次迭代作业开始，加入了分支覆盖率的要求。在我开始思考覆盖率的意义之时，我方才意识到，单元测试之所以是单元测试，便在于它使得代码中各种细微的地方都能被顾及得到。同样，覆盖率也能够帮助我写出更完善的测试代码。\n单元测试，但不仅仅是单元 在单元测试中，我们不仅要编写对于单个方法的测试，更需要对较大的方法进行测试，在大方法中测试小方法相互作用关系的正确性。单元测试中的单元不仅是指最小单元，更是单元之间组合形成的层次化结构单元。\n测试数据构造需要技巧 无论何时，以debug为目的的测试终究是要找到bug。因此要尽力去构造bug相关的测试点，构造较极端的情况进行分析，而不是为了达到覆盖率要求而进行大量的无意义测试。\n学习OOpre的心得体会 以方法为核心的逻辑 在学习C语言的时候，我曾畅想，如果各项基本操作都能靠函数实现，而函数的实现也依靠其他函数，人脑只需负责顶层逻辑，那些条条框框的小方法被封装起来等着用该多好\u0026hellip;\n在OOpre的课程中可谓是函数方法用的最多的一集，有大量好用的被封装好的方法，我只负责对方法进行封装，构造新的方法，再调用方法\u0026hellip; 因此，在debug时，C语言和OOpre两门课带给我的感受是很不一样的。前面是对于方法具体实现细枝末节的深深考究，而OOpre的思路总是流畅贯通，哪里有问题它可以根据逻辑分析直接推理出漏洞\n以对象为主体的视角 这一点，是我在第四次迭代中深刻体悟到的，万物皆为对象。前文已有讲述。\n课程建议 希望可以像CO一样提前有一定的基础知识学习期，提供资料自学容器，子类，接口等内容的基础知识，解决课上刚学会的知识总是不能快速理解运用的问题。\n","date":"2024-11-01T13:30:00+08:00","image":"https://demiurge-zby.github.io/p/oopre%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/d477300c36f0221527b9816c97bed3b_hu13817389781556842652.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93/","title":"oopre结课总结"},{"content":" 设计文档 前情提要 本次搭建需要实现的指令有\nadd,sum,ori,lui sw,lw beq jal,jr nop 在此基础之上，本人额外添加了lh,lb,sh,sb,j指令。\nverilog的基本构建思路源始于logisim，Tunnel化的logisim电路为verilog代码的编写提供了很大的便利和可扩展性。\nverilog的编写仍然从数据通路基础部件和控制器两方面来书写，不过额外的是，在mips.v中应当实现所有的基础接线操作。\n或者说，mips.v是最独特的一环。\n一切源代码仅供参考，千万不要抄袭！！\n数据通路的构建 PC PC作为CPU中的时序电路核心器件，其功能实现也较为简单，只有同步复位操作和npc赋值操作。\n直接由logisim文件分析PC模块的接口\n名称 位宽 方向 npc 32 I clk 1 I reset 1 I pc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 `default_nettype none module PC( input wire [31:0] npc, input wire clk, input wire reset, output wire [31:0] pc ); reg [31:0] PCreg; always @(posedge clk) begin if (reset) begin PCreg \u0026lt;= 32\u0026#39;h00003000; end else begin PCreg \u0026lt;= npc; end end assign pc = PCreg; endmodule NPC NPC与P3不同，加入了jal，jr指令，使得其增加了两种全新跳转方式：\n26位立即数经位拼接得到直接地址 32为GRF数据得到直接地址 再加上原来的pc+4与pc+4+sign_ext(imm)\n共有四种跳转逻辑，需要较多的控制信号\nbr 和 zero 控制 相对寻址跳转 j 控制imm_26绝对寻址跳转\njr 控制$ra绝对寻址跳转\n接口信息如下：\n名称 位宽 方向 pc 32 I imm_16 16 I imm_26 26 I reg_ra 32 I br 1 I zero 1 I j 1 I jr 1 I pc_4 32 O npc 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 `default_nettype none module NPC( input wire br, input wire zero, input wire [15:0] imm_16, input wire [25:0] imm_26, input wire [31:0] pc, input wire [31:0] reg_ra, input wire j, input wire jr, output wire [31:0] pc_4, output wire [31:0] npc ); wire [31:0] j_pc; wire [31:0] br_pc; assign pc_4 = pc + 32\u0026#39;d4; assign j_pc = {pc[31:28],imm_26,{2{1\u0026#39;b0}}}; assign br_pc = pc_4 + {{15{imm_16[15]}},imm_16[14:0],{2{1\u0026#39;b0}}}; assign npc = (jr) ? reg_ra : (j) ? j_pc : (br \u0026amp;\u0026amp; zero) ? br_pc : pc_4; endmodule IM IM作为需要读取指令的单位，需要调用readmemh\n为了保证读取的正确顺序，定义寄存器堆时使用[0:4095]\n也可以添加参数控制readmemh读取到的起始位置与终止位置\n由于该指令寄存器堆应当存储4096*32bit\n然而起始位置却是0x00003000 因此可以先对pc减去0x00003000\n再取[13:2]作为指令寄存器堆的读取地址\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I Instruction 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 `default_nettype none module IM( input wire [31:0] pc, input wire reset, input wire clk, output wire [31:0] Instruction ); wire [31:0] address; reg [31:0] InstrMemory [0:4095]; always @(posedge clk) begin if(reset) begin $readmemh(\u0026#34;code.txt\u0026#34;, InstrMemory); end end assign address = pc - 32\u0026#39;h00003000; assign Instruction = InstrMemory[address[13:2]]; endmodule EXT 注意位拼接操作的写法！！不能少打大括号\n位拼接“0”时，一定要控制有多少个0\n例如16个“0”,应使用{16{1\u0026rsquo;b0}}或{16\u0026rsquo;b0}\n名称 位宽 方向 EXTOp 1 I imm_16 16 I IMM_32 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `default_nettype none module EXT( input wire EXTOp, input wire [15:0] imm_16, output wire [31:0] IMM_32 ); wire [31:0] signed_IMM; wire [31:0] unsigned_IMM; assign signed_IMM = {{16{imm_16[15]}},imm_16}; assign unsigned_IMM = {{16{1\u0026#39;b0}},imm_16}; assign IMM_32 = EXTOp ? signed_IMM : unsigned_IMM; endmodule GRF GRF的最特殊性在于其0号寄存器\n值不能被改变 始终值为0 在此有两种处理方案\n初始时为所有寄存器赋0\n之后不对0号寄存器进行写入 读0号寄存器时始终输出0 由于个人偏好，希望各个寄存器中的值保持正确，本人采用了第一种写法\n根据题目要求，需要输出寄存器被写时的各项参数，需要将pc传入其中\n接口如下所示：\n名称 位宽 方向 pc 32 I reset 1 I clk 1 I WE 1 I A1 5 I A2 5 I A3 5 I WD 32 I RD1 32 O RD2 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 `default_nettype none module GRF( input wire [31:0] pc, input wire [4:0] A1, input wire [4:0] A2, input wire [4:0] A3, input wire [31:0] WD, input wire reset, input wire clk, input wire WE, output wire [31:0] RD1, output wire [31:0] RD2 ); reg [31:0] grf [31:0]; integer i; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 32;i = i + 1) begin grf[i] \u0026lt;= 32\u0026#39;b0; end end else begin if(WE \u0026amp;\u0026amp; A3) begin grf[A3] \u0026lt;= WD; $display(\u0026#34;@%h: $%d \u0026lt;= %h\u0026#34;, pc, A3, WD); end end end assign RD1 = grf[A1]; assign RD2 = grf[A2]; endmodule ALU 实现基本与logisim同理，但是操作更为简单\n注意使用`define以增强代码可读性\n名称 位宽 方向 ALUOp 2 I num_1 32 I num_2 32 I zero 1 O out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 `default_nettype none `define ADD 2\u0026#39;b00 `define SUB 2\u0026#39;b01 `define ORI 2\u0026#39;b10 `define LUI 2\u0026#39;b11 module ALU( input wire [1:0] ALUOp, input wire [31:0] num_1, input wire [31:0] num_2, output wire zero, output wire [31:0] out ); wire [31:0] add; wire [31:0] sub; wire [31:0] ori; wire [31:0] lui; assign add = num_1 + num_2; assign sub = num_1 - num_2; assign ori = num_1 | num_2; assign lui = {num_2[15:0],{16{1\u0026#39;b0}}}; assign zero = (num_1 == num_2) ? 1\u0026#39;b1 : 1\u0026#39;b0; assign out = (ALUOp == `ADD) ? add : (ALUOp == `SUB) ? sub : (ALUOp == `ORI) ? ori : lui; endmodule DM 仅对于lw和sw而言，DM本应是极为简单的。\n但是正因为sh,sb的特殊性，我尝试了对其功能的描述\nsh,sb指令的核心问题，在于我们不能直接做到针对一个字部分内容的修改\n因为我们的寄存器都是以32bit为单位的 因此我们要先把它所在寄存器的值取出来，进行位拼接操作得到该寄存器应存入的新数，再存入DM之中\n由于添加了指令，我的WE与RE信号都进行了调整\n控制信号取值 含义 00 以w为单位 01 以h为单位 10 以b为单位 11 不予使能 同样地，为了输出中间参数，pc需要被引入。\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 我还添加了word,half,by_te等中间变量，便于我后续的描述\n名称 位宽 方向 pc 32 I data 32 I addr 32 I WE 2 I RE 2 I clk 1 I reset 1 I out 32 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 `default_nettype none `define SW 2\u0026#39;b00 `define SH 2\u0026#39;b01 `define SB 2\u0026#39;b10 `define LW 2\u0026#39;b00 `define LH 2\u0026#39;b01 `define LB 2\u0026#39;b10 module DM( input wire [31:0] pc, input wire [31:0] data, input wire [31:0] addr, input wire [1:0] WE, input wire [1:0] RE, input wire clk, input wire reset, output wire [31:0] out ); reg [31:0] DataMemory [0:3071]; integer i; wire [11:0] word; wire half; wire [1:0] by_te; assign word = addr[13:2]; assign by_te = addr[1:0]; assign half = addr[1]; always @(posedge clk) begin if (reset) begin for (i = 0; i \u0026lt; 3072; i = i + 1) begin DataMemory[i] \u0026lt;= 32\u0026#39;b0; end end else begin case (WE) `SW: begin DataMemory[word] \u0026lt;= data; $display(\u0026#34;@%h: *%h \u0026lt;= %h\u0026#34;, pc, addr, data); end `SH: begin case (half) 1\u0026#39;b1: begin DataMemory[word] \u0026lt;= {data[15:0], DataMemory[word][15:0]}; end 1\u0026#39;b0: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[15:0]}; end default: begin end endcase end `SB: begin case (by_te) 2\u0026#39;b11: begin DataMemory[word] \u0026lt;= {data[7:0], DataMemory[word][23:0]}; end 2\u0026#39;b10: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:24], data[7:0], DataMemory[word][15:0]}; end 2\u0026#39;b01: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:16], data[7:0], DataMemory[word][7:0]}; end 2\u0026#39;b00: begin DataMemory[word] \u0026lt;= {DataMemory[word][31:8], data[7:0]}; end default: begin end endcase end default: begin end endcase end end assign out = (RE == `LW) ? DataMemory[word] : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b1) ? {{16{DataMemory[word][31]}},DataMemory[word][31:16]} : (RE == `LH \u0026amp;\u0026amp; half == 1\u0026#39;b0) ? {{16{DataMemory[word][15]}}, DataMemory[word][15:0]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b11) ? {{24{DataMemory[word][31]}}, DataMemory[word][31:24]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b10) ? {{24{DataMemory[word][23]}}, DataMemory[word][23:16]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b01) ? {{24{DataMemory[word][15]}}, DataMemory[word][15:8]} : (RE == `LB \u0026amp;\u0026amp; by_te == 2\u0026#39;b00) ? {{24{DataMemory[word][7]}}, DataMemory[word][7:0]} : 32\u0026#39;b0; endmodule 控制器的编写 在搭建数据通路的过程中，控制信号的要求也已经浮出水面。\n关键还是由IM到指令，由指令到控制信号的过程\n不过加入了其他操作，使得DMWr,DMRd发生了一定的改变 以及额外添加的Link,J,Jr等控制信号\n相较于P3的BSel,此处本人将其更名为ImmSel,强调其解决的是立即数与寄存器谁参与ALU运算的问题\n名称 位宽 方向 opcode 6 I funct 6 I Br 1 O EXTOp 1 O RFWr 1 O DMWr 2 O DMRd 2 O ALUOp 2 O WrSel 1 O WdSel 1 O ImmSel 1 O Link 1 O J 1 O Jr 1 O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 `default_nettype none module CTRL( input wire [5:0] opcode, input wire [5:0] funct, output wire Br, output wire EXTOp, output wire RFWr, output wire [1:0] DMWr, output wire [1:0] DMRd, output wire [1:0] ALUOp, output wire WrSel, output wire WdSel, output wire ImmSel, output wire Link, output wire J, output wire Jr ); wire add; wire sub; wire ori; wire lui; wire sw; wire sh; wire sb; wire lw; wire lh; wire lb; wire beq; wire j; wire jal; wire jr; wire R; assign R = (opcode == 6\u0026#39;b000000); assign add = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100000); assign sub = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b100010); assign jr = R \u0026amp;\u0026amp; (funct == 6\u0026#39;b001000); assign j = (opcode == 6\u0026#39;b000010); assign jal = (opcode == 6\u0026#39;b000011); assign ori = (opcode == 6\u0026#39;b001101); assign lui = (opcode == 6\u0026#39;b001111); assign sw = (opcode == 6\u0026#39;b101011); assign sh = (opcode == 6\u0026#39;b101001); assign sb = (opcode == 6\u0026#39;b101000); assign lw = (opcode == 6\u0026#39;b100011); assign lh = (opcode == 6\u0026#39;b100001); assign lb = (opcode == 6\u0026#39;b100000); assign beq = (opcode == 6\u0026#39;b000100); assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign ImmSel = ori || lui || sw || sh || sb || lw || lh || lb; assign EXTOp = sw || sh || sb || lw || lh || lb; assign ALUOp = sub ? 2\u0026#39;b01 : ori ? 2\u0026#39;b10 : lui ? 2\u0026#39;b11 : 2\u0026#39;b00; assign RFWr = add || sub || ori || lui || lw || lb || lh || jal; assign DMRd = lw ? 2\u0026#39;b00 : lh ? 2\u0026#39;b01 : lb ? 2\u0026#39;b10 : 2\u0026#39;b11; assign DMWr = sw ? 2\u0026#39;b00 : sh ? 2\u0026#39;b01 : sb ? 2\u0026#39;b10 : 2\u0026#39;b11; endmodule mips.v 前面说了那么多，其实都是相对独立的结构 那么接下来，才是verilog描述的独特之处 才能更深刻地展示verilog的抽象功能\n接口十分简单，毕竟真正来自外部的信号只有clk和reset\n名称 位宽 方向 clk 1 I reset 1 I 1 2 3 4 5 `default_nettype none module mips( input wire clk, input wire reset ); 接线逻辑 在我书写这一板块的过程中，我曾选用了将所有的wire先定义好，再全部统一赋值，再逐个接接口的方法\n结果这样导致的问题（或者说我曾经出现的bug） 就是你不能确定你需要的信号都得到了定义与赋值\n因此，我秉承了P3的基本思路，对各个部件的外部接线进行分析。\n分析方法：\n先定义所有需要的输出信号 输入信号分为 直接与其他某部件的输出信号直接相连 由其他部件的输出信号相互作用（计算or选择）得到 为这些相互作用进行assign处理 基础信号 名义上如此，其实这是在模拟我没有模块化的Splitter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 基础信号定义 wire [5:0] opcode; wire [4:0] rs; wire [4:0] rt; wire [4:0] rd; wire [4:0] shamt; wire [5:0] funct; assign opcode = Instr[31:26]; assign rs = Instr[25:21]; assign rt = Instr[20:16]; assign rd = Instr[15:11]; assign shamt = Instr[10:6]; assign funct = Instr[5:0]; wire [15:0] imm_16; wire [25:0] imm_26; assign imm_16 = Instr[15:0]; assign imm_26 = Instr[25:0]; CTRL 定义大量控制信号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //控制信号定义 wire Br; wire EXTOp; wire RegWrite; wire [1:0] DMWr; wire [1:0] DMRd; wire [1:0] ALUOp; wire WrSel; wire WdSel; wire ImmSel; wire Link; wire J; wire Jr; CTRL Ctrl( .opcode(opcode), .funct(funct), .Br(Br), .EXTOp(EXTOp), .RFWr(RegWrite), .DMWr(DMWr), .DMRd(DMRd), .ALUOp(ALUOp), .WrSel(WrSel), .WdSel(WdSel), .ImmSel(ImmSel), .Link(Link), .J(J), .Jr(Jr) ); PC 定义输出信号pc\n1 2 3 4 5 6 7 8 // PC 输出信号 wire [31:0] pc; PC Pc( .npc(npc), .clk(clk), .reset(reset), .pc(pc) ); IM 定义输出信号Instr\n1 2 3 4 5 6 7 8 9 10 // IM输出信号 wire [31:0] Instr; IM Im( .pc(pc), .Instruction(Instr), .clk(clk), .reset(reset) ); EXT 定义输出信号IMM_32\n1 2 3 4 5 6 7 8 // EXT输出信号 wire [31:0] IMM_32; EXT Ext( .EXTOp(EXTOp), .imm_16(imm_16), .IMM_32(IMM_32) ); NPC 定义输出信号npc和pc_4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // NPC输出信号 wire [31:0] npc; wire [31:0] pc_4; NPC Npc( .br(Br), .zero(zero), .imm_16(imm_16), .imm_26(imm_26), .pc(pc), .reg_ra(RD1), .j(J), .jr(Jr), .pc_4(pc_4), .npc(npc) ); GRF 定义输出信号RD1,RD2 定义输入信号，并给出其assign语句实现赋值 要知道，输入信号一定要从其他部件的输出信号或者外部的clk 与reset中得到 如果盲目定义输入信号，却不予有意义的赋值，就会产生xxxzzz等问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // GRF 输入信号·中间变量 wire [31:0] LinkPC; wire [4:0] A1; wire [4:0] A2; wire [4:0] RegAddr; wire [31:0] RegData; // GRF 中间变量的赋值 assign LinkPC = pc_4; assign A1 = rs; assign A2 = rt; assign RegAddr = Link ? 5\u0026#39;b11111 : WrSel ? rd : rt; assign RegData = Link ? LinkPC : WdSel ? MemReadData : ALUData; // GRF 输出信号 wire [31:0] RD1; wire [31:0] RD2; GRF Grf( .clk(clk), .reset(reset), .WE(RegWrite), .pc(pc), .A1(A1), .A2(A2), .A3(RegAddr), .WD(RegData), .RD1(RD1), .RD2(RD2) ); ALU 输出信号zero和ALUData\n定义输入信号num_1，num_2并给出assign\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ALU 输入信号·中间变量 wire [31:0] num_1; wire [31:0] num_2; // ALU 中间变量的赋值 assign num_1 = RD1; assign num_2 = ImmSel ? IMM_32 : RD2; // ALU 输出信号 wire zero; wire [31:0] ALUData; ALU Alu( .ALUOp(ALUOp), .num_1(num_1), .num_2(num_2), .zero(zero), .out(ALUData) ); DM 这两个输入变量的赋值是否没有意义？\nMemAddr一定是ALUData?\nMemData一定是RD2?\n可能确实如此。 但是这样的命名使得整体逻辑更为清晰，也增强了可扩展性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // DM 输入信号·中间变量 wire [31:0] MemAddr; wire [31:0] MemData; // DM 中间变量的赋值 assign MemAddr = ALUData; assign MemData = RD2; // DM 输出信号 wire [31:0] MemReadData; DM Dm( .pc(pc), .data(MemData), .addr(MemAddr), .WE(DMWr), .RE(DMRd), .clk(clk), .reset(reset), .out(MemReadData) ); endmodule 测试文档 我仍然采用了对拍的方法，并自行构造了一定数据。\n对于新增指令，我着重加强了对jr,jal的测试\n以下是一组测试数据，重点观察$ra取值的改变是否正常\n1 2 3 4 5 6 7 8 9 0c000c06 // jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f0000 //ori $ra, $0, 0 0c000c06 //jal label 341f301c //ori $ra, $0, 0x0000301c //label: 03e00008 //jr $ra 03fff820 //add $ra, $ra, $ra 可知$ra会在pc+4和0不断跳转\n直到变为0x0000301c后跳转到add语句变为0x00006038\n下面是我的输出结果，与MIPS结果一致\n1 2 3 4 5 6 7 @00003000: $31 \u0026lt;= 00003004 @00003004: $31 \u0026lt;= 00000000 @00003008: $31 \u0026lt;= 0000300c @0000300c: $31 \u0026lt;= 00000000 @00003010: $31 \u0026lt;= 00003014 @00003014: $31 \u0026lt;= 0000301c @0000301c: $31 \u0026lt;= 00006038 思考题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ?\naddr信号来自于ALU的计算，即GRF[base]+sign_ext(offset) 其中addr[11:2]意为取ALU计算结果从第2位开始的12位数字作为address。 其原因在于对于lw指令，第0位和第1位均为0，自第2位起开始计数才是以32bit为单位，才能与DM寄存器堆的寄存器编号相对应。\n思考两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。\n控制信号每种取值所对应的指令： 举例：\n1 2 3 4 5 6 7 assign Br = beq; assign Jr = jr; assign Link = jal; assign J = jal || j; assign WdSel = lw || lh || lb; assign WrSel = add || sub; assign EXTOp = sw || sh || sb || lw || lh || lb; 每条指令对应的控制信号取值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 always@(*) begin case (Operation) `ADD : begin Br = 1\u0026#39;b0; Jr = 1\u0026#39;b0; Link = 1\u0026#39;b0; J = 1\u0026#39;b0; WrSel = 1\u0026#39;b1; ... end ... default : begin end end 分析优劣： 由指令确定其控制信号： 优点：考虑全面，不会有漏掉的指令，对每个指令也不会有漏掉的控制信号 上机新增指令时直接对其分析，一个也不会漏 缺点：代码重复冗长 产生新的控制信号时还需要对每个指令都加句话\n对控制信号归纳其生效指令： 优点：本质上是上一种方法的总结归纳，代码量少 缺点：自行归纳时某些控制信号可能会忘记考虑一些指令\nPS：解决方法：对新指令在演草纸上进行所有控制信号枚举，之后再进行归纳，用于代码书写\n在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。\n同步复位：clk优先（还必须得是上升沿） 异步复位：reset优先\nC 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。\n1 2 if temp32 ≠ temp31 then SignalException(IntegerOverflow) 这是add和addu、addi和addiu的唯一区别 u的本意即为不考虑输出 那在忽略输出的前提下自然就等价了。\n","date":"2024-10-31T14:15:30+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p4-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/292fa3e8c7e86664cbaefef9ddc7893_hu9110516496620476980.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p4-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84verilog%E6%90%AD%E5%BB%BA/","title":"北航CO P4 单周期CPU的verilog搭建"},{"content":"序列输入之数据特征分析 数据类型 不作介绍 关系 顺序关系 依次赋值 层次关系（赋值的所属对象） 1 2 3 4 5 6 7 8 Scanner scanner = new Scanner(System.in); int i; int n = scanner.nextInt(); for(i = 0; i \u0026lt; n; i++){ id = scanner.nextInt(); name = scanner.next();// id 与 name之间为顺序关系 // 不同组之间形成不同层次 } 结构 硬编码式的解析处理 较为简单，确定的输入方式 缺点：兼容性灵活性差 使用正则表达式的解析处理 可对应一个有穷自动机解析 默认使用贪婪匹配\n\u0026ldquo;.\u0026rdquo; 任意\n\u0026ldquo;*\u0026rdquo; 同一项内容任意项\n\u0026ldquo;+\u0026rdquo; 同一内容一项或多项\n\u0026ldquo;?\u0026rdquo; 同一内容零项或一项\n非贪婪匹配\n```java Pattern = new Pattern.compile(\u0026quot;(\\\\w+?)((good)*)\u0026quot;); // 添加 \\w+? 实现非贪婪 // 注意 \\\\ 编译问题 ``` 弊端：可读性差，技巧性高\n递归下降式解析处理 递归 借助递归进行解析 下降 从顶层到底层 按层解析 文法 终结符 取值不可变的符号，单个字符层级上的元素 非终结符 取值可变，以\u0026lt;\u0026gt;表示 定义规则 L -\u0026gt; R\n定义非终结符的取值方式\n1 2 3 4 5 \u0026lt;Var\u0026gt; -\u0026gt; \u0026lt;digit\u0026gt; | \u0026lt;Const\u0026gt; \u0026lt;Var\u0026gt; //递归下降 无限循环 \u0026lt;Const\u0026gt; -\u0026gt; \u0026lt;op\u0026gt; | \u0026lt;digit\u0026gt; \u0026lt;op\u0026gt; \u0026lt;digit\u0026gt; -\u0026gt; \u0026#39;0\u0026#39;|\u0026#39;1\u0026#39;|\u0026#39;2\u0026#39;|\u0026#39;3\u0026#39;|\u0026#39;4\u0026#39;|\u0026#39;5\u0026#39;|\u0026#39;6\u0026#39;|\u0026#39;7\u0026#39;|\u0026#39;8\u0026#39;|\u0026#39;9\u0026#39; \u0026lt;op\u0026gt; -\u0026gt; \u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;|\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39; // \u0026#39;+\u0026#39;为终结符，\u0026lt;op\u0026gt;,\u0026lt;Const\u0026gt;为非终结符 词法分析：定义Token 1 2 3 4 5 public class Token{ private String name; private Type type; // ... } //实现了一种抽象 语法分析：建立抽象语法树 根据文法所定义的关系\n1 2 3 4 5 public class Var{ private Arraylist\u0026lt;digit\u0026gt;; private Arraylist\u0026lt;op\u0026gt;; // ... } // 在表达树的方面降了一层 由表达式到项，由项到因子\n每一个非终结符都对应一棵局部语法树\n唉唉 只是课上跟着写还是太草率了\n不如PPT\n","date":"2024-10-24T15:30:00+08:00","image":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/15c277c39924c01bcd89e8f7b84de46_hu6067831623915793491.jpg","permalink":"https://demiurge-zby.github.io/p/oopre%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5/","title":"oopre课堂随笔-序列输入"},{"content":" 设计文档 Key Point: 数据通路，控制器及其连接\n要实现的核心指令介绍 add,sub,lui,ori,lw,sw,beq,nop\n数据通路的建立 名称 功能 简写 程序计数器 输出当前指令所在地址 PC 下指令地址 计算下一指令所在地址并传递给PC NPC 寄存器堆 32 个 32 位寄存器 GRF 指令存储器 存储所有的指令 IM 数据存储器 充当内存存储数据 DM 扩展单元 进行位扩展运算 EXT 算术逻辑单元 进行各项基本运算 ALU 下面先对各数据通路进行分析，并在此过程中得到对控制器的需求\n(在每个数据通路中都只考虑自己需要什么！\n输出的东西如何被使用是其他数据通路考虑的事情！！)\nPC 一个 32 位寄存器即可\n输出引脚：输出当前指令所在地址，提供给IM用于取指令\n输入引脚：由NPC算出的下一条指令地址\n作为整个设备中最核心的时序逻辑，在PC层面其本质应为Moore机\n在下一周期上升沿才可输出下一PC\n在输出PC以后，其他数据通路都基本呈现组合逻辑的形态，即时性进行输出内容的改变，即Mealy机\n（ROM和GRF的写入操作还是要等下一上升沿的，但是关于其写入的各项信息都是即时性得到的）\n当然，最后输出PC值的时候要再加上 3000\n若用PC初始化3000的方法，在复位后PC还是会输出 0\nNPC 下一指令的地址可能是PC+4\n对于beq跳转 也可能是PC+4+sign_ext(imm_16 || 00)\n对于j, jal跳转 还可能是PC[31:28] || imm_26 || 00\n输入引脚：输入当前PC值，imm_16, imm_26\n选择信号：br, zero, j\n这里区分br和zero是有原因的。\n详见zero产出地：ALU\n输出引脚：下一条指令PC值\n！！经后续分析，对于XXXAndLink指令，PC+4是被需要的，那就直接从NPC输出\nNPC外部的连接也比较直白\n具体分析：\n控制信号的使用：\n只有br和zero同时为1时才是成功beq跳转 鉴别出j，jal等才使用imm_26直接地址跳转 Tips: 由于jal指令为本人后续添加，因此选择了新增了MUX而不是改变原MUX\n计算过程实现：简单的加法，移位，位扩展，位拼接运算\n要注意位扩展一定是sign_ext，因此完全可以直接使用bit_sign_extender\nIM 采用了4096*32bit的ROM 地址长度选项只需12位\n！！ROM的地址以字为单位，因此PC要右移2位才能传给ROM\n右移之后还需bit_extender到12位\n（一定要先右移再extend，因为实质上就是取PC[13:2]）\n其余的没什么内容了\nSplitter 把这个东西单独拿出来写只是图个方便（）\nSplitter内部的构造就只是一些小splitter\nEXT EXT也是一个相对好说的部件\n根据EXTOp进行不同形式的位扩展\n（缺点（？）是只能用于16bit -\u0026gt; 32bit）\nEXTOp 含义 0 无符号扩展 1 符号扩展 EXTOp具体怎么得到就是Ctrl要考虑的了\n外部构造：\n内部结构：\n好的我刚刚意识到bit_extender本来就可以输入EXTOp\n但是我的EXT更好看（？）那就不改了\nGRF GRF相对来说就复杂多了\n内部结构在P0课下已经搭好了，但其正确性仍需后续测试\n在此仅略加展示：\n而其外部结构也大有文章\n指令 使用数据 add,sub 读rs,rt写ALU到rd ori 读rs写ALU到rt lui 写ALU到rt lw 读rs（即base）求ALU写MemReadData到rt sw 读rs（即base）求ALU但不写Grf beq 读rs,rd求ALU（做减法判zero）但不写Grf jal 不读但写PC+4到$31 因此构造相应的控制信号与多路选择器即可\nWrsel 含义 0 写到rt 1 写到rd Wdsel 含义 0 写ALU的结果 1 写MemReadData 后续添加的jal指令我又使用了控制信号Link\nLink 含义 0 按上述两个选择器行事 1 写PC+4到$31 当然，除此之外还有最重要的写使能信号\n整体外部结构如下图所示：\nALU 首先明确ALU要解决的问题：\n加法，减法，或，左移16位共4种运算\n显然ALUOp需要4种，即需要两位信号\nALUOp 使用指令 00 add，加法 01 sub，beq，减法 10 ori，或运算 11 lui，左移16位 不过，我并没有直接分四种器件进行操作\n采用了gxp老师课上提到的方法：\n加法和减法可使用同一加法器！！\na - b = a + ~b + 1\n而两个数相加再加1正是加法器已经提供的功能！\n最上方的接口即为进位接口\n！但是复用器件的代价就是更多的选择信号\n减法不仅仅要选择进位信号，还要选择参与运算的数\n对于整个ALU还需要区分进行了什么运算\n我们分为如下三个\n使用指令 M1 M1含义 Cin Cin含义 M2 M2含义 加法 0 使用b 0 进位为0 00 加减 减法 1 使用~b 1 进位为1 00 加减 或运算 X X X X 01 或运算 左移16位 X X X X 10 左移 如何根据ALUOp写出这些控制信号也一目了然：\n只需把上面两个表合起来，让ALUOp直接对应控制信号\n用Combinational Analysis给我们写出来就行了\n最终内部结构如下：\n在此解释前文NPC中zero与br都需存在的原因：\nbeq也是对rs,rt的值做减法，但关键在于结果值为0时输出zero信号为1\n因此zero信号也是会被sub甚至add干扰的\n所以在zero==1时必须有br==1才有效\n另一方向显然，br==1时判跳转有效当然离不开zero==1的判定\n关于其外部连接，关键只是两个控制信号：\n我们把GRF处使用的表格稍有侧重点地修改\n指令 使用数据 add,sub rs,rt算ALU（加减） ori rs，imm算ALU（或运算） lui imm算ALU（移位） lw,sw rs，imm算ALU（加法） beq rs,rd算ALU（做减法判zero） 将rs替换成RD1，将rt,rd按照对应法则替换到RD2\n可得到更清晰的表格\n指令 使用数据 add,sub RD1,RD2算ALU（加减） ori RD1，imm算ALU（或运算） lui imm算ALU（移位） lw,sw RD1，imm算ALU（加法） beq RD1,RD2算ALU（做减法判zero） 即可发现控制信号除了ALUOp之外，还有操作数2的选择\n操作数2可选择RD2或imm\n因此构造相应的控制信号与多路选择器即可\nBsel 含义 0 RD2 1 imm 这里的imm都是imm_16经过EXT的结果\n事已至此，可以顺便EXTOp也考虑清楚\n准确来说，只有ori需要无符号（EXTOp == 0）\nEXTOp 指令 0 ori 1 lw,sw X 其他 beq的sign_ext已经在NPC里面确认了\nEXTOp对于beq指令没有意义\n外部连接如下图所示：\nDM 我们采用了3072*32bit的RAM 地址长度选项只需9位\nDM和GRF逻辑类似\n但是由于我们直接使用RAM\n在一些内容的表达上需要按照RAM行事\nRAM 应使用双端口模式，即设置 RAM 的 Data Interface 属性为 Separate load and store ports RAM的ld也需要特别激活，因此需要一个lw信号来控制它 str信号就是普通的写使能信号 clr信号为异步复位信号 和ROM类似，RAM的地址也以字为单位，因此PC要右移2位才能传入 右移之后还需bit_extender到9位 （一定要先右移再extend，因为实质上就是取PC[10:2]）\nDM的A接口是地址，由ALU算出\n要存入的信息则是GRF从rt读出来的RD2\n连接比较简单\n控制器的搭建 在数据通路的苦苦搭建之中，其实控制信号已经都有了自己的定义\n我们发现，这些定义一般都依赖于指令\n那么控制器就可以建起这个桥梁：\n通过opcode和funct得到指令\n再由指令得出控制信号\n由外部信号到指令 得到指令的过程我使用了比较器，因此构建过程非常简单\n由指令到控制信号 由指令到控制信号那可就更简单了\n除了 ALUOp（）\n我们使用OR阵列\n哪条指令需要这个信号，我们就给它或到这个控制信号上\n这种拉线式的写法还是很方便的\nALUOp就只能拜托我们亲爱的Combinational Analysis啦\nCTRL在整个main电路中的书写还是比较简单的\n我把他设计成了一个很富有信息量的样子（）\n搭电路的过程中一些小惬意的时光就是在修改电路外观~\n测试文档 那么至此，我们的基础版CPU算是实现了基本自洽\n接下来，就需要有大量的边界与随机指令去测试它了！\n我首先测试了课程组给出的附件，并翻译为MIPS\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 .text ori\t$28, $0, 0 ori\t$29, $0, 0 ori\t$1, $0, 0x3456 add\t$1, $1, $1 lw\t$1, 4($0) sw\t$1, 4($0) lui\t$2, 0x7878 sub\t$3, $2, $1 lui\t$5, 0x1234 ori\t$4, $0, 5 nop sw\t$5, -1($4) lw\t$3, -1($4) beq\t$3, $5, _1 beq\t$0, $0, _13 _1: ori\t$7, $3, 0x404 beq\t$7, $3, _11 nop lui\t$8, 0x7777 ori\t$8, $8, -1 sub\t$0, $0, $8 ori\t0, $0, 0x1100 add\t$10, $7, $6 ori\t$8, $0, 0 ori\t$9, $0, 1 ori\t$10, $0, 1 _minus2: add\t$8, $8, $10 beq\t$8, $9, _minus2 _13: _11: _minus1: beq\t$0, $0, _minus1 # dead continue 寄存器数据及跳转测试 // 本测试的不足之处在于支持了MARS不支持的错误运算 //如最大正数加1，最小负数减1，-1减最小负数等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //记得写v2.0 raw 3c00ffff // 测试`$0` //下面是对低16位赋值 3c01ffff 3c028000 00000000 //nop测试 3c047fff 3c058000 //下面是对低16位赋值 3421ffff // `$1` = -1 34420000 // `$2` = 最小负数 34630001 // `$3` = 1 3484ffff // `$4` = 最大正数 34a50001 // `$5` = 最小负数 + 1 //sw与lw的简单测试 ac64ffff //在0处存 `$4` 测试offset为负 bc200001 //把0处的值给`$0` 测试`$0` 8c040000 //把0处的值给`$4` 测试offset为0 00253020 // `$6` = `$5` + `$1` 10460002 //等于最小负数 跳2句 //跳-8句跳回形成死循环 00643820 //最大正数加一 10e20000 //等于最小负数 跳0句 00a34022 //最小负数+1减一 11020000 //等于最小负数 跳0句 01034822 //最小负数减一 11240000 //等于最大正数 跳0句 00225022 //-1减最小负数 1144fff8 //等于最大正数 跳-8句 检验方法 在保证sw无问题的前提下\n将所有的敏感变量都及时存储\nbe like:\n1 2 3 4 5 6 .macro save(%data) #不保存$t0,$t1 sw %data, 0($t0) # 不能用addi ori $t1, $0, 4 add $t0, $t0, $t1 .end_macro 之后只需要直接比对MARS和DM的存储区即可\n","date":"2024-10-23T12:30:15+08:00","image":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p3-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/88e20704208d17e1fd4372ecfb993c3_hu1946466944430747746.jpg","permalink":"https://demiurge-zby.github.io/p/%E5%8C%97%E8%88%AAco-p3-%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E7%9A%84logisim%E6%90%AD%E5%BB%BA/","title":"北航CO P3 单周期CPU的logisim搭建"},{"content":"Welcome!! I feel so excited and interested to create my first blog!\nI plan to name my blog \u0026lsquo;Demiurge\u0026rsquo; just because this song is really astonishing and touching\u0026hellip;\n(By the way, the illustration is also fantastic)\nI am suddenly awared that 我可以说中文\n那么，今后请多多指教！\n","date":"2024-09-24T00:37:20+08:00","image":"https://demiurge-zby.github.io/p/demiurgefirstblog/demiurge_hu5188072458766260427.png","permalink":"https://demiurge-zby.github.io/p/demiurgefirstblog/","title":"DemiurgeFirstBlog"}]