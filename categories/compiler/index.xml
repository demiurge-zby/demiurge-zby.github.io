<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Compiler on Demiurge</title>
        <link>https://demiurge-zby.github.io/categories/compiler/</link>
        <description>Recent content in Compiler on Demiurge</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Demiurge</copyright>
        <lastBuildDate>Sun, 07 Dec 2025 17:15:30 +0800</lastBuildDate><atom:link href="https://demiurge-zby.github.io/categories/compiler/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>BUAA Compiler 实验报告</title>
        <link>https://demiurge-zby.github.io/p/buaa-compiler-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</link>
        <pubDate>Sun, 07 Dec 2025 17:15:30 +0800</pubDate>
        
        <guid>https://demiurge-zby.github.io/p/buaa-compiler-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</guid>
        <description>&lt;img src="https://demiurge-zby.github.io/p/buaa-compiler-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/cuidu.jpg" alt="Featured image of post BUAA Compiler 实验报告" /&gt;&lt;hr&gt;
&lt;h2 id=&#34;说在前面&#34;&gt;说在前面
&lt;/h2&gt;&lt;p&gt;本文章尚未完工。&lt;/p&gt;
&lt;p&gt;本篇文章的内容并不能达到可以让你跟着做完整个编译器项目的程度，它只是我最终总结时的一些回忆，而非施工现场。&lt;/p&gt;
&lt;p&gt;倘若能在某个时候激发起你的共鸣，给予你信心或是方向，那便已是极好的了。&lt;/p&gt;
&lt;h2 id=&#34;整体架构&#34;&gt;整体架构
&lt;/h2&gt;&lt;h3 id=&#34;bzh学长的架构&#34;&gt;bzh学长的架构
&lt;/h3&gt;&lt;p&gt;顶层文件夹是Compiler与config，还有frontend,midend,backend,utils,optimise,error六个包。&lt;/p&gt;
&lt;p&gt;error进行错误处理，前端处理词法与语法分析，中端进行语义分析，LLVM体系定义与中间代码生成，后端进行MIPS语言体系的定义，optimise进行中端优化，utils是一些功能启动、文件输入输出、性能结果展示等附加功能的定义。&lt;/p&gt;
&lt;p&gt;compiler首先调用工具进行testfile的读入，然后调用前端得到tokenlist与语法树，语法树树根传给中端，中端遍历语法树得到符号表与中间代码结构，将中间代码模块传递给optimiser进行优化后，再传递给后端，后端递归执行toMips，得到最终的MIPS模块结构。&lt;/p&gt;
&lt;p&gt;所有产物都可以借助IOHandler输出为文件。&lt;/p&gt;
&lt;p&gt;再详细的架构再讲就讲不完了。&lt;/p&gt;
&lt;h3 id=&#34;我的简单改装&#34;&gt;我的简单改装
&lt;/h3&gt;&lt;p&gt;在细节上的架构，我和学长代码保持了较为高度的一致，最多只是将某些类进行合并或者拆分。&lt;/p&gt;
&lt;p&gt;但在宏观上我根据自己的主观理解，进行了较大的调整。不过意义也不是很大。&lt;/p&gt;
&lt;p&gt;我顶层的包分为前端，中端，后端，错误与工具。&lt;/p&gt;
&lt;p&gt;frontend在处理词法分析，语法分析之外，我没有传递语法树，而是继续在前端进行语义分析与中间代码生成。因为这一段本就是与源代码高度相关，语法树更是直接来源于源代码的文法。&lt;/p&gt;
&lt;p&gt;我在思考，如果真的做到修改源代码不必修改midend的话，midend里该有的内容，可能只有llvm那个文件夹。而visit与symbol都是属于与源代码有关的内容，如果更改了文法，肯定是要有改动的。&lt;/p&gt;
&lt;p&gt;因此我前端内部的文件夹有lexer,parse,ast,还有llvm_ir这个包，这个包包含symbol与visit，主要负责的就是产出中端所需的架构。&lt;/p&gt;
&lt;p&gt;midend在严格意义上，包含的动作只有中间代码优化。此外他还包括llvm的架构定义。因此里面包括llvm和optimiser两个包。&lt;/p&gt;
&lt;p&gt;backend则涵盖中间代码生成目标代码所需要的架构信息与Builder。有一个现象值得注意：后端的实质翻译工作 &lt;code&gt;toMips()&lt;/code&gt; 实际上定义在midend文件夹，也即llvm文件夹，因为从前往后推进的过程中，后端貌似就是要依赖于中端的架构才可以工作。&lt;/p&gt;
&lt;p&gt;那如果后端发生改变，需要更改的为什么是midend文件夹而不是backend文件夹呢？我想，可能只有优化严格属于中端，中端到后端的toMips函数可能只是身在中端，其实不属于中端吧。&lt;/p&gt;
&lt;p&gt;无论怎样，关于我的代码架构，我可以说，如果期末考试源代码文法发生改变，我确实只应当修改frontend文件夹。&lt;/p&gt;
&lt;h2 id=&#34;词法分析&#34;&gt;词法分析
&lt;/h2&gt;&lt;p&gt;刚开始接触编译器的搭建时，面对复杂多样的文法，茫然的情绪是毋庸置疑的。
但我一直对词法分析抱有美好愿想，因为它看起来只不过是把token提取出来，
这和整体的结构关系不大。&lt;/p&gt;
&lt;p&gt;但尽管是相对独立的结构，也需要融入整个大型框架。因此我借鉴了往届的优秀代码，
对编译器整体的前中后端与错误处理框架形成了基础认知，才开始了编写工作。&lt;/p&gt;
&lt;p&gt;不过官方已经给出了确定的token类别，其实词法分析的问题并不是很多。
需要注意的点是注释的处理，
可以检查一下&lt;code&gt;/*/&lt;/code&gt;与&lt;code&gt;/***/&lt;/code&gt;能否正确处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Oct.4更新：   &lt;br&gt;
注释相关的处理出现了问题！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跨行的注释请注意不能无脑read，要记录行数的增加！&lt;/li&gt;
&lt;li&gt;对于//，读取到\n之后要再read一次去掉换行符，否则会影响行数记录&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Oct.22更新：   &lt;br&gt;
注释相关的处理再次出现了问题！
参见讨论区。 &lt;br&gt;
&lt;img src=&#34;https://demiurge-zby.github.io/p/buaa-compiler-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image.png&#34;
	width=&#34;982&#34;
	height=&#34;472&#34;
	srcset=&#34;https://demiurge-zby.github.io/p/buaa-compiler-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image_hu9443800336733228216.png 480w, https://demiurge-zby.github.io/p/buaa-compiler-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image_hu1055654150862010912.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;208&#34;
		data-flex-basis=&#34;499px&#34;
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从架构而言，首先要形成frontend/midend/backend/utils这样的系统结构观念；其次在frontend中需要有一个frontend类，还要有parser/ast/lexer等等。我们在lexer中主要实现的就是针对读取到的char分析出是什么单词，并加入单词列表，因此还需要实现Token类和token类型。&lt;/p&gt;
&lt;p&gt;另外，作为最起始的框架，IO操作也是一个关键点，不过参考学长代码之后不难解决其处理模式，放在utils包中很有结构感。&lt;/p&gt;
&lt;h2 id=&#34;语法分析&#34;&gt;语法分析
&lt;/h2&gt;&lt;p&gt;语法分析的难度个人认为远超词法分析。
因为他看似只是进行结构的划分，但是结构的性质，也就是语义分析部分极为重要，
要尽可能形成相对科学合理的结构。 而这个结构，虽然文法已经给出了一些提示，
但还是有许多需要自己决定的结构。&lt;/p&gt;
&lt;h3 id=&#34;first集&#34;&gt;FIRST集
&lt;/h3&gt;&lt;p&gt;对于多分支的处理，我们常常使用FIRST集来尽可能区分不同的分支。&lt;/p&gt;
&lt;p&gt;简单的比如&lt;code&gt;Decl → ConstDecl | VarDecl&lt;/code&gt;，可以用const来区分。&lt;/p&gt;
&lt;p&gt;稍微复杂一点的比如&lt;code&gt;BlockItem → Decl | Stmt&lt;/code&gt;，
经过多层分析发现，First(Decl) 包括 CONSTTK | STATICTK | INTTK，
并且这些都不出现在stmt中，从而可以区分。&lt;/p&gt;
&lt;p&gt;最复杂的就是Stmt了，他的情况极其多，虽然大多数还是很好区分的，
比如if,for,continue,break,return,printf,block。
但是不好区分的就是&lt;code&gt;LVal=Exp;&lt;/code&gt;和&lt;code&gt;Exp;&lt;/code&gt;。原则上我们总可以发现在某个时候可能出现
可观测的差距，但是我们不妨可以使用这样的一种方法：&lt;/p&gt;
&lt;h3 id=&#34;回溯&#34;&gt;回溯
&lt;/h3&gt;&lt;p&gt;仔细观察&lt;code&gt;LVal=Exp;&lt;/code&gt;和&lt;code&gt;Exp;&lt;/code&gt;，可以知道LVal也属于Exp，因此一定可以被Exp识别。
那么只需要看读取Exp之后的符号即可，如果是&lt;code&gt;=&lt;/code&gt;，则说明是前者。&lt;/p&gt;
&lt;p&gt;但是原则上，LVal和Exp是不同的，形成的语法树结构也不同。因此前面的分析
只能用来判断，而不能用来构造语法树。&lt;/p&gt;
&lt;p&gt;这时候的识别就需要被回溯了。我们需要注意三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尝试的时候不能更改树的结构，可以new，可以parse，但是不能add到树上。&lt;/li&gt;
&lt;li&gt;尝试过程中如果遇到语法错误，不可以记录。&lt;/li&gt;
&lt;li&gt;在尝试前标记当前位置用于回溯。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;期中考试 Update：&lt;/p&gt;
&lt;p&gt;考了回溯，不过不能像原来那样&lt;strong&gt;直接预读Exp&lt;/strong&gt;了，
或者说&lt;strong&gt;公共部分不是已有的非终结符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过没关系，你只需要自己创建这样一个非终结符就好了，
这个非终结符的parse也只需要复制公共部分的相关内容就好。&lt;/p&gt;
&lt;p&gt;我们只需&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录位置，关闭报错&lt;/li&gt;
&lt;li&gt;parse完这个公共部分&lt;/li&gt;
&lt;li&gt;通过peek找差异，判定好类型&lt;/li&gt;
&lt;li&gt;回到原位，开启报错&lt;/li&gt;
&lt;li&gt;按照你识别的类型addNode即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;递归&#34;&gt;递归
&lt;/h3&gt;&lt;p&gt;对于Exp的那一堆，经过一系列拆解，会发现真正的递归其实只出现在UnaryExp中。
不过这里是右递归，所以我们可以大胆递归。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;右递归本来就是安全的，不安全的是在重重循环中从未consume的左递归。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;左递归结构还原&#34;&gt;左递归结构还原
&lt;/h3&gt;&lt;p&gt;针对Exp出现的大量左递归，我们一般的处理方法就是直接消除左递归，
把&lt;code&gt;LOrExp → LAndExp | LOrExp &#39;||&#39; LAndExp&lt;/code&gt;
改成&lt;code&gt;LOrExp → LAndExp {&#39;||&#39; LAndExp}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这用来解析当然是没问题的，但是这其实已经修改了文法，
导致语法树的结构发生了变化，输出的结果就会不一样。&lt;/p&gt;
&lt;p&gt;因此，我们需要对语法树进行还原，使其恢复原来的结构。
我们知道除了最后一个&lt;code&gt;LAndExp是真的LAndExp&lt;/code&gt;，其余的其实都是&lt;code&gt;LOrExp-&amp;gt;LAndExp&lt;/code&gt;。
所以我们要new一个新的&lt;code&gt;LOrExp&lt;/code&gt;，把&lt;code&gt;LAndExp&lt;/code&gt;放进去，然后再装进components里面。&lt;/p&gt;
&lt;h2 id=&#34;语义分析&#34;&gt;语义分析
&lt;/h2&gt;&lt;p&gt;说到语义分析，主要内容就是符号表管理与错误处理两大部分。
其中关于符号表的内容，仅从通过测试来考虑的话，只需要考虑decl语句即可。
错误处理部分相对就更加复杂，同时也需要利用符号表的相关信息。&lt;/p&gt;
&lt;h3 id=&#34;符号表管理&#34;&gt;符号表管理
&lt;/h3&gt;&lt;p&gt;这个部分最难的地方应该在于结构的组织，我参考了往届优秀代码，
构建了Symbol相关的多个类，类型上大体分为变量与函数，
功能上还有全局管理的SymbolRecorder
以及每个Scope的SymbolTable。&lt;/p&gt;
&lt;p&gt;Symbol本身的属性在这个阶段相对简单，
我们主要关注名称，类型和初始值。&lt;/p&gt;
&lt;p&gt;SymbolRecorder需要着重管理的就是符号表的组织与切换，
并实现addSymbol方法。当然addSymbol还是要落实到
SymbolTable的addSymbol方法上。&lt;/p&gt;
&lt;p&gt;SymbolTable的作用就是管理符号的声明与查找，
主要的方法是addSymbol和getSymbol，其中
关于addSymbol的调用，就在VarDef与FuncDef中；
关于getSymbol的书写，需要注意scope规则。&lt;/p&gt;
&lt;h3 id=&#34;错误处理&#34;&gt;错误处理
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;break与continue&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一点我借鉴了学长的代码，在parse的过程中
完成了break与continue的处理。它相比于重新
visit一遍更加简单，因为parse过程中结构已知。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redefine与undefined&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个的区别在于，一个只能看当前scope，一个必须看完
所有嵌套scope。当前scope就直接看当前的符号表就可以，
嵌套的scope其实就是getSymbol的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数调用的错误处理主要是参数的数量与类型。
数量还比较好解决，类型的判断，尤其是实参就复杂的多。&lt;/p&gt;
&lt;p&gt;实参是Exp，要判断Exp是不是数组，就要求他必须是
单一的AddExp,单一的MulExp,单一的UnaryExp,
单一的PrimaryExp,单一的LVal，并且这个LVal
的symbol类型必须是数组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然这么简单的判断条件是基于课程组的文法简化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;return&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里涉及到两种错误，int函数最后一句不是return，以及
void函数存在return Exp&lt;/p&gt;
&lt;p&gt;int函数要想完备地判断是否能return还是比较复杂的，
所以题目加以限制，必须是最后一句，其实也就是
Block的BlockItem的最后一项。&lt;/p&gt;
&lt;p&gt;关于void函数的return，要详细地寻找到每一个return，
就不仅要寻找当前的Block的BlockItem中的ReturnStmt,
还要考虑其他Stmt。&lt;/p&gt;
&lt;p&gt;容易想到的是BlockStmt，容易被忽略的则是IfStmt与ForStmt。
他们两个也会嵌套Stmt，也需要进行寻找。&lt;/p&gt;
&lt;h2 id=&#34;中间代码生成&#34;&gt;中间代码生成
&lt;/h2&gt;&lt;p&gt;过了很久，我终于决定认真复盘这个最为复杂的单元。&lt;/p&gt;
&lt;p&gt;中间代码生成仍然属于前端的内容，他和语义分析一样，
都是与源语言文法、语义紧密相关的内容。&lt;/p&gt;
&lt;h3 id=&#34;二次扫描语法树简介&#34;&gt;二次扫描语法树——简介
&lt;/h3&gt;&lt;p&gt;我们中间代码生成的过程，就是要根据语法树的信息进一步提炼出抽象的中间代码逻辑。&lt;/p&gt;
&lt;p&gt;大家在做语义分析的时候也会注意到，符号表蕴含的信息只是一次小范围的总结，
并没有对控制流逻辑有所分析，所以我们AST的信息并没有提取足够，需要二次扫描，
在扫描的过程中顺势输出有结构的中间代码。&lt;/p&gt;
&lt;p&gt;不过要想知道怎么输出中间代码，我们必须先要深入了解LLVM IR。&lt;/p&gt;
&lt;p&gt;我们生成的LLVM IR必须是有一定结构的，我们将利用这个结构去递归完成toMips()的内容。&lt;/p&gt;
&lt;h3 id=&#34;llvm-ir体系构建&#34;&gt;LLVM-IR体系构建
&lt;/h3&gt;&lt;p&gt;这个结构的顶端就是 IrModule 。&lt;/p&gt;
&lt;p&gt;IrModule 包括以下四个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;functions：每个 FuncDef（包括Main）映射成 IrFunction，内部是 IrBasicBlock。&lt;/li&gt;
&lt;li&gt;globalValues：遇到全局/静态变量时要映射成 IrGlobalValue。&lt;/li&gt;
&lt;li&gt;stringConstantMap：printf 拆出来的字符串常量以 IrConstantString 形式缓存。&lt;/li&gt;
&lt;li&gt;declares：IO 内建函数声明（getint/putint/&amp;hellip;）也要预置在LLVM IR中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出 IR 时，IrModule.toString() 先打印声明、常量、全局变量，再打印所有函数体。&lt;/p&gt;
&lt;h4 id=&#34;value&#34;&gt;value
&lt;/h4&gt;&lt;p&gt;IrValue 是LLVM IR中最基础的概念，包括常量、变量、函数、乃至指令、基本块，都属于IrValue。
指令就是可以利用其他IrValue值的IrValue，他自己的值也可以被其他指令使用。
也就是说 IrValue 是一个统一接口，提供 getIrName()、getIrType()、toString()、toMips() 等通用行为。&lt;/p&gt;
&lt;h4 id=&#34;use&#34;&gt;use
&lt;/h4&gt;&lt;p&gt;在未来的优化部分，我们希望自己可以知道 IrValue 之间的关系，而不是只有代码的简单翻译，
因此我们要引入 IrUse 与 IrUser，强调 IrValue 之间的依赖关系。&lt;/p&gt;
&lt;p&gt;具体怎么构建use关系，还需阅读下文的Instr部分。&lt;/p&gt;
&lt;p&gt;每个 IrValue 都能用&lt;code&gt;Value + Type + Use&lt;/code&gt;这套语言描述。&lt;/p&gt;
&lt;h4 id=&#34;type&#34;&gt;type
&lt;/h4&gt;&lt;p&gt;IrType 是所有type的抽象基类，每个 IrValue 都要携带一个 IrType。&lt;/p&gt;
&lt;p&gt;核心的静态方法 convertType(originValue, targetType)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;转 i32，若源已是 i32 就直接返回，否则生成一条 ExtendInstr。&lt;/li&gt;
&lt;li&gt;转 i8：i32 -&amp;gt; TruncInstr，i8 保持不变，i1 -&amp;gt; ExtendInstr。&lt;/li&gt;
&lt;li&gt;转 i1：非 i1 一律截断。&lt;/li&gt;
&lt;li&gt;如果目标是数组，则递归转换其元素类型，保证数组初始化时的元素类型一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IrBaseType：内置的标量类型常量（VOID, INT1, INT8, INT32），toString() 对应 LLVM 文本 void/i1/i8/i32。&lt;/p&gt;
&lt;p&gt;IrPointerType：&lt;strong&gt;包装&lt;/strong&gt;任意目标类型，toString() 追加 *。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对数组/全局变量来说，我们用 IrPointerType 描述地址，这也是 GepInstr、LoadInstr 根据 getTargetType() 决定步长的依据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IrArrayType：记录数组长度和元素类型。 [N x i&amp;hellip;]。&lt;/p&gt;
&lt;p&gt;IrFunctionType：只强调返回类型（参数类型由 IrFunction 的 IrParameter 决定）。&lt;/p&gt;
&lt;p&gt;IrBasicBlockType：它没有信息量，就仅仅是BasicBlock，没有人需要getType来确认，toString() 为空字符串。&lt;/p&gt;
&lt;p&gt;但我们需要有一个 IrType，使得 IrBasicBlock 能继承 IrValue。&lt;/p&gt;
&lt;h4 id=&#34;具体的value&#34;&gt;具体的value
&lt;/h4&gt;&lt;h5 id=&#34;irfunction&#34;&gt;IrFunction
&lt;/h5&gt;&lt;p&gt;IrFunction 类型是 IrFunctionType，属于IrUser。&lt;/p&gt;
&lt;p&gt;包含 parameterList 保存 IrParameter，还包含 basicBlockList 是顺序化的 IrBasicBlock。&lt;/p&gt;
&lt;p&gt;toString() ：
&lt;code&gt;define dso_local type @name(param...) { basicBlock IR }&lt;/code&gt;。每个 IrBasicBlock 的 toString() 被拼接成函数体。&lt;/p&gt;
&lt;p&gt;isMainFunction() 检查名字是否为 @main，决定这个IrFunction是整个程序的入口。&lt;/p&gt;
&lt;h5 id=&#34;irparameter&#34;&gt;IrParameter
&lt;/h5&gt;&lt;p&gt;类型取决于源代码。&lt;/p&gt;
&lt;p&gt;独立出来的作用就是因为其toString是函数参数调用这一特殊形式。&lt;/p&gt;
&lt;p&gt;toString() ： &lt;code&gt;irType + &amp;quot; &amp;quot; + irName&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它也只是一个普通的变量，在自已的作用域里被use。&lt;/p&gt;
&lt;h5 id=&#34;irbasicblock&#34;&gt;IrBasicBlock
&lt;/h5&gt;&lt;p&gt;IrBasicBlock 类型是 IrBasicBlockType.BASIC_BLOCK。&lt;/p&gt;
&lt;p&gt;核心数据：instrList，块就是指令的合集。&lt;/p&gt;
&lt;p&gt;toString() 打印 b_x: + 指令的LLVM。&lt;/p&gt;
&lt;p&gt;基本块在代码优化意义重大，不过仅从代码生成角度考虑，他也只是一层无意义的包装。&lt;/p&gt;
&lt;h5 id=&#34;irloop&#34;&gt;IrLoop
&lt;/h5&gt;&lt;p&gt;他其实并不是IrValue。准确来说，他只是一个栈的结构体单元。&lt;/p&gt;
&lt;p&gt;它用来记录四个基本块：条件 condBlock、循环体 bodyBlock、步进 stepBlock、退出 followBlock。&lt;/p&gt;
&lt;p&gt;在面临多重循环时，栈式的结构可以帮助你更好地确定当前循环的各项信息。&lt;/p&gt;
&lt;h5 id=&#34;irconstant&#34;&gt;IrConstant
&lt;/h5&gt;&lt;p&gt;IrConstant 是编译时常量，包括以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IrConstantInt：最常见的标量常量，类型固定 i32。irName 就是数字文本。toString() 输出 i32 数字文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IrConstantArray：用于全局/常量数组初值。内部保存元素的类型，元素常量列表 valueList 与 arraySize。toString() 生成 [N x type] [elem0, elem1, &amp;hellip;] 或 zeroinitializer；若初始化列表不足，会自动补0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IrConstantString：封装字符串字面量。类型是 i8* 指向 [len x i8] 数组（len 包含 \0），存储时会把 \n 转义为 \0A。toString() 生成 @s = constant [len x i8] c&amp;quot;&amp;hellip;\00&amp;quot;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;instr&#34;&gt;Instr
&lt;/h4&gt;&lt;p&gt;最后一类 IrValue 就是我们最关键的 IrUser: Instr！&lt;/p&gt;
&lt;p&gt;每条指令既是可被引用的IrValue，又可引用其他值。&lt;/p&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术/逻辑：AluInstr（加减乘除/模）、CompareInstr、ExtendInstr/TruncInstr（类型转换）。它们通常产生新 SSA 值，toString() 形如 %v1 = add i32 %v0, 1。&lt;/li&gt;
&lt;li&gt;内存与地址：AllocateInstr（栈分配）、LoadInstr、StoreInstr、GepInstr（数组/指针偏移），MoveInstr 用于优化阶段的平行拷贝。&lt;/li&gt;
&lt;li&gt;控制流：JumpInstr（无条件跳转）、BranchInstr（条件跳转）、ReturnInstr。它们通常不定义新值，但会更新基本块的前驱/后继关系。&lt;/li&gt;
&lt;li&gt;调用：CallInstr 负责函数调用，收集参数列表并决定返回值类型。&lt;/li&gt;
&lt;li&gt;IO：instr/io 目录下的 PrintIntInstr、PrintCharInstr、PrintStrInstr、GetIntInstr，属于自动生成的declare。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;指令&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;LLVM IR&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;AllocateInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;%vx = alloca &amp;lt;element_type&amp;gt;（数组为 [N x i32]）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;AluInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;%vx = add/sub/mul/&amp;hellip; i32 lhs, rhs，操作符小写，始终声明 i32 操作数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;BranchInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;br i1 cond, label %true, label %false，cond 必须是 i1，块标签用 %&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;CallInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;call type @f(args…)，每个参数写成 type name，若函数有返回值则前缀 %vx =&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;CompareInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;%vx = icmp eq/ne/sgt/&amp;hellip; i32 lhs, rhs&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;ExtendInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;%vx = zext type name to type&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;GepInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;区分数组和普通指针：数组时打印 getelementptr inbounds [N x T], ptr_type ptr, i32 0, offset_type offset，否则为 getelementptr inbounds target_type, ptr_typr ptr, offset_type offset.  原因在于gep是计算基地址+索引*类型大小，支持多级索引，而数组第一级索引是0，第二级索引才是数组内偏移&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;JumpInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;br label %target&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;LoadInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;%vx = load target_type, ptr_type addr&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;ReturnInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;ret void 或 ret type value&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;StoreInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;store type value, ptr_type addr&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;TruncInstr&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;%vx = trunc type name to type，用于 i32→i1/i8 等截断。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;GetIntInstr等IO类&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;%vx = call i32 @getint()&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;特别注意：&lt;/p&gt;
&lt;p&gt;为了避免大量的重复内容，我们将addInstr与addUse这两个操作直接放置于构造函数内。&lt;/p&gt;
&lt;p&gt;指令本身不复杂，复杂的是下一部分，也就是怎么生成LLVM IR。&lt;/p&gt;
&lt;h3 id=&#34;二次遍历语法树实操&#34;&gt;二次遍历语法树——实操
&lt;/h3&gt;&lt;h4 id=&#34;架构构建者irbuilder&#34;&gt;架构构建者：IrBuilder
&lt;/h4&gt;&lt;p&gt;IrBuilder 是生成中间代码的核心部件之一，它持有全局单例 IrModule，并通过静态字段跟踪当前 IrFunction、IrBasicBlock，以及循环栈 loopStack，让 Visitor 在任何时刻都能把新指令、新块挂到正确的位置。&lt;/p&gt;
&lt;p&gt;模块管理：
IrBuilder需要负责组织各模块之间的关系，包括创建Function,Block,Instr,Global_Var以及addBlock,addInstr等操作。&lt;/p&gt;
&lt;p&gt;命名服务：newFuncName, newBasicBlockName, newGlobalVarName, newLocalVarName 统一生成 @f_name, b_#, @g_#, %v# 等符号。对局部命名，Builder 以函数为粒度维护计数器，保证每个函数的 %v0, %v1, &amp;hellip; 独立递增。&lt;/p&gt;
&lt;h4 id=&#34;架构填充者visitor&#34;&gt;架构填充者：Visitor
&lt;/h4&gt;&lt;p&gt;我们终于谈到了中间代码生成的核心，也就是真正二次遍历语法树的过程。&lt;/p&gt;
&lt;p&gt;Visitor.generateIr 是中端的入口，持有完整 CompUnit，依次对全局 Decl、普通 FuncDef、MainFuncDef 调用专门的 Visitor。&lt;/p&gt;
&lt;h5 id=&#34;decl&#34;&gt;Decl
&lt;/h5&gt;&lt;p&gt;VisitorDecl：处理所有的decl语句，区分好全局、局部static与局部，以及数组与标量。&lt;/p&gt;
&lt;p&gt;我们只依赖 VarSymbol 中的语义信息（作用域、类型、是否数组、初值列表等）就足以完成翻译。&lt;/p&gt;
&lt;p&gt;generateDeclIr(Decl) 先区分常量/变量，逐个 ConstDef/VarDef 处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局/局部静态变量：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;无论是否const，VarSymbol.isGlobal() 或 isStatic() 时使用 IrBuilder.getNewIrGlobalValue(new IrPointerType(type), initConstant)。初始化的值通过symbol构造 IrConstantInt 或 IrConstantArray，数组要自动补零。生成的 IrGlobalValue 存回 symbol.setIrValue，后续访值都指向这个全局指针。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;局部变量：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;统一先 new AllocateInstr(type) 在栈上开空间，再视情况写初值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非数组：若提供初值（ConstDef 一定有，VarDef 可能有），就 new StoreInstr(value, alloc)；常量的初值来自符号表中提前计算好的 initValueList。&lt;/li&gt;
&lt;li&gt;数组：遍历初值表达式列表，对每个元素 VisitorExp.generateExpIr → convertType → GepInstr → StoreInstr，未提供的尾部元素由 ConstDef 分支提前填 0。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;常量的局部分支和变量一样，区别在于 VarSymbol 里 initValueList 已经静态求值完毕，而变量不能保证第一遍扫描的时候就已求值，而是用 VisitorExp.generateExpIr 来生成现场计算的表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;funcdef&#34;&gt;FuncDef
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;Def&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在遇到函数节点时利用 IrBuilder 创建 IrFunction，把形参列表映射成 IrParameter，再借助局部 Alloc+Store 把参数写入栈。随后 VisitorBlock。&lt;/p&gt;
&lt;p&gt;需要注意作用域的改变时机：在解析形参时进入子作用域，Block生成完毕后退出子作用域。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Block&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;VisitorBlock 遍历 BlockItem。遇到 Decl 转交 VisitorDecl，遇到 Stmt 转交 VisitorStmt。&lt;/p&gt;
&lt;h5 id=&#34;stmt&#34;&gt;Stmt
&lt;/h5&gt;&lt;p&gt;VisitorStmt 以语句类型为分发点：IF/FOR 创建新的基本块并通过 IrBuilder 管理跳转；ASSIGN 找到左值地址（调用 VisitorLVal）并生成 StoreInstr；PRINTF 先把字符串拆成常量块和占位符，再插入对应的 IO 指令；RETURN 根据函数返回类型自动补 0。循环语句通过 IrLoop 堆栈记录 break/continue 的目标块。&lt;/p&gt;
&lt;p&gt;VisitorStmt 根据 StmtType 分别处理不同类型的语句。&lt;/p&gt;
&lt;ol start=&#34;0&#34;&gt;
&lt;li&gt;
&lt;p&gt;LVal：&lt;/p&gt;
&lt;p&gt;后面会用到，这里先讲清楚：
VisitorLVal.generateLValIr(lval, &lt;strong&gt;false&lt;/strong&gt;) 给左值对象的值，&lt;/p&gt;
&lt;p&gt;VisitorLVal.generateLValIr(lval, &lt;strong&gt;true&lt;/strong&gt;) 给左值对象的地址。&lt;/p&gt;
&lt;p&gt;具体而言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;返回地址时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非数组变量直接返回符号表记录的 IrValue（通常是 AllocateInstr / IrGlobalValue），即地址。&lt;/li&gt;
&lt;li&gt;针对数组或指针：先取符号的 IrValue。如果这是一个指向数组的指针(作为 IrPointerType，其 target 还是指针)，说明它需要先 LoadInstr 读出真实首地址；然后根据下标生成 GepInstr(pointer, index)，当然要先生成算出index的IR。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接取值时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若符号是标量，直接 new LoadInstr(symbol.getIrValue()) 取内存中的内容。&lt;/li&gt;
&lt;li&gt;数组情况更复杂：
首先特别注意：若 pointerType.getTargetType() 仍是 IrPointerType，说明 symbol.getIrValue() 存的是指向指针的地址，必须先 LoadInstr 取到真正数组指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拿到数组指针之后就继续找值：
- 如果没有下标（size == null），意味着把整个数组当作指针使用，返回 new GepInstr(pointer, new IrConstantInt(0))，相当于数组首地址。
- 如果有下标，就先算index，然后 GepInstr(pointer, index) 计算元素地址，再 LoadInstr 读取元素值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;block：&lt;/p&gt;
&lt;p&gt;进入子作用域，VisitBlock，离开子作用域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exp与assign：&lt;/p&gt;
&lt;p&gt;generateExpStmtIr 纯调用 VisitorExp.generateExpIr，如果没有表达式就直接返回；        &lt;br&gt;
generateAssignStmtIr 先用 VisitorLVal.generateLValIr(lval, true) &lt;strong&gt;拿到地址&lt;/strong&gt;，再把翻译右侧表达式，&lt;strong&gt;并转成目标类型&lt;/strong&gt;，最终 &lt;strong&gt;new StoreInstr(value, address)&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;printf：&lt;/p&gt;
&lt;p&gt;手动解析格式串：遇到 %d/%c 时调用 &lt;strong&gt;VisitorExp&lt;/strong&gt; 获取实参，转换类型后 PrintIntInstr/PrintCharInstr; 普通字符串则直接用 IrBuilder.getNewIrConstantString + PrintStrInstr。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;先建 ifBlock（真分支），若有 else 再建 elseBlock.&lt;/p&gt;
&lt;p&gt;VisitorExp.generateCondIr(cond, ifBlock, elseBlock/followBlock) 生成条件跳转。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;特别注意！ cond和exp的不同点在于cond的解析为了处理短路求值，是&lt;strong&gt;自带跳转功能&lt;/strong&gt;的！&lt;/p&gt;
&lt;p&gt;因此我们看似只是生成条件的IR，其实已经把根据条件进行跳转的指令也涵盖了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来就分别生成if与else本身 &lt;strong&gt;stmt&lt;/strong&gt; 的代码，注意结尾都要跳转到 follow 块！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;for&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;建四个块：cond, body, step, follow，并把它们打包成 IrLoop 压入 IrBuilder.loopStack。 多重循环一定要成套记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;入栈 IrLoop&lt;/strong&gt;:
&lt;code&gt;IrBuilder.LoopStackPush(new IrLoop(condBlock, bodyBlock, stepBlock, followBlock));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先是起点：处理 init 这个 &lt;strong&gt;ForStmt&lt;/strong&gt;，并跳到 &lt;strong&gt;condBlock&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进入条件块：直接生成cond的IR（自带跳转）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意 cond块的跳转指令是cond生成的，而不是人为添加的！如果不存在cond，该块将无跳转语句造成&lt;code&gt;OCE&lt;/code&gt;。因此最后需要&lt;strong&gt;一轮check&lt;/strong&gt;或者在这里&lt;strong&gt;强制手动多添加一个无条件jump&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入body块：直接翻译 body 这个 &lt;strong&gt;Stmt&lt;/strong&gt; ，然后跳到 &lt;strong&gt;stepBlock&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进入stepBlock：处理 step 这个 &lt;strong&gt;ForStmt&lt;/strong&gt;，并跳到 &lt;strong&gt;condBlock&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出栈 IrLoop&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进入 &lt;strong&gt;followBlock&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 ForStmt： 其实就是多个 assign 语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;break / continue:&lt;/p&gt;
&lt;p&gt;直接查看当前所在的循环体 IrBuilder.LoopStackPeek()，&lt;strong&gt;break 跳到 followBlock，continue 跳到 stepBlock&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;return：&lt;/p&gt;
&lt;p&gt;generateReturnStmtIr 若语句带表达式则生成该表达式，否则对 int 函数&lt;strong&gt;默认补 0&lt;/strong&gt;。返回值统一&lt;strong&gt;转到函数返回类型&lt;/strong&gt;，然后 new ReturnInstr(value or null)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;exp&#34;&gt;Exp
&lt;/h5&gt;&lt;p&gt;Exp 就是一个 AddExp。&lt;/p&gt;
&lt;p&gt;结点提供子表达式与连接符号，我们按子表达式列表迭代，逐个拼接 AluInstr。&lt;/p&gt;
&lt;p&gt;要注意在每次二元运算前，都把操作数提升到 i32，保证算术统一在 32 位整型上进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新的 AluInstr 既作为指令插入，也作为下一轮的左操作数。这样实现了 AST → SSA 的顺序化运算。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一直迭代到的最底层：一元表达式，分为三种。&lt;/p&gt;
&lt;p&gt;Primary（括号、数字、左值）：括号就调用 generateExpIr，数字就构造 IrConstantInt，左值调用 VisitorLVal.generateLValIr(lval, false) 获取值。&lt;/p&gt;
&lt;p&gt;Ident 函数调用：&lt;strong&gt;getint（直接返回 GetIntInstr）&lt;/strong&gt;，其他函数从 SymbolRecorder 取 FuncSymbol，把实参列表递归成 IrValue，最后 new &lt;strong&gt;CallInstr&lt;/strong&gt;(irFunction, paramList)。&lt;/p&gt;
&lt;p&gt;一元运算符：&lt;code&gt;+&lt;/code&gt; 返回原值；&lt;code&gt;-&lt;/code&gt; 构造 0 - value 的 AluInstr；&lt;code&gt;!&lt;/code&gt; 则先转 i32，再生成 CompareInstr(&amp;quot;==&amp;quot;, 0, value)，最后 &lt;code&gt;ExtendInstr 把布尔结果扩展成 i32&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;布尔/条件表达式：&lt;/p&gt;
&lt;p&gt;左值加载：PrimaryExp 中的 LVal 调用 VisitorLVal.generateLValIr(lval, false)，这会根据是否数组、是否指针返回 LoadInstr 或 GEP+Load 的组合。所以 VisitorExp 不直接关心符号表，只处理表达式结构。&lt;/p&gt;
&lt;h5 id=&#34;cond&#34;&gt;Cond
&lt;/h5&gt;&lt;p&gt;generateCondIr 是 if、for 条件代码的入口。它把 Cond 降成 LOrExp，以 trueBlock 和 falseBlock 为目标生成短路控制流。&lt;/p&gt;
&lt;p&gt;generateLOrExpIr 为下一个 || 子表达式&lt;strong&gt;创建一个中间块&lt;/strong&gt;，在每个块里调用 generateLAndExpIr，&lt;strong&gt;得到的值通过 BranchInstr 控制跳转&lt;/strong&gt;；若当前子表达式为真，&lt;strong&gt;立刻跳&lt;/strong&gt;trueBlock；&lt;strong&gt;否则落到&lt;/strong&gt;下一个 LAnd 块，实现短路。&lt;/p&gt;
&lt;p&gt;generateLAndExpIr 类似，不过 &amp;amp;&amp;amp; 的短路条件是&lt;strong&gt;中途为假就跳 falseBlock&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后一个子表达式产生的 BranchInstr 直接指向 trueBlock/falseBlock。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EqExp、RelExp &lt;strong&gt;链式构建&lt;/strong&gt; CompareInstr，因为 a == b == c 这种语法递归展开后需要&lt;strong&gt;把前一次比较的结果转换为 i32&lt;/strong&gt; 再与下一项比较。generateEqExpIr 最后还&lt;strong&gt;把链式结果与 0 再比较&lt;/strong&gt;一次，统一转换成 i1。&lt;/p&gt;
&lt;h4 id=&#34;构建的画笔tostring&#34;&gt;构建的画笔：toString()
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先是IrModule本身的toString(),作为顶层架构，输出 IR 时，IrModule.toString() 先打印声明、常量、全局变量，再打印所有函数体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数体的toString()：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;define dso_local type() irName(IrParameter.toString()) {IrBasicBlock.toString()\n}&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;参数的toString：&lt;code&gt;类型+名字&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本块的toString：&lt;code&gt;irName(也就是IrBuilder给他生成的那个b_#): Instr.toString()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Instr.toString: 我们在介绍Instr的时候已经说过了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;目标代码生成&#34;&gt;目标代码生成
&lt;/h2&gt;&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;代码优化&#34;&gt;代码优化
&lt;/h2&gt;&lt;p&gt;代码优化分为体系结构无关的中间代码优化与体系结构相关的目标代码优化。&lt;/p&gt;
&lt;p&gt;而中间代码优化才是真正名副其实的中端。&lt;/p&gt;
&lt;h3 id=&#34;不可达代码删除&#34;&gt;不可达代码删除
&lt;/h3&gt;&lt;p&gt;可达这句话归因于跳转语句，因此我们先把一些没用的跳转语句删掉，以便更好地删除不可达代码。&lt;/p&gt;
&lt;p&gt;接下来，我们删除不可达基本块。&lt;/p&gt;
&lt;p&gt;因基本块的最后一句一定是return/branch/jump，所以直接根据这个来判断他所能到达的地方。&lt;/p&gt;
&lt;p&gt;我们暂时默认所有function本身的entry_block是可达的，仅删除
function内部的不可达块，这个用DFS很容易解决。&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
