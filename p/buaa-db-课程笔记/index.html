<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="狂补16节回放所著">
<title>BUAA DB 课程笔记</title>

<link rel='canonical' href='https://demiurge-zby.github.io/p/buaa-db-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/'>

<link rel="stylesheet" href="/scss/style.min.74099dcf6f27d3a5b29d594a0d43776277ceef5b42ab33f209f7ca94e95b2ab1.css"><meta property='og:title' content="BUAA DB 课程笔记">
<meta property='og:description' content="狂补16节回放所著">
<meta property='og:url' content='https://demiurge-zby.github.io/p/buaa-db-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/'>
<meta property='og:site_name' content='Demiurge'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2026-01-07T12:15:30&#43;08:00'/><meta property='article:modified_time' content='2026-01-07T12:15:30&#43;08:00'/><meta property='og:image' content='https://demiurge-zby.github.io/p/buaa-db-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ava.png' />
<meta name="twitter:title" content="BUAA DB 课程笔记">
<meta name="twitter:description" content="狂补16节回放所著"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://demiurge-zby.github.io/p/buaa-db-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ava.png' />
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu2966618033499034663.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">💖</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Demiurge</a></h1>
            <h2 class="site-description">Easy Life</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#数据库概论">数据库概论</a>
      <ol>
        <li><a href="#数据库">数据库</a></li>
        <li><a href="#数据模型">数据模型</a>
          <ol>
            <li><a href="#概念数据模型">概念数据模型</a></li>
            <li><a href="#逻辑数据模型">逻辑数据模型</a></li>
          </ol>
        </li>
        <li><a href="#数据库系统模式">数据库系统模式</a></li>
      </ol>
    </li>
    <li><a href="#关系数据库">关系数据库</a>
      <ol>
        <li><a href="#数据结构">数据结构</a>
          <ol>
            <li><a href="#关系模型对关系的限定和扩充">关系模型对关系的限定和扩充</a></li>
            <li><a href="#关系的性质">关系的性质</a></li>
            <li><a href="#关系模式">关系模式</a></li>
            <li><a href="#关系数据库-1">关系数据库</a></li>
          </ol>
        </li>
        <li><a href="#完整性约束">完整性约束</a>
          <ol>
            <li><a href="#实体完整性">实体完整性</a></li>
            <li><a href="#参照完整性">参照完整性</a></li>
            <li><a href="#用户定义的完整性">用户定义的完整性</a></li>
          </ol>
        </li>
        <li><a href="#数据操作关系代数">数据操作——关系代数</a>
          <ol>
            <li><a href="#基本运算">基本运算</a></li>
            <li><a href="#并运算">并运算</a></li>
            <li><a href="#差运算">差运算</a></li>
            <li><a href="#交运算">交运算</a></li>
            <li><a href="#广义笛卡尔积">广义笛卡尔积</a></li>
            <li><a href="#选择运算">选择运算</a></li>
            <li><a href="#投影运算">投影运算</a></li>
            <li><a href="#连接运算">连接运算</a></li>
            <li><a href="#自然连接">自然连接</a></li>
            <li><a href="#复合连接">复合连接</a></li>
            <li><a href="#半连接">半连接</a></li>
            <li><a href="#外连接">外连接</a></li>
            <li><a href="#除运算">除运算</a></li>
            <li><a href="#关系代数练习">关系代数练习</a></li>
          </ol>
        </li>
        <li><a href="#数据操作sql语言">数据操作——SQL语言</a>
          <ol>
            <li><a href="#特点">特点</a></li>
            <li><a href="#数据查询">数据查询</a>
              <ol>
                <li><a href="#alldistinct">ALL|DISTINCT</a></li>
                <li><a href="#目标表达式">目标表达式</a></li>
                <li><a href="#条件表达式">条件表达式</a></li>
                <li><a href="#order-by">Order By</a></li>
                <li><a href="#group-by">Group By</a></li>
                <li><a href="#多表查询">多表查询</a></li>
                <li><a href="#嵌套查询">嵌套查询</a></li>
                <li><a href="#集合查询">集合查询</a></li>
              </ol>
            </li>
            <li><a href="#数据更新">数据更新</a>
              <ol>
                <li><a href="#insert----into">Insert &ndash; Into</a></li>
                <li><a href="#update----set">Update &ndash; Set</a></li>
                <li><a href="#delete">Delete</a></li>
              </ol>
            </li>
            <li><a href="#数据定义">数据定义</a>
              <ol>
                <li><a href="#基本表定义删除修改">基本表——定义、删除、修改</a>
                  <ol>
                    <li><a href="#create">create</a></li>
                    <li><a href="#alter">alter</a></li>
                    <li><a href="#drop">drop</a></li>
                  </ol>
                </li>
                <li><a href="#索引定义删除">索引——定义、删除</a></li>
                <li><a href="#视图定义删除">视图——定义、删除</a>
                  <ol>
                    <li><a href="#视图消解">视图消解</a></li>
                    <li><a href="#视图更新">视图更新</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#数据库安全性与完整性">数据库安全性与完整性</a>
      <ol>
        <li><a href="#安全性">安全性</a>
          <ol>
            <li><a href="#安全威胁">安全威胁</a></li>
            <li><a href="#定义">定义</a></li>
            <li><a href="#安全控制">安全控制</a>
              <ol>
                <li><a href="#外部安全控制">外部安全控制</a></li>
                <li><a href="#内部安全控制">内部安全控制</a>
                  <ol>
                    <li><a href="#用户标识与鉴别">用户标识与鉴别</a></li>
                    <li><a href="#存取控制">存取控制</a></li>
                    <li><a href="#审计">审计</a></li>
                    <li><a href="#数据加密">数据加密</a></li>
                  </ol>
                </li>
              </ol>
            </li>
            <li><a href="#统计数据库安全性">统计数据库安全性</a></li>
          </ol>
        </li>
        <li><a href="#完整性">完整性</a>
          <ol>
            <li><a href="#完整性约束条件">完整性约束条件</a>
              <ol>
                <li><a href="#静态约束">静态约束</a>
                  <ol>
                    <li><a href="#隐含约束">隐含约束</a></li>
                    <li><a href="#显示完整性约束">显示完整性约束</a></li>
                  </ol>
                </li>
                <li><a href="#动态约束">动态约束</a></li>
              </ol>
            </li>
            <li><a href="#完整性控制机制">完整性控制机制</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#关系数据理论">关系数据理论</a>
      <ol>
        <li><a href="#函数依赖">函数依赖</a>
          <ol>
            <li><a href="#分类">分类</a>
              <ol>
                <li><a href="#平凡函数依赖与非平凡函数依赖">平凡函数依赖与非平凡函数依赖</a></li>
                <li><a href="#完全函数依赖与部分函数依赖">完全函数依赖与部分函数依赖</a></li>
                <li><a href="#传递函数依赖">传递函数依赖</a></li>
              </ol>
            </li>
            <li><a href="#码的规范定义">码的规范定义</a></li>
          </ol>
        </li>
        <li><a href="#范式">范式</a>
          <ol>
            <li><a href="#1nf">1NF</a></li>
            <li><a href="#2nf">2NF</a></li>
            <li><a href="#3nf">3NF</a></li>
            <li><a href="#bcnf">BCNF</a></li>
          </ol>
        </li>
        <li><a href="#数据依赖的公理系统">数据依赖的公理系统</a>
          <ol>
            <li><a href="#armstrong公理">Armstrong公理</a></li>
            <li><a href="#求属性集的闭包">求属性集的闭包</a></li>
            <li><a href="#更便捷地求码">更便捷地求码</a></li>
            <li><a href="#最小依赖集">最小依赖集</a></li>
          </ol>
        </li>
        <li><a href="#模式分解">模式分解</a>
          <ol>
            <li><a href="#判别模式分解的无损连接性">判别模式分解的无损连接性</a>
              <ol>
                <li><a href="#填表法">填表法</a></li>
                <li><a href="#定理法">定理法</a></li>
              </ol>
            </li>
            <li><a href="#模式分解中函数依赖的保持">模式分解中函数依赖的保持</a></li>
            <li><a href="#常用的模式分解算法">常用的模式分解算法</a>
              <ol>
                <li><a href="#达到3nf且保持函数依赖的分解算法">达到3NF且保持函数依赖的分解算法</a></li>
                <li><a href="#达到3nf且同时保持无损连接与函数依赖的分解算法">达到3NF且同时保持无损连接与函数依赖的分解算法</a></li>
                <li><a href="#达到bcnf且保持无损连接的分解算法">达到BCNF且保持无损连接的分解算法</a></li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#数据库设计">数据库设计</a>
      <ol>
        <li><a href="#数据库的生命周期">数据库的生命周期</a>
          <ol>
            <li><a href="#需求分析">需求分析</a></li>
            <li><a href="#概念结构设计">概念结构设计</a>
              <ol>
                <li><a href="#局部概念结构">局部概念结构</a></li>
                <li><a href="#全局概念模式合成">全局概念模式合成</a></li>
                <li><a href="#事务设计">事务设计</a></li>
              </ol>
            </li>
            <li><a href="#逻辑结构设计">逻辑结构设计</a>
              <ol>
                <li><a href="#形成初始关系数据库模式">形成初始关系数据库模式</a>
                  <ol>
                    <li><a href="#实体型的转换">实体型的转换</a></li>
                    <li><a href="#实体间联系的转换">实体间联系的转换</a></li>
                  </ol>
                </li>
                <li><a href="#关系模式的规范化">关系模式的规范化</a></li>
                <li><a href="#关系模式的优化">关系模式的优化</a>
                  <ol>
                    <li><a href="#水平分解-减少行数">水平分解 减少行数</a></li>
                    <li><a href="#垂直分解-减少列数">垂直分解 减少列数</a></li>
                    <li><a href="#逆规范化--合并关系">逆规范化  合并关系</a></li>
                  </ol>
                </li>
                <li><a href="#设计子模式">设计子模式</a></li>
                <li><a href="#数据库物理设计">数据库物理设计</a>
                  <ol>
                    <li><a href="#数据库的存取方法">数据库的存取方法</a></li>
                    <li><a href="#数据库的存储结构">数据库的存储结构</a></li>
                  </ol>
                </li>
                <li><a href="#数据库的实施">数据库的实施</a></li>
                <li><a href="#数据库的运行和维护">数据库的运行和维护</a></li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#查询优化">查询优化</a>
      <ol>
        <li><a href="#基本运算的实现">基本运算的实现</a>
          <ol>
            <li><a href="#选取">选取</a></li>
            <li><a href="#连接">连接</a></li>
          </ol>
        </li>
        <li><a href="#查询代价的度量">查询代价的度量</a></li>
        <li><a href="#关系代数等价变换">关系代数等价变换</a></li>
        <li><a href="#查询优化的一般准则">查询优化的一般准则</a></li>
      </ol>
    </li>
    <li><a href="#数据库恢复">数据库恢复</a>
      <ol>
        <li><a href="#事务">事务</a>
          <ol>
            <li><a href="#事务的基本流程">事务的基本流程</a></li>
            <li><a href="#事务的特性-acid">事务的特性 ACID</a></li>
          </ol>
        </li>
        <li><a href="#数据库恢复子系统">数据库恢复子系统</a></li>
        <li><a href="#数据库故障">数据库故障</a></li>
        <li><a href="#恢复技术">恢复技术</a>
          <ol>
            <li><a href="#建立冗余">建立冗余</a>
              <ol>
                <li><a href="#数据转储数据冗余">数据转储——数据冗余</a>
                  <ol>
                    <li><a href="#静态转储冷备份">静态转储——冷备份</a></li>
                    <li><a href="#动态转储热备份">动态转储——热备份</a></li>
                  </ol>
                </li>
                <li><a href="#登记日志文件操作冗余">登记日志文件——操作冗余</a></li>
              </ol>
            </li>
            <li><a href="#恢复策略">恢复策略</a>
              <ol>
                <li><a href="#事务故障">事务故障</a></li>
                <li><a href="#系统故障">系统故障</a></li>
                <li><a href="#介质故障">介质故障</a></li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#具有检查点的恢复技术">具有检查点的恢复技术</a>
          <ol>
            <li><a href="#检查点记录操作">检查点记录操作</a></li>
            <li><a href="#恢复">恢复</a></li>
          </ol>
        </li>
        <li><a href="#数据库镜像">数据库镜像</a></li>
      </ol>
    </li>
    <li><a href="#并发控制">并发控制</a>
      <ol>
        <li><a href="#优势">优势</a></li>
        <li><a href="#问题">问题</a>
          <ol>
            <li><a href="#丢失修改">丢失修改</a></li>
            <li><a href="#不可重复读">不可重复读</a></li>
            <li><a href="#读脏数据">读“脏”数据</a></li>
          </ol>
        </li>
        <li><a href="#并发控制措施封锁">并发控制措施——封锁</a>
          <ol>
            <li><a href="#封锁的类型">封锁的类型</a></li>
            <li><a href="#封锁协议">封锁协议</a>
              <ol>
                <li><a href="#一级封锁协议read-uncommitted">一级封锁协议（Read Uncommitted）</a></li>
                <li><a href="#二级封锁协议read-committed">二级封锁协议（Read Committed）</a></li>
                <li><a href="#三级封锁协议repeatable-read">三级封锁协议（Repeatable Read）</a></li>
              </ol>
            </li>
            <li><a href="#封锁的危害">封锁的危害</a>
              <ol>
                <li><a href="#封锁级别">封锁级别</a></li>
                <li><a href="#活锁与死锁">活锁与死锁</a></li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#死锁的解决">死锁的解决</a>
          <ol>
            <li><a href="#预防死锁">预防死锁</a>
              <ol>
                <li><a href="#一次封锁法">一次封锁法</a></li>
                <li><a href="#顺序封锁法">顺序封锁法</a></li>
              </ol>
            </li>
            <li><a href="#死锁检测与恢复">死锁检测与恢复</a>
              <ol>
                <li><a href="#死锁检测">死锁检测</a>
                  <ol>
                    <li><a href="#超时法">超时法</a></li>
                    <li><a href="#等待图法">等待图法</a></li>
                  </ol>
                </li>
                <li><a href="#死锁恢复">死锁恢复</a></li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#事务的调度与可串行性">事务的调度与可串行性</a>
          <ol>
            <li><a href="#调度的正确性">调度的正确性</a></li>
            <li><a href="#冲突可串行化调度">冲突可串行化调度</a></li>
            <li><a href="#两段锁协议">两段锁协议</a></li>
            <li><a href="#多粒度封锁">多粒度封锁</a>
              <ol>
                <li><a href="#多粒度树">多粒度树</a></li>
                <li><a href="#意向锁">意向锁</a></li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#数据库存储">数据库存储</a>
      <ol>
        <li><a href="#存储介质">存储介质</a>
          <ol>
            <li><a href="#raid">RAID</a></li>
          </ol>
        </li>
        <li><a href="#缓冲区调度">缓冲区调度</a></li>
        <li><a href="#数据库文件结构">数据库文件结构</a>
          <ol>
            <li><a href="#记录文件">记录文件</a></li>
            <li><a href="#记录文件的组织">记录文件的组织</a>
              <ol>
                <li><a href="#顺序文件组织">顺序文件组织</a></li>
              </ol>
            </li>
            <li><a href="#关系数据库的文件选择">关系数据库的文件选择</a></li>
            <li><a href="#数据字典">数据字典</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#索引">索引</a>
      <ol>
        <li><a href="#基本概念">基本概念</a>
          <ol>
            <li><a href="#主索引">主索引</a>
              <ol>
                <li><a href="#多级索引">多级索引</a></li>
              </ol>
            </li>
            <li><a href="#辅助索引">辅助索引</a></li>
          </ol>
        </li>
        <li><a href="#有序索引">有序索引</a>
          <ol>
            <li><a href="#稠密索引文件">稠密索引文件</a></li>
            <li><a href="#稀疏索引文件">稀疏索引文件</a></li>
          </ol>
        </li>
        <li><a href="#b树索引文件">B+树索引文件</a></li>
        <li><a href="#hash数据索引">Hash数据索引</a></li>
        <li><a href="#总结">总结</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/buaa-db-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">
                <img src="/p/buaa-db-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ava_hu298496458010257943.png"
                        srcset="/p/buaa-db-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ava_hu298496458010257943.png 800w, /p/buaa-db-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/ava_hu7085937519096569705.png 1600w"
                        width="800" 
                        height="334" 
                        loading="lazy"
                        alt="Featured image of post BUAA DB 课程笔记" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/db/" style="background-color: #3585ac; color: #fff;">
                DB
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/buaa-db-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">BUAA DB 课程笔记</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            狂补16节回放所著
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2026-01-07</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 56 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="数据库概论">数据库概论
</h2><h3 id="数据库">数据库
</h3><p><strong>所谓数据库是长期储存在计算机内的、有组织的、可共享的数据集合。<strong>数据库中的数据按一定的</strong>数据模型</strong>组织、存储和描述，由<strong>DBMS</strong>统一管理，多用户共享。</p>
<p>数据管理的三个阶段：人工管理阶段、文件系统阶段、数据库系统阶段。</p>
<p>数据库系统的特点：<strong>面向全组织的结构化</strong>，<strong>数据集成与共享</strong>、易扩充性、<strong>可控冗余度</strong>，<strong>数据独立性好</strong>（包括逻辑独立性与物理独立性），<strong>统一的控制机制</strong>（安全性与完整性、并发控制、数据库恢复）。</p>
<p>数据库系统与文件系统的本质差别：<strong>面向全组织的结构化</strong>。</p>
<p>数据库系统的组成部分：<strong>数据库</strong>、<strong>软件</strong>（DBMS,支持DBMS的OS,高级语言及其Compiler,应用开发工具与应用系统）、<strong>硬件</strong>（内存\存取设备\IO）、<strong>用户</strong>（DBA、偶然用户、&hellip;）</p>
<p>DBA：数据库管理员，决定和监控数据库</p>
<p>DBMS：数据库定义功能（提供DDL，数据描述语言）、数据存取功能（提供DML，数据操作语言，分为宿主型与自含型）、数据库运行管理、数据组织 存储与管理、数据库的建立和维护功能</p>
<h3 id="数据模型">数据模型
</h3><p>分类：概念数据模型、逻辑数据模型、物理数据模型</p>
<p>组成：数据结构、数据操作、数据的约束条件</p>
<p>数据结构的组成：数据本身、数据之间的联系</p>
<h4 id="概念数据模型">概念数据模型
</h4><p>实体（值）、属性、域、实体型、实体集</p>
<p>能唯一标识实体的属性集：码</p>
<p>联系的种类：1对1，1对多，多对多</p>
<p>E-R图</p>
<h4 id="逻辑数据模型">逻辑数据模型
</h4><p>层次模型：树结构，结点是数据集合，边是多个指针，不可表达多对多，对用户要求较高。</p>
<p>网状模型：有向图，结点是数据集合，边是多个指针，支持多对多。表达能力强。易用性差。</p>
<p>关系模型：二维表。将数据本身与数据之间的联系统一形式。联系的形式：将两个实体的码（唯一标识）放在同一个表项中。建立在严格的数学概念基础上（集合论）。简单直观。数据独立性、安全保密性强。性能相对更差。</p>
<p>面向对象模型：增添方法，以实现对属性值的操作。</p>
<h3 id="数据库系统模式">数据库系统模式
</h3><p>模式：数据的结构与联系的描述</p>
<p>型是对一类属性结构和属性的说明，值是型的具体赋值</p>
<p>模式也有其对应的实例。</p>
<p>数据库系统<strong>三级模式与两级映像</strong></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231160929600.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231160929600"
	
	
></p>
<p>内模式：存储模式</p>
<p>模式：逻辑模式（所有数据的逻辑结构与属性）</p>
<p>外模式：模式的子集，是用户的数据视图（为用户定义外模式）</p>
<p>意义：某模式改变时，<strong>DBMS自动调整映象</strong>，使得其他模式无需改变。</p>
<p><strong>数据独立性</strong>：<strong>逻辑独立性</strong>与<strong>物理独立性</strong></p>
<p>逻辑独立性：外模式/模式映象，模式改变，外模式不变</p>
<p>数据独立性：模式/内模式映象，内模式改变，模式不变</p>
<h2 id="关系数据库">关系数据库
</h2><p>关系模型的三个组成要素：</p>
<p><strong>数据结构</strong>：关系</p>
<blockquote>
<p>实体型和联系用同样的二维表结构表示。</p>
<p>联系转为表时：可以单独成表，在某些条件下可以与相连的实体合并</p>
</blockquote>
<p><strong>数据操作</strong>：关系代数、SQL、<del>关系演算（不学）</del></p>
<blockquote>
<p>关系操作的特点：1.面向<strong>集合操作</strong>，操作的<strong>对象与结果</strong>都是<strong>集合</strong> 2.非过程化，只需给出做什么，无需给出怎么做</p>
</blockquote>
<p><strong>数据的约束条件</strong>：实体完整性约束、参照完整性约束、用户定义完整性约束</p>
<h3 id="数据结构">数据结构
</h3><p>域：某属性的值的集合（值域）</p>
<p>域之间做<strong>笛卡尔积</strong>得到一张大表，表中的一行称为n-元组或<strong>元组</strong>，元组的每一个值叫做一个<strong>分量</strong>。</p>
<p>笛卡尔积的基数为<strong>每个域的基数的积</strong>。</p>
<blockquote>
<p>D1(1,2) ×D2 (3,4) &mdash;- (1,3) (1,4) (2,3) (2,4)</p>
</blockquote>
<p>笛卡尔积的<strong>子集</strong>叫做<strong>关系</strong>，写作<strong>R(D1,D2,&hellip;,Dn)</strong>,为n元关系，n为关系的度/目。</p>
<p>由于域有可能相同，为了区分不同的域，为每一列起名，称为<strong>属性</strong>。n元关系即有n个属性。</p>
<h4 id="关系模型对关系的限定和扩充">关系模型对关系的限定和扩充
</h4><p>限定：关系必须是<strong>有限的</strong>、<strong>有意义的</strong></p>
<p>扩充：利用属性名的唯一性，<strong>取消关系的有序性</strong>。</p>
<blockquote>
<p>同一关系在不同的属性名顺序下可有不同的表达顺序</p>
</blockquote>
<h4 id="关系的性质">关系的性质
</h4><p>1.列是同质的：每一列的分量来自同一域，有同样类型</p>
<p>2.每列属性有不同的属性名，但可出自同一域</p>
<p>3.列的顺序与行的顺序都无关紧要 （这个算两点性质）</p>
<p>4.集合内任意两个元组<strong>不可完全相同</strong></p>
<p>5.每一分量必须是<strong>不可再分的数据</strong>，满足<strong>1NF</strong></p>
<blockquote>
<p>二维表无法表示<code>对分量进行再分</code>。例如住址这一分量不能是<code>河南省</code>、<code>南阳市</code> 两个数据，而应该为 <code>河南省南阳市</code>单个数据。或者直接设定为<code>省</code>、<code>市</code>两个分量。</p>
</blockquote>
<h4 id="关系模式">关系模式
</h4><p>用关系模型设置出来的一种结构就是关系模式。</p>
<p>关系模式还能确定为<strong>关系实例</strong>，关系实例是关系模式在<strong>某一时刻</strong>的状态或内容。</p>
<p>R（U，D，dom，F， I），R为关系名，U</p>
<p>为组成该关系的<strong>属性名集合</strong>，D为属性集U<strong>所来自的</strong></p>
<p><strong>域</strong>，dom为<strong>属性</strong>向<strong>域</strong>的<strong>映象集合</strong>、F为属性间的<strong>数</strong></p>
<p><strong>据依赖关系</strong>集合，I为<strong>完整性约束</strong>集合。关系模式通</p>
<p>常可以简记作R(A1 , A2 ,…, An ) ，只写<strong>R,U</strong>。</p>
<h4 id="关系数据库-1">关系数据库
</h4><p>关系数据库的型是关系模式的集合。（各个表的结构）</p>
<p>关系数据库的值是关系实例的集合。（具体的取值）</p>
<h3 id="完整性约束">完整性约束
</h3><p><strong>候选码</strong>：唯一性、最小性（删一个都不行）</p>
<blockquote>
<p>候选码可能只有一个属性，也有可能包含所有属性。所有属性作为候选码时，称为<strong>全码</strong>。</p>
</blockquote>
<p><strong>主码</strong>：候选码中选一个。</p>
<p><strong>主属性</strong>：<strong>所有候选码</strong>的属性的并。</p>
<p><strong>非主属性</strong>：不出现在任何候选码的属性。</p>
<p><strong>外部码</strong>：F是关系R的一个/一组属性，但<strong>不是R的码</strong>，而<strong>与关系S</strong>的主码<strong>相对应</strong>（F与S的主码必须定义在一个域）。<strong>R为参照关系，S为被参照关系（目标关系）。</strong></p>
<blockquote>
<p>R和S未必是不同的关系。比如学生表，可有主码<code>学号</code>，也可有外码<code>班长学号</code>。<code>班长学号</code>可以与学生表的主码<code>学号</code>相对应。</p>
</blockquote>
<h4 id="实体完整性">实体完整性
</h4><p>关系R<strong>主码</strong>中所包含的<strong>任意属性</strong>都不能取空值（未知或无意义）。 reason: 主码要用来区分不同实体</p>
<h4 id="参照完整性">参照完整性
</h4><p>若关系R的外码F与关系S的主码P相对应，那么关系R中每个元组的<strong>F值必须为空</strong>，或者<strong>等于</strong>关系S中<strong>某个元组的P值</strong>。 reason：可以尚未参照，若有参照，参照对象必须存在。</p>
<h4 id="用户定义的完整性">用户定义的完整性
</h4><p>用户针对具体的应用环境定义的完整性约束条件。如数值范围等。</p>
<p><strong>系统</strong>自动支持<strong>实体完整性</strong>和<strong>参照完整性</strong>，并提供<strong>定义和检验</strong>用户定义的完整性的机制。</p>
<h3 id="数据操作关系代数">数据操作——关系代数
</h3><p>集合论中传统的集合操作：<strong>集合并、集合交、集合差、广义笛卡尔积</strong></p>
<blockquote>
<p>不能处理条件，比如分数低于60的元组</p>
<p>不能选择属性，比如只看元组的学号、课程名、成绩，不显示学生名字</p>
<p>不能选择性拼接多个表，比如课程表里的课程名与学生表里的学生名</p>
<p>不能做笛卡尔积的逆运算</p>
</blockquote>
<p>专门的关系运算：<strong>选择、投影、连接、商</strong></p>
<p>由于要处理条件，所以还会有比较运算符与逻辑运算符</p>
<h4 id="基本运算">基本运算
</h4><p><strong>集合并、集合差、广义笛卡尔积、选择、投影</strong></p>
<p>其他运算都可以由基本运算得出。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174413660.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174413660"
	
	
></p>
<p>运算的结果都是表，也就是<strong>元组的集合</strong>。</p>
<h4 id="并运算">并运算
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174506438.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174506438"
	
	
></p>
<p>会去重。</p>
<h4 id="差运算">差运算
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174539244.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174539244"
	
	
></p>
<p>前面的去掉共有的。R-S与S-R不同。</p>
<h4 id="交运算">交运算
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174656568.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174656568"
	
	
></p>
<h4 id="广义笛卡尔积">广义笛卡尔积
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174739061.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174739061"
	
	
></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174752893.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174752893"
	
	
></p>
<p>笛卡尔积的元组个数是原来两个关系的元组个数的乘积。</p>
<p>笛卡尔积的属性个数是原来两个关系的属性个数之和。</p>
<h4 id="选择运算">选择运算
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174812110.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174812110"
	
	
></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174832386.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174832386"
	
	
></p>
<h4 id="投影运算">投影运算
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174847450.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174847450"
	
	
></p>
<p>要去重。</p>
<h4 id="连接运算">连接运算
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231174913634.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231174913634"
	
	
></p>
<p>笛卡尔积是强硬的拼接。经过选择即为连接。</p>
<p>若<strong>θ为‘=’</strong>，则为<strong>等值连接</strong>。</p>
<p>拼接后属性的个数等于原关系的属性数之和。</p>
<h4 id="自然连接">自然连接
</h4><p>若不写条件，则为自然连接。</p>
<p>自然连接相对于等值连接的区别：</p>
<p>1.不强调是哪个属性，而是取<strong>属性名相同</strong>且<strong>取值相等</strong>拼接为新元组</p>
<p>2.同名属性只保留一份</p>
<p>因此自然拼接后属性的个数未必等于原关系的属性数之和。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231180427756.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231180427756"
	
	
></p>
<blockquote>
<p>对于多处属性名相同的情况，必须<strong>都对应相等</strong>才能视为取值相等</p>
</blockquote>
<h4 id="复合连接">复合连接
</h4><p>对于自然连接的结果，直接<strong>删去连接属性列</strong>。</p>
<h4 id="半连接">半连接
</h4><p>连接运算后只保留R或者S的属性列。</p>
<blockquote>
<p>用于节省数据传输，仅提取数据用于条件判断，不必传整张表</p>
</blockquote>
<h4 id="外连接">外连接
</h4><p>目的：避免自然连接时因失配而发生的信息丢失。</p>
<p>未匹配的元组也仍存在于表中，只是多出来的属性取null。</p>
<blockquote>
<p>左外连接 = 自然连接 + 左侧表中失配的元组</p>
<p>右外连接 = 自然连接 + 右侧表中失配的元组</p>
<p>全外连接 = 自然连接 + 两侧表中失配的元组</p>
</blockquote>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231181139249.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231181139249"
	
	
></p>
<h4 id="除运算">除运算
</h4><p>A÷B=C……D</p>
<p>则B×C+D=A</p>
<p>也即C的属性应为 A的属性<strong>去掉</strong>B的属性</p>
<p>C应该填什么值？C中的值和B中的值一定能组合出A中的值！</p>
<p>那么需要考虑A中<strong>与B中元组取值相同</strong>的元组。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231182040182.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231182040182"
	
	
></p>
<p>可以大胆先得到所有可能元组ab,bc,ed，然后再逐元组验证。</p>
<p>也可以利用象集：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231181311887.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231181311887"
	
	
></p>
<p>对于T(CD,AB),</p>
<p>CD=cd时，象集为ab,ed</p>
<p>CD=ef时，象集为ab,bc,ed</p>
<p>对所有象集做广义交（在所有象集中都出现的元组）。</p>
<p>下面也是一种思路：</p>
<p>先列出所有AB的组合，并做笛卡尔积，得到理想被除数，然后减去真实被除数，可以得到欠缺的组合，从中提取欠缺的AB。最后并从所有AB组合中减去欠缺的AB，就是真正的商。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231183200875.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231183200875"
	
	
></p>
<p>这也就得到了除法的这一定义：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231183549756.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231183549756"
	
	
></p>
<p>其中，</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231183818202.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231183818202"
	
	
></p>
<p>就代表找到的AB组合一定能满足和除数做笛卡尔积还在R中，也就是除数包含于这个组合的象集。</p>
<p>象集的特殊含义：若把X作为对象A，那么X的象集就表示与对象A有关系R的<strong>所有</strong>对象B。</p>
<p>除法的特殊含义：得到的数据满足<strong>S中所有要求</strong>，也即与S中<strong>所有数据</strong>都满足关系R。</p>
<h4 id="关系代数练习">关系代数练习
</h4><p>简单的选择+投影</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231184954797.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231184954797"
	
	
></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231185018120.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231185018120"
	
	
></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231185041576.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231185041576"
	
	
></p>
<p>多表连接后选择+投影</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231185117756.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231185117756"
	
	
></p>
<p>可只选择表的一部分（关联部分+使用部分）后进行连接。</p>
<p>比如STUDENT预先只投影出关联部分Sno与使用部分Sname</p>
<blockquote>
<p>Cpno=5也可以最后再选择，但是连接操作cost很大，预处理后再连接比较好。</p>
<p>Course甚至也可以先投影只留下Cno和Cpno</p>
</blockquote>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231185208842.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231185208842"
	
	
></p>
<p>除法！</p>
<p>先求学号，之后关联就能求姓名。</p>
<p>学号怎么求？ 满足和<strong>所有课程</strong>都有<strong>选修关系</strong>的<strong>学生学号</strong>，用<strong>除法</strong>！</p>
<p>需要注意<strong>属性的选择</strong>。这里被除数不应包含其他属性。例如被除数包含<code>成绩</code>属性，那么就会要求<code>（学号，成绩）</code>的二元组与所有课程都有选修关系，也就是选了所有课的<strong>且成绩都相同</strong>选课记录，这是错误的。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231185950025.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231185950025"
	
	
></p>
<h3 id="数据操作sql语言">数据操作——SQL语言
</h3><h4 id="特点">特点
</h4><p>1.综合统一，集<strong>数据定义</strong>，<strong>数据操纵</strong>，<strong>数据查询</strong>和<strong>数据控制</strong>于一体</p>
<p>2.高度非过程化（关系操作的特点）</p>
<p>3.面向集合的操作方式（关系操作的特点）</p>
<p>4.以同一种语法结构提供<strong>两种使用方式</strong>，<strong>SQL既是自含式语言，又是嵌入式语言</strong></p>
<p>5.语言简洁，易学易用</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231191320008.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231191320008"
	
	
></p>
<p>外模式、模式和内模式都可以用SQL管理。</p>
<p>模式：<strong>基本表</strong>是本身独立存在的表，一个（或多个）基本表对应一个存储文件。</p>
<p>内模式：<strong>存储文件</strong>由数据块构成的存储空间，用于存储<strong>基本表、索引</strong>等。</p>
<p>外模式：<strong>视图</strong>是从一个或几个基本表中导出的表，其本身不独立存储于数据库中。</p>
<h4 id="数据查询">数据查询
</h4><p><strong>Select [ALL|DISTINCT] &lt;目标表达式&gt;[{,&lt;目标表达式&gt;}]</strong>
<strong>From &lt;表名或视图名&gt;[{,&lt;表名或视图名&gt;}]</strong>
<strong>[Where &lt;条件表达式&gt;]</strong>
<strong>[Group By &lt;分组列&gt; [{,&lt;分组列&gt;}] [HAVING &lt;条件表达式&gt;]]</strong>
<strong>[Order By &lt;排序列&gt; &lt;排序方式&gt;[{,&lt;排序列&gt; &lt;排序方式&gt;}]</strong></p>
<h5 id="alldistinct">ALL|DISTINCT
</h5><p>SQL不会自动去重，如果需要去重，需要加上DISTINCT</p>
<h5 id="目标表达式">目标表达式
</h5><p>目标表达式是<strong>表达式</strong>，也可直接<strong>缺省为</strong>*表示所有属性，也可以不是/不包含表中的属性</p>
<p>select * from Student;</p>
<p>select <strong>&lsquo;北航&rsquo;</strong>, toLower(Sname), <strong>2025-Sage</strong> from Student;</p>
<p>加空格后面可<strong>附上属性别名</strong>：</p>
<p>select &lsquo;北航&rsquo;  <strong>school</strong>, 2025-Sage <strong>birth_date</strong> from Student;</p>
<p><strong>聚集函数</strong>也是目标表达式。</p>
<blockquote>
<p>Count() 求元组个数</p>
<p>Sum() 对数值列求总和</p>
<p>Avg() 求数值列的平均值</p>
<p>Max() 求最大值</p>
<p>Min() 求最小值</p>
</blockquote>
<p>Select Count(*) student_count From Student;</p>
<p>Select Count(<strong>Distinct</strong> Sno) From SC;</p>
<h5 id="条件表达式">条件表达式
</h5><p>where + 条件表达式</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231192443420.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231192443420"
	
	
></p>
<p>LIKE: 支持通配符<code>%</code>(通配零到多个字符)，<code>_</code>(仅通配一个字符)</p>
<p>IN可以作为同类OR的简写，如A=1 OR A=2可写为A IN (1,2)</p>
<blockquote>
<p>注意A IN (1,2)可不是A BETWEEN 1 AND 2的意思</p>
</blockquote>
<p><code>IS NULL</code> 而非 <code>= NULL</code> ，因为说 <code>NULL = NULL</code>是不合理的</p>
<blockquote>
<p>注意若NULL参与计算，要把NULL转为其他值再进行计算，避免数据污染</p>
</blockquote>
<h5 id="order-by">Order By
</h5><p>可选择<strong>升序ASC</strong>与<strong>降序DESC</strong></p>
<p>顺序代表排序优先级</p>
<h5 id="group-by">Group By
</h5><p>聚集函数的结果总是只有一行。因为默认大家是一个大group.</p>
<p>我们可以先对某变量进行group，聚集函数就会根据新的group进行成批运算。</p>
<p>Select <strong>Cno, Count(Sno)</strong> From SC</p>
<p><strong>Group By Cno;</strong></p>
<p>这样就会算出每个Cno Group的Count(Sno)</p>
<blockquote>
<p>要求：若使用group,目标表达式只能包含聚集函数与group的对象。因为只有这两类表达式能保证以group为单位，而不会出现一个group对应多值。</p>
</blockquote>
<p>查询选课至少为三门的学生的学号及其选课门数：</p>
<p>Select Sno, Count(Sno) From SC</p>
<p>Group By Sno <strong>Having Count(Sno)&gt;=3</strong>;</p>
<p>对聚集函数统计结果进行筛选<strong>只能使用HAVING</strong>!</p>
<p>因为<strong>WHERE子句比GROUP BY先执行。</strong></p>
<p>查询 <strong>至少有三门课选课并及格</strong> 的学生的学号及其<strong>及格选课</strong>门数：</p>
<p>Select Sno, Count(Sno) From SC</p>
<p>WHERE Grade &gt;= 60</p>
<p>Group By Sno <strong>Having Count(Sno)&gt;=3</strong>;</p>
<h5 id="多表查询">多表查询
</h5><p>直接写from多个表即可。</p>
<p>若有属性名相同，需要强调 <code>表名.属性名</code></p>
<p>直接在WHERE子句应填写<strong>连接条件</strong>，不填写则默认<strong>笛卡尔积</strong>。</p>
<p>连接条件：[&lt;表名&gt; .] &lt;列名&gt; &lt;比较运算符&gt; [&lt;表名&gt; .] &lt;列名&gt;</p>
<blockquote>
<p>推荐新版写法：JOIN ON语句，把连接条件单列出来</p>
<p>from 表1</p>
<p>JOIN 表2 ON .连接条件</p>
</blockquote>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231195510833.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231195510833"
	
	
></p>
<p>表名后也可以加空格进行更名。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231195532219.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231195532219"
	
	
></p>
<p>外连接：所有学生</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231200242005.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231200242005"
	
	
></p>
<p>新版本表达（推荐）：</p>
<p>from Student <strong>LEFT (OUTER)  JOIN</strong> SC ON &hellip;</p>
<p>同理还有RIGHT与FULL</p>
<h5 id="嵌套查询">嵌套查询
</h5><p><strong>不相关</strong>子查询：由内向外，将<strong>查询语句的返回值</strong>作为<strong>查询条件的条件值</strong>。因为查询语句的返回值是集合，我们往往使用<strong>IN</strong>运算符而非等号，或者**&lt; ANY()<strong>，</strong>&lt;ALL()<strong>这种，any为存在，all为任意，也可以是</strong>EXIST()<strong>，若返回值为空集则为</strong>FALSE**。</p>
<p><strong>相关</strong>子查询：子查询进行时需要父查询提供信息。</p>
<p><code>查询与刘晨在同一个系学习的学生</code>：先找到刘晨在哪个系</p>
<blockquote>
<p>这里是特殊情况，使用=</p>
</blockquote>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231200744915.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231200744915"
	
	
></p>
<p>这是一个不相关子查询。</p>
<p><code>查询选修了课程名为‘信息系统’的学生的学号和姓名。</code></p>
<p>这是一个典型的连接查询，但我们也可以用嵌套查询。</p>
<p>先求出课程名为‘信息系统’的课程号，</p>
<p>再求选修了该课程号的学生的学号，</p>
<p>最后求该学号对应的学号和姓名。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231200956497.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231200956497"
	
	
></p>
<p><code>查询选择了1号课程的学生姓名。</code></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231202501986.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231202501986"
	
	
></p>
<p>这是一个<strong>相关子查询</strong>。</p>
<p><strong>外层Student表也参与了子查询</strong>。执行逻辑是遍历父查询的每一个元组，对每个元组计算Student.Sno，这个值参与子查询的运算，从而决定父查询是否包含该元组。</p>
<p><code>查询选修了全部课程的学生姓名</code></p>
<p>除法操作，表示与某属性所有值均有联系：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231203349483.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231203349483"
	
	
></p>
<p>这是一个相关子查询。</p>
<p>双重相关子查询：找的是学生，所以遍历student，再对每个student遍历course，看是否每个都存在。</p>
<p>不存在 <code>没匹配上的课程</code>，就是选修了所有课程。</p>
<p>如果改为EXIST NOEXIST，则表示未选修全部课程。</p>
<p>如果改为EXIST EXIST，则表示选修过课程。</p>
<p>如果改为NOEXIST EXIST，则表示未选修过课程。</p>
<h5 id="集合查询">集合查询
</h5><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231204837359.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231204837359"
	
	
></p>
<p>对语句做<strong>并</strong>操作。要求查询结果字段结构一致。</p>
<p><strong>交操作与差操作没有集合查询功能。</strong></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231204950810.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231204950810"
	
	
></p>
<p>差集就是排除，只需要把第二个条件取反，或者用NOT。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231205020740.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231205020740"
	
	
></p>
<h4 id="数据更新">数据更新
</h4><h5 id="insert----into">Insert &ndash; Into
</h5><blockquote>
<p>不是add</p>
</blockquote>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231205626250.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231205626250"
	
	
></p>
<p>如果只insert了一部分属性，其余属性值<strong>默认为null</strong>。</p>
<h5 id="update----set">Update &ndash; Set
</h5><blockquote>
<p>不是modify</p>
</blockquote>
<p>支持原值引用。</p>
<p>子查询的值可以用在<strong>WHERE</strong>语句与<strong>SET</strong>语句。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231205706643.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231205706643"
	
	
></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231205719741.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231205719741"
	
	
></p>
<h5 id="delete">Delete
</h5><p>delete from 表名 会直接删掉该表所有元组。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231210055483.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231210055483"
	
	
></p>
<h4 id="数据定义">数据定义
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231210129817.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231210129817"
	
	
></p>
<h5 id="基本表定义删除修改">基本表——定义、删除、修改
</h5><h6 id="create">create
</h6><p><strong>Create Table &lt;表名&gt;</strong></p>
<p><strong>(</strong>&lt;列名&gt;&lt;<strong>数据类型</strong>&gt;[&lt;<strong>列级</strong>完整性约束&gt;]</p>
<p>[{, &lt;列名&gt;&lt;数据类型&gt;[&lt;<strong>列级</strong>完整性约束&gt;]}]</p>
<p>[{, [&lt;<strong>表级</strong>完整性约束&gt;]}]<strong>)</strong></p>
<p><strong>数据类型</strong>常用：char(n)、int、float(n)、date、time</p>
<p><strong>完整性约束</strong>：NULL/NOT NULL（列级）、UNIQUE（<strong>列级</strong>、候选码，可以取空值）、PRIMARY KEY（<strong>表级</strong>、主码，不可取空值）、FOREIGN KEY（<strong>表级</strong>）、CHECK（<strong>表级</strong>）</p>
<p>单一属性的非外码的表级完整性约束也可以只写在对应列级上。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231210608638.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231210608638"
	
	
></p>
<p>外码的书写需要标明reference 表(主码)</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231210815802.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231210815802"
	
	
></p>
<h6 id="alter">alter
</h6><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231211039990.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231211039990"
	
	
></p>
<p>drop尽量不要删除属性列，其实是可以删的。</p>
<p>modify尽量不要改列名，虽然其实也可以改。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231211201064.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231211201064"
	
	
></p>
<h6 id="drop">drop
</h6><p>直接 drop table 表名即可删除整个基本表。分配的空间也回收了。</p>
<h5 id="索引定义删除">索引——定义、删除
</h5><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231212609133.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231212609133"
	
	
></p>
<p>unique是<strong>唯一性约束</strong>，cluster要求索引与基本表在<strong>物理上连续存储</strong>，便于查询。</p>
<p><strong>cluster索引只能建一个。<strong>因为</strong>物理上</strong>只能有一个连续存储。</p>
<p>索引可以<strong>提升查询速度</strong>，需要<strong>单独创建文件</strong>，占<strong>空间小</strong>、元组<strong>有序</strong>。</p>
<p>但是会<strong>降低更新速度</strong>，每次更新还要更新索引表，还要重新排序。</p>
<blockquote>
<p>不能说索引<strong>越多越好</strong>，也不能说索引会提高<strong>操作</strong>效率</p>
</blockquote>
<p>也是create和drop</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231212007391.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231212007391"
	
	
></p>
<p>index的drop<strong>不会丢失数据，不必备份</strong>。</p>
<p>索引的<strong>排序顺序对我们没有意义</strong>，是DBMS操作的。</p>
<p>索引与where子句、聚合函数高度相关，索引<strong>便于筛选</strong>，并且<strong>预先计算好统计数据</strong>。</p>
<p>双关键字排序时，第二个关键字整体还是乱序。</p>
<p>消除碎片：把所有index删掉再重建，DBMS重新集中分配空间。</p>
<h5 id="视图定义删除">视图——定义、删除
</h5><p>视图被称为<strong>虚表</strong>，<strong>没有存储数据</strong>，而是存储<strong>select语句</strong>。</p>
<blockquote>
<p>能够<strong>简化用户操作</strong>, 使用户能够以<strong>多种角度</strong>看待同一数据, 对重构数据提供了一定程度的<strong>逻辑独立性</strong>, 能够对机密数据提供<strong>安全保护</strong>。</p>
</blockquote>
<p>直接利用视图<strong>封装</strong>好复杂的select语句。</p>
<p>我们只提供视图，就既能提供功能，还能保护数据。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231213220186.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231213220186"
	
	
></p>
<p>手写列名可用于更名。</p>
<p><strong>子查询</strong>可以是单表查询，多表查询，嵌套查询，集合查询……</p>
<p>**视图可以嵌套！**子查询语句可以是对另一视图的select。</p>
<p><strong>drop view 视图名</strong>即可直接删除，<strong>不会丢失数据，不必备份</strong>。</p>
<h6 id="视图消解">视图消解
</h6><p>DBMS会<strong>尝试</strong>把程序员发起的SQL指令中的视图拆为select，并进行语句合并，融合为一个select进行。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231214523805.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231214523805"
	
	
></p>
<h6 id="视图更新">视图更新
</h6><p>视图也可以充当<strong>范围受限的基本表</strong>使用。</p>
<p><code>insert into 视图 values(...)</code> 也能<strong>实现修改基本表</strong>。</p>
<p>values可以包含视图中没有提供的属性，这可能触发错误。可开启<strong>With Check Option</strong>，使其在Insert与Update的时候也会做检查。</p>
<p><strong>视图更新约束</strong></p>
<p>要借助视图进行insert时，视图自身需满足一定要求。</p>
<ol>
<li>
<p>select子句中的目标列不能包含<strong>聚集函数</strong></p>
</li>
<li>
<p>select子句中不能使用<strong>distinct关键字</strong></p>
</li>
<li>
<p>不能包括<strong>group by</strong>子句</p>
</li>
<li>
<p>不能包括经<strong>算术表达式</strong>计算出来的列</p>
</li>
<li>
<p>必须包含基本表的<strong>主码</strong>（否则插入的元组主码为空）</p>
</li>
</ol>
<p>对于行列子集视图可以更新（视图是从<strong>单个基本表使用选择</strong>、<strong>投影操作导出</strong>的，并且<strong>包含了基本表的主码</strong>）</p>
<h2 id="数据库安全性与完整性">数据库安全性与完整性
</h2><p><strong>计算机系统的安全性</strong>是指为计算机系统建立和采取的各种安全保护措施，以保护计算机系统中的硬件、软件和数据，防止其因偶然或恶意的原因使系统遭到破坏，数据遭到更改或泄漏等。</p>
<p>技术安全类（计算机系统及其数据受到攻击，如增添丢失泄露）、管理安全类（意外故障、管理不善、物理破坏丢失）、政策法律类</p>
<h3 id="安全性">安全性
</h3><h4 id="安全威胁">安全威胁
</h4><ol>
<li>
<p>造成对数据库内存储数据的<strong>非授权访问–读取</strong>，或<strong>非授权的写入–增加、删除、修改</strong></p>
</li>
<li>
<p>影响<strong>授权用户以正常方式</strong>使用数据库系统的数据服务</p>
</li>
</ol>
<p>具体分类：</p>
<p>1.<strong>偶然地、无意地</strong>接触或修改DBMS管理下的数据</p>
<p>2.<strong>蓄意的侵犯和敌意的攻击</strong></p>
<h4 id="定义">定义
</h4><p>数据库的安全性是指<strong>保护数据库</strong>以防止<strong>不合法的</strong>使用所造成的<strong>数据泄漏、更改和破坏</strong>。它包括两个方面的含义：向<strong>授权用户提供可靠</strong>的信息服务。同时，<strong>拒绝非授权的</strong>对数据的<strong>存取访问</strong>请求，保证数据库管理下的数据的<strong>可用性、完整性和一致性</strong>，进而保护数据库<strong>所有者和使用者</strong>的<strong>合法权益</strong>。</p>
<h4 id="安全控制">安全控制
</h4><h5 id="外部安全控制">外部安全控制
</h5><p><strong>外部安全控制</strong>解决内部安全控制<strong>不能解决</strong>的问题。</p>
<blockquote>
<p>偏管理</p>
</blockquote>
<p><strong>实体安全</strong>控制、<strong>人员、组织安全</strong>控制、<strong>过程安全</strong>控制</p>
<h5 id="内部安全控制">内部安全控制
</h5><p><strong>内部安全控制</strong>由计算机系统的<strong>软硬件</strong>实现。它必须与管理系统物理存取的适当的外部安全控制相配合。</p>
<blockquote>
<p>偏技术</p>
</blockquote>
<p><strong>数据库本身提供的安全机制</strong>：</p>
<h6 id="用户标识与鉴别">用户标识与鉴别
</h6><p>采用用户名与口令，是<strong>系统提供的最外层安全保护措施</strong></p>
<h6 id="存取控制">存取控制
</h6><p>合法用户能按照指定权限使用，非法用户、无权用户不能</p>
<ul>
<li>定义用户权限</li>
<li>合法权限检查</li>
</ul>
<p>存取控制可以分为</p>
<p><strong>自主存取控制（DAC)</strong>：更自由，用户对不同数据对象有不同权限，可转授权限。</p>
<p>用户权限分为<strong>数据对象</strong>和<strong>操作类型</strong>两个要素。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231221910126.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231221910126"
	
	
></p>
<p><strong>用户级</strong>权限：一般由<strong>数据库管理员</strong>为每个用户授权，与整个数据库相关。</p>
<p><strong>关系级</strong>权限：由<strong>数据库管理员或数据库对象拥有者</strong>授权，基本是表义级权限。</p>
<blockquote>
<p>对权限与用户打包：</p>
<p><strong>角色</strong>：<strong>权限</strong>的集合，可以授予给<strong>用户</strong>或其他<strong>角色</strong>。</p>
<p><strong>用户组</strong>：<strong>用户</strong>的集合，可以<strong>以用户组为单位</strong>授权与收回权限</p>
</blockquote>
<p><strong>用户级权限与角色</strong></p>
<p>授权与收回权限：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231222204396.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231222204396"
	
	
></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231222504946.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231222504946"
	
	
></p>
<p><strong>public</strong> 指数据库中的<strong>全部用户</strong>。</p>
<p><strong>With Grant Option</strong>则允许被授权的用户将指定的用户级权限或角色<strong>授予其他用户</strong>。</p>
<p><strong>多重授权</strong>：A-&gt;C B-&gt;C  若A被revoke,C仍有权限。</p>
<p><strong>循环授权</strong>：A-&gt;B B-&gt;C 若C主动-&gt;B，会导致A被revoke,C仍有权限。现在已被禁止。</p>
<p>Oracle的角色：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231222405279.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231222405279"
	
	
></p>
<p><strong>没有授权CONNECT甚至没有登录权。</strong></p>
<p><strong>DBA拥有全部权限</strong>。</p>
<p><strong>关系级权限</strong></p>
<p>对于具体的表格与视图的权限控制。</p>
<p>多了<strong>ON子句针对具体的表/视图</strong>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231222813243.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231222813243"
	
	
></p>
<p>可以<strong>利用视图</strong>实现<strong>安全控制</strong>。</p>
<p><strong>强制存取控制（MAC）</strong>：中央集中控制，用户与数据对象被赋予固定的许可证级别与密级。</p>
<p>主体的敏感度标记称为<strong>许可证级别</strong>，客体敏感度标记称为<strong>密级</strong>。</p>
<ul>
<li><strong>许可证级别 &gt;= 密级</strong>：可以<strong>读</strong></li>
<li><strong>许可证级别 == 密级</strong>：可以<strong>写</strong>，避免滥用权力</li>
</ul>
<h6 id="审计">审计
</h6><p>​	把用户对数据库的<strong>所有操作都自动记录</strong>下来放入审计日志中。DBA可以利用审计跟踪的信息，<strong>重现</strong>导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。</p>
<h6 id="数据加密">数据加密
</h6><p>​	防止数据库中数据在<strong>存储和传输中失密</strong>的有效手段。加密的基本思想是根据一定的算法将<strong>原始数据（明文）变换为不可识别的格式（密文）</strong>，从而使得不知道解密算法的人无法获知数据的内容。</p>
<h4 id="统计数据库安全性">统计数据库安全性
</h4><p>​	统计数据库中的数据分为两类，一类是<strong>微数据</strong>描述现实世界的实体、概念或事件的数据；另一类是<strong>统计或综合数据</strong>，是对微数据进行综合处理而得到的结果数据。</p>
<p>​	<strong>统计数据库只为用户提供统计数据，不允许用户访问微数据</strong>。但微数据有时可以通过一组统计数据推导出来。统计数据库安全性的目的就是防止用户<strong>访问或推导</strong>出统计数据库的微数据。</p>
<p>解决方案：</p>
<blockquote>
<p>先用where语句访问count，count为1时的统计数据就是微数据！</p>
</blockquote>
<ol>
<li>控制统计结果的大小</li>
</ol>
<blockquote>
<p>访问A+其他人，B+其他人，相减得到AB差值。</p>
</blockquote>
<ol start="2">
<li>
<p>禁止重复执行统计查询</p>
</li>
<li>
<p>统计结果加入噪声 （越查询误差越大）</p>
</li>
</ol>
<h3 id="完整性">完整性
</h3><p>数据库的完整性是指数据的<strong>正确性</strong>和<strong>相容性</strong>。</p>
<p><strong>正确性</strong>：合法的类型、有效的取值范围</p>
<p><strong>相容性</strong>：同一事实的两个数据应当自洽。</p>
<p>完整性措施的防范对象是<strong>不合语义的数据</strong>。</p>
<h4 id="完整性约束条件">完整性约束条件
</h4><p>施加在数据库数据之上的<strong>语义约束条件</strong>称为数据库完整性约束条件。</p>
<p>作用的对象可以是<strong>关系、元组、列</strong>三种。</p>
<ul>
<li>
<p>列约束主要是列的<strong>类型、取值范围、精度</strong>等约束条件。</p>
</li>
<li>
<p>元组的约束是元组中<strong>各个字段间联系</strong>的约束。</p>
</li>
<li>
<p>关系的约束是若干<strong>元组间、关系集合上以及关系之间</strong>的联系的约束。</p>
</li>
</ul>
<p>又可分为<strong>静态约束</strong>和<strong>动态约束</strong>。</p>
<h5 id="静态约束">静态约束
</h5><p>静态约束是指数据库<strong>每一确定状态</strong>时，数据对象所应满足的约束条件，它是反映数据库状态合理性的约束。</p>
<p><strong>静态列级</strong>约束是对一个列的<strong>取值域</strong>的说明。</p>
<p><strong>静态元组级</strong>约束是对<strong>一个元组的各个列之间的约束关系</strong>。</p>
<blockquote>
<p>属性A为x的元组需要满足属性B大于100</p>
</blockquote>
<p><strong>静态关系</strong>约束：<strong>实体完整性约束、参照完整性约束、函数依赖、统计约束</strong></p>
<blockquote>
<p>统计约束：对于属性A为x的元组，属性B的值必须高于其平均值。</p>
</blockquote>
<p>还可分为：</p>
<p><strong>固有约束</strong>：数据<strong>模型</strong>固有约束。如属性原子化</p>
<p><strong>隐含约束</strong>：数据<strong>模式</strong>隐含约束，DDL语句说明（如实体完整性约束等建表时就确定的约束）</p>
<p><strong>显式约束</strong>：人为显示定义的语义与应用层约束</p>
<h6 id="隐含约束">隐含约束
</h6><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231233021430.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231233021430"
	
	
></p>
<ul>
<li>
<p><strong>实体完整性与其他DDL定义</strong>约束：</p>
<p>Insert 或者Update时检查，违反则取消操作</p>
</li>
<li>
<p><strong>参照完整性约束</strong>：</p>
<p>Insert、Update、<strong>Delete</strong>时检查</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20251231233141515.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20251231233141515"
	
	
></p>
</li>
</ul>
<p><strong>级联删除/更新</strong>：直接把参照表的对应记录也删除/更新</p>
<h6 id="显示完整性约束">显示完整性约束
</h6><ul>
<li>
<p><strong>过程</strong>（程序员为每个约束编制一个验证过程）</p>
</li>
<li>
<p><strong>断言</strong></p>
</li>
<li>
<p><strong>触发器</strong>（不同DBMS写法不同   <code>:new.属性名</code>  <code>:old.属性名</code>）</p>
<blockquote>
<p>断言表示数据库状态<strong>应当满足</strong>的条件，</p>
<p>而触发器中的条件却是<strong>违反约束</strong>的条件</p>
</blockquote>
</li>
</ul>
<h5 id="动态约束">动态约束
</h5><p>动态约束是指数据库从一种状态转变为另一种状态时，<strong>新、旧值之间</strong>所应满足的约束条件，它是反映数据库状态变迁的约束。</p>
<p><strong>动态列级</strong>约束是修改<strong>列定义</strong>或<strong>列值</strong>时应满足的约束条件。</p>
<blockquote>
<p>某属性的值只能增加不能减少</p>
<p>不能在已包含null的列上增加not null约束</p>
</blockquote>
<p><strong>动态元组级</strong>约束指修改元组值时元组中各个字段间需要满足的约束。</p>
<blockquote>
<p>属性A为x的元组需要满足属性B只能增加</p>
</blockquote>
<p><strong>动态关系</strong>约束：多元组之间等等。</p>
<h4 id="完整性控制机制">完整性控制机制
</h4><p>三个功能：<strong>定义功能、检查功能、违约响应</strong>。</p>
<p>检查时机：</p>
<p><strong>立即执行约束</strong>是指在执行用户事务的过程中，在<strong>一条语句执行完</strong>后立即进行完整性约束的检查。若违背了完整性约束，系统将<strong>拒绝该操作</strong>。</p>
<p><strong>延迟执行约束</strong>是指在<strong>整个用户事务</strong>执行完毕后，再进行完整性约束的检查。若违背了完整性约束，系统将<strong>拒绝整个</strong>事务。</p>
<p>一条完整性规则可以用一个**五元组（D，O，A，C，P）**来描述，其中：</p>
<p><strong>D</strong>（Data）约束所作用的<strong>数据对象</strong></p>
<p>O（Operation）触发完整性检查的<strong>数据库操作</strong>，即当用户发出<strong>什么操作</strong>请求时需要检查，是<strong>立即检查还是延迟检查</strong>。</p>
<p><strong>A</strong>（Assertion）数据对象必须满足的断言或语义<strong>约束</strong>。</p>
<p><strong>C</strong>（Condition）选择A作用的数据对象值的<strong>谓词</strong>（条件）</p>
<p><strong>P</strong>（Procedure）违反完整性规则时<strong>触发的过程</strong>。</p>
<h2 id="关系数据理论">关系数据理论
</h2><p>如何判断关系模式的优劣？如何优化关系模式？</p>
<p><strong>关系数据理论</strong>借助于<strong>数学工具</strong>规定了一套关系数据库设计的理论和方法。</p>
<p>基于<strong>属性之间的联系</strong>进行设计，这种联系叫做<strong>数据依赖</strong>。</p>
<h3 id="函数依赖">函数依赖
</h3><p>数据依赖中最重要的就是<strong>函数依赖</strong>。</p>
<p>在某关系模式中，若某属性组A的值确定后，另一属性组B的值也被唯一确定，则称A<strong>函数决定</strong>B，B<strong>函数依赖</strong>于A。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260101224113675.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260101224113675"
	
	
></p>
<ul>
<li>函数依赖不随时间而变，永远成立。（不能仅凭当前的数据判断函数依赖）</li>
<li>函数依赖是<strong>语义</strong>决定的，是一种语义完整性约束，是一切关系均需满足的约束条件。</li>
</ul>
<p>属性之间的联系分为1对1，1对多，多对多：</p>
<p>其中<strong>X与Y</strong>为<strong>1对1</strong>或<strong>1对多</strong>时，有<strong>X函数依赖于Y</strong>，<strong>Y函数决定X</strong></p>
<blockquote>
<p>学号与身份证号是1对1，名字与学号是1对多（存在重名）</p>
<p>都有学号<strong>函数决定</strong>身份证号和名字</p>
</blockquote>
<p>多对多时，则不存在函数依赖。</p>
<p>根据表格初步判断函数依赖时，找<strong>左端重复项</strong>，对应<strong>右端是否相同</strong>即可。</p>
<h4 id="分类">分类
</h4><h5 id="平凡函数依赖与非平凡函数依赖">平凡函数依赖与非平凡函数依赖
</h5><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102172528087.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102172528087"
	
	
></p>
<p>自己决定自己就是平凡的函数依赖。</p>
<p>平凡的函数依赖是<strong>永真的</strong>，意义不大。</p>
<h5 id="完全函数依赖与部分函数依赖">完全函数依赖与部分函数依赖
</h5><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102172649547.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102172649547"
	
	
></p>
<p>完全：<strong>full</strong>   部分：<strong>part</strong></p>
<p><strong>完全</strong>的函数依赖有<strong>最小性</strong>，决定者<strong>不包含多余属性</strong>，或者说删去任一属性就无法再决定。</p>
<blockquote>
<p>上图中的例子就很经典：</p>
<p>完全函数依赖属性缺一不可，部分函数依赖则有冗余</p>
</blockquote>
<h5 id="传递函数依赖">传递函数依赖
</h5><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102173245901.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102173245901"
	
	
></p>
<ol>
<li>X决定Y是<strong>非平凡</strong>的函数依赖</li>
<li>Y决定Z是<strong>非平凡</strong>的函数依赖</li>
<li>X与Y不是<strong>一一对应</strong>（1:1的属性联系，比如学号和身份证号）</li>
</ol>
<h4 id="码的规范定义">码的规范定义
</h4><p>码有 <em>唯一性</em> 和 <strong>最小性</strong>。其实对应的就是 <strong>完全</strong> <em>函数依赖</em>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102174005434.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102174005434"
	
	
></p>
<p>超码不一定是码，而是广义的码。只要求函数依赖，不强调<strong>完全</strong>。</p>
<p>同样，主属性依旧是所有候选码中出现的属性的并集。</p>
<p>非主属性不包含在任何一个候选码。</p>
<p>全码是指<strong>码由整个属性组构成</strong>，也强调最小性。</p>
<blockquote>
<p>不要混淆超码和全码。</p>
</blockquote>
<h3 id="范式">范式
</h3><p>范式是对关系的不同<strong>数据依赖程度</strong>的要求。</p>
<blockquote>
<p>范式即表示条件，也表示满足条件的关系构成的集合。</p>
<p>我们用 属于符号 来描述关系与范式。</p>
</blockquote>
<p><strong>1NF 2NF 3NF BCNF 4NF 5NF</strong></p>
<blockquote>
<p>本课程仅讲述1NF到BCNF。</p>
</blockquote>
<p><strong>一个</strong>低级范式的关系模式，通过<strong>模式分解</strong>可以转换为<strong>若干个</strong>高级范式的关系模式的集合，这一过程称作<strong>规范化</strong>。</p>
<p>范式等级越高越好？(X)</p>
<blockquote>
<p>表数量增多，增加了关联操作的次数，开销也会更大。</p>
</blockquote>
<h4 id="1nf">1NF
</h4><p>关系中每一分量必须是<strong>原子的，不可再分</strong>。即不能以<strong>集合、序列</strong>等作为属性值。</p>
<p>这是关系六大性质之一。所以<strong>只要是关系模式，都满足1NF</strong>。</p>
<h4 id="2nf">2NF
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102175505230.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102175505230"
	
	
></p>
<p>也就是<strong>所有候选码</strong>都<strong>完全决定</strong> <strong>所有非主属性</strong>。</p>
<p>要成为2NF，关键是消除<strong>非主属性</strong>对码的<strong>部分</strong>依赖。</p>
<ul>
<li>关系R的全体属性都是R的主属性时，也就是没有非主属性，没有反例，所以一定属于2NF</li>
<li>R的所有候选码都只含一个属性时，一定是最小的，所以一定都是完全的函数依赖，一定属于2NF</li>
</ul>
<p><strong>没有2NF时存在捆绑问题</strong>：</p>
<ol>
<li>
<p>插入异常：码中存在<strong>多余属性</strong>，在插入<strong>不依赖于多余属性</strong>的信息时，<strong>多余属性没有值</strong>，而主码不能为空，导致插入失败。</p>
</li>
<li>
<p>删除异常：要想删除学生的<strong>多余属性信息</strong>，<strong>整个元组</strong>都需随之删除。</p>
</li>
<li>
<p>数据冗余：在导入<strong>多余属性相关信息</strong>时，会重复插入相同的<strong>不依赖于多余属性</strong>的信息。</p>
</li>
<li>
<p>更新异常：3的逆过程，数据冗余会导致修改时需要多次重复来保证数据一致性。</p>
</li>
</ol>
<p><strong>规范化为2NF的示例</strong>：</p>
<p>将<strong>导致部分函数依赖</strong>的<strong>完全函数依赖</strong>相关的<strong>主属性与非主属性</strong>拉出去单独成表。</p>
<p>原表若缺主码可以再填回主属性。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102180752984.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102180752984"
	
	
></p>
<h4 id="3nf">3NF
</h4><ul>
<li>一种民间的定义：</li>
</ul>
<p>若<strong>R属于2NF</strong>，并且不存在<strong>非主属性对码的传递函数依赖</strong>，则R属于3NF。</p>
<ul>
<li><strong>正式定义</strong>：</li>
</ul>
<p>不要求2NF的前提。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102181023990.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102181023990"
	
	
></p>
<p>对比一下传递依赖的定义：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102173245901.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102173245901"
	
	
></p>
<p>3NF去除了Y不是X的子集的限制。</p>
<ul>
<li>如果Y是X的子集，那么Y-&gt;Z的意思就是<strong>码的子集</strong>能函数决定非主属性，这就是<strong>部分函数依赖</strong>的定义。因此可以排除部分函数依赖。</li>
<li>如果不是，那就是<strong>传递函数依赖</strong>的定义，可以排除传递函数依赖。</li>
</ul>
<p>要成为3NF，关键是要消除2NF的关系模式中<strong>非主属性对码</strong>的<strong>传递函数依赖</strong>。</p>
<blockquote>
<p>所有非主属性对码都有依赖，如果非主属性对码有了<strong>传递函数依赖</strong>，那就说明非主属性<strong>内部存在函数依赖</strong>。</p>
</blockquote>
<ul>
<li>关系R的只有一个非主属性时，内部必无非平凡依赖，一定属于3NF</li>
</ul>
<p><strong>没有3NF时存在捆绑问题</strong>：</p>
<p>同样是那四条。主要原因是非主属性内部存在函数依赖，而这种关系可以提取出来单独成表。</p>
<p>例如S_SD(SNO, SNAME, DEPT, HEAD)，DEPT与HEAD之间的函数依赖就应当单独成表，否则由于<strong>SNO的主码限制</strong>，不能单独插入、修改DEPT与HEAD的信息。</p>
<p><strong>规范化为3NF的示例</strong>：</p>
<p>将<strong>导致传递依赖</strong>的<strong>非主属性内部函数依赖</strong>相关的<strong>非主属性</strong>拉出去单独成表。</p>
<p>新表的码放回原表当外码。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102181547534.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102181547534"
	
	
></p>
<h4 id="bcnf">BCNF
</h4><p>R(A,B,C)有以下函数依赖：A-&gt;B   (B,C)-&gt;A</p>
<p>候选码：(B,C) (A,C)</p>
<p><strong>问题：</strong></p>
<ul>
<li>
<p>如果没有C，就无法描述A-&gt;B的关系。</p>
</li>
<li>
<p>因为C的不同产生的不同元组也会存入A-&gt;B的冗余信息。</p>
</li>
</ul>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102184110122.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102184110122"
	
	
></p>
<p>所有<strong>非平凡函数决定者</strong>必须是<strong>码</strong>（也就是候选码）。</p>
<blockquote>
<p>也就是不允许码之外存在任何函数依赖。</p>
</blockquote>
<ul>
<li>只包含<strong>两个属性</strong>时一定是BCNF。（四种函数依赖情况都没有反例）</li>
</ul>
<p><strong>解决示例：</strong></p>
<p>A-&gt;B，但是A不是候选码。</p>
<p>改造为R1(A,B)与R2(B,C)。只有两个属性一定是BCNF。</p>
<h3 id="数据依赖的公理系统">数据依赖的公理系统
</h3><p>对于满足一组函数依赖F的关系模式R&lt; U, F &gt;，若函数依赖X-&gt;Y成立，则称F<strong>逻辑蕴涵</strong>X-&gt;Y，也即F|=X-&gt;Y。</p>
<h4 id="armstrong公理">Armstrong公理
</h4><ul>
<li>自反律。<strong>平凡的</strong>函数依赖为F所蕴含。</li>
<li>增广律。X-&gt;Y为F所蕴含，则(X,Z)-&gt;(Y,Z)也为F所蕴含。</li>
<li>传递律。X-&gt;Y，Y-&gt;Z为F所蕴含，则X-&gt;Z也为F所蕴含。</li>
</ul>
<p>为F所蕴含的<strong>所有函数依赖</strong>的全体称为<strong>F的闭包</strong>，记作F^+^。</p>
<ul>
<li>
<p>有效性：由F出发根据Armstrong公理推导出来的函数依赖一定在F的闭包中。</p>
</li>
<li>
<p>完备性： F的闭包中的每一个函数依赖都可以由F出发根据Armstrong公理从F中导出。</p>
</li>
</ul>
<p><strong>由Armstrong公理导出的推理规则</strong>：</p>
<ul>
<li>
<p>合并律。若X-&gt;Y，X -&gt; Z，则X -&gt; YZ。</p>
<blockquote>
<p>增广律：XX-&gt;XY, XY-&gt;YZ</p>
</blockquote>
</li>
<li>
<p>分解律。若X -&gt; YZ ，则X -&gt; Y，X -&gt; Z。</p>
<blockquote>
<p>自反律：YZ-&gt;Y，YZ-&gt;Z</p>
</blockquote>
</li>
<li>
<p>伪传递律。若X -&gt; Y，WY -&gt; Z，则XW -&gt; Z。</p>
<blockquote>
<p>也就是XW-&gt;WY-&gt;Z</p>
</blockquote>
</li>
</ul>
<h4 id="求属性集的闭包">求属性集的闭包
</h4><p>F有闭包，属性集也有闭包！</p>
<p>属性集X的闭包X<del>F</del>^+^是它在 F^+^ 中<strong>能函数决定</strong>的属性的集合。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102200756107.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102200756107"
	
	
></p>
<p>引理一就是合并律与分解律。</p>
<p>引理二显然，总之要判定一个函数依赖是否可推导、是否成立，我们需要求出决定者的闭包中有没有依赖者，总之要会算X<del>F</del>^+^。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102201249838.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102201249838"
	
	
></p>
<p>把X放进闭包，然后从闭包里找F^+^中的左端项，把所有对应右端项放进去。迭代直到闭包结果不变或达到全集。</p>
<p>逻辑很直观很简单。下面是一个例子。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102201646599.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102201646599"
	
	
></p>
<p>同理，(AC)<del>F</del>^+^= ABCDE。</p>
<p>又因为(A)<del>F</del>^+^=A,(B)<del>F</del>^+^=BD, (C)<del>F</del>^+^=BCDE，所以AB和AC还满足最小性，都是码。</p>
<h4 id="更便捷地求码">更便捷地求码
</h4><p>求码有什么用？<strong>范式的判断</strong>需要知道<strong>码、主属性、非主属性</strong>。</p>
<p>我们按照求属性集闭包的方法来验证是不是码。但如果一个一个试就太麻烦了。</p>
<p>我们可以预先得到一些信息，来判断某属性一定是/不是码。</p>
<ul>
<li>L、N：只出现在左侧或不出现。或者直接说：<strong>不出现在右侧</strong>。这说明他一定不能被推导出来，所以<strong>必须是</strong>码。</li>
<li>R：只出现在右侧。它不决定任何属性，<strong>而且能被推导出来</strong>。因此<strong>一定不是</strong>码，否则加入它会破坏最小性。</li>
<li>LR：无法初步直接判定是否是码。</li>
</ul>
<p>如上题中，A是L类，D是R类，BCE是LR类。</p>
<p>所以只需要<strong>依次</strong>考虑：A、AB、AC、AE、ABC、ABE、ACE、ABCE。
首先(A)<del>F</del>^+^=A。</p>
<p>然后考虑(AB)<del>F</del>^+^=ABCDE、排除ABC,ABE,ABCE。</p>
<p>(AC)<del>F</del>^+^=ABCDE、排除ACE。</p>
<p>(AE)<del>F</del>^+^=AE。</p>
<p>所有情况考虑完毕。</p>
<p>所以候选码就是AB和AC。</p>
<h4 id="最小依赖集">最小依赖集
</h4><p>首先函数依赖集有<strong>等价性</strong>，等价性的定义就是其<strong>闭包结果相同</strong>。</p>
<p>很显然，我们要利用等价性，找到最好最方便的一个函数依赖集。</p>
<p>如果有这样一个规范的函数依赖集F，我们称之为<strong>最小依赖集（最小覆盖）</strong>：</p>
<ul>
<li>
<p>F中所有函数依赖的<strong>右部只有一个属性</strong>。</p>
</li>
<li>
<p>F有最小性：F中去掉任何一个函数依赖就不能与F等价。</p>
<blockquote>
<p>排除传递函数依赖。</p>
<p>A-&gt;B,B-&gt;C,A-&gt;C就不满足最小性。</p>
</blockquote>
</li>
<li>
<p>F中函数依赖的左侧也要满足最小性。</p>
<blockquote>
<p>排除部分函数依赖。</p>
<p>如果A-&gt;C，就不能有AB-&gt;C。</p>
</blockquote>
</li>
</ul>
<p>如何求出最小覆盖？</p>
<ol>
<li>用分解律分解为<strong>右侧单一属性</strong>。</li>
<li>验证每一条函数依赖<strong>是否可以去掉</strong>。</li>
<li>验证每一条函数依赖的<strong>决定者的子集</strong>是否也能推出<strong>依赖者</strong>。</li>
</ol>
<p>最小覆盖不是唯一的，和我们的验证（删除）顺序有关。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102204447208.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102204447208"
	
	
></p>
<h3 id="模式分解">模式分解
</h3><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102204804919.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102204804919"
	
	
></p>
<p>模式分解可以提高范式等级，但是并不是所有的模式分解都能够无损地保存原有信息。分解一损坏了SNO-&gt;DEPT与DEPT-&gt;HEAD，分解二损坏了DEPT-&gt;HEAD。</p>
<p><strong>分解的目标</strong>：</p>
<ul>
<li>
<p><strong>无损</strong>连接分解</p>
<blockquote>
<p>可以通过自然连接得到原表</p>
</blockquote>
</li>
<li>
<p>保持<strong>函数依赖</strong></p>
</li>
<li>
<p>达到<strong>更高级</strong>范式</p>
</li>
</ul>
<p>分解的基本要求：</p>
<ul>
<li>
<p>表之间的<strong>属性集没有包含关系</strong>，且<strong>并集为原表属性集</strong>。</p>
</li>
<li>
<p>函数依赖需要<strong>投影</strong>到各个表中。</p>
<blockquote>
<p>投影也就是左侧有点</p>
</blockquote>
</li>
</ul>
<h4 id="判别模式分解的无损连接性">判别模式分解的无损连接性
</h4><h5 id="填表法">填表法
</h5><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102205807448.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102205807448"
	
	
></p>
<p>第一张表：</p>
<p>​	如果<strong>i列</strong>的属性在<strong>j行的属性集</strong>中，填写<strong>a<del>i</del></strong>，如果不在就填写<strong>b<del>ji</del></strong></p>
<p>后续的表：</p>
<p>​	验证每一条函数依赖是否被违反。如果被违反，也即决定者相同、依赖者不同，就将依赖者统一，如果<strong>有a<del>i</del>就定为a<del>i</del></strong>，否则为<strong>其中行数最小</strong>的值。</p>
<blockquote>
<p>注意！</p>
<ul>
<li>相等的值要永远保持相等，也就是如果A和B统一过，那么B和C统一时应该将ABC一起统一。</li>
<li>用过的依赖关系需要全程发挥作用。</li>
</ul>
</blockquote>
<p><strong>如果某行达成了a<del>1</del>a<del>2</del>……a<del>n</del>，说明是无损连接。</strong></p>
<h5 id="定理法">定理法
</h5><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102211309924.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102211309924"
	
	
></p>
<p>如果拆为了U1,U2两个属性集。如果U1与U2的交集能够<strong>函数决定</strong>U1或U2，那么就是无损连接。</p>
<p>原理如下：U1交U2-&gt;U1，那么可以将b<del>22</del>变为a<del>2</del>，从而形成a<del>1</del>a<del>2</del>a<del>3</del>行。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102211539163.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102211539163"
	
	
></p>
<p>解释起来也不难。</p>
<p><strong>用于自然连接的公共属性是分表的候选码</strong>，说明是无损连接。</p>
<h4 id="模式分解中函数依赖的保持">模式分解中函数依赖的保持
</h4><p>判定方法很简单。如果投影过去的各个依赖集<strong>并起来</strong>能和原依赖集<strong>等价</strong>（也就是闭包相等），就说该分解保持函数依赖。</p>
<h4 id="常用的模式分解算法">常用的模式分解算法
</h4><h5 id="达到3nf且保持函数依赖的分解算法">达到3NF且保持函数依赖的分解算法
</h5><p>这个算法仅满足两个条件，不保证无损连接性。</p>
<ol>
<li>求出最小依赖集F</li>
<li>找到不在F中出现的属性，单独构成一个关系模式，剩余属性记为U。</li>
<li>若有X-&gt;A且XA=U，说明我已找到<strong>满足3NF</strong>的码X, 非主属性集A。算法终止。</li>
<li>否则对F根据<strong>相同左部</strong>的原则分组：每一组函数依赖所涉及的全部属性记为U<del>i</del>。若有包含关系，取最大的组合。最后得到的组合即为分解结果。</li>
</ol>
<p>不在F中出现的属性（N类属性）不能进行自然连接。因此不能保证无损分解。</p>
<h5 id="达到3nf且同时保持无损连接与函数依赖的分解算法">达到3NF且同时保持无损连接与函数依赖的分解算法
</h5><p>针对上一步求出的结果，观察是否有某个关系模式保留了<strong>原表的候选码</strong>。</p>
<p>如果有，该结果即为无损连接。</p>
<p>如果没有，就<strong>新增一个关系模式</strong>，其属性集为<strong>原表</strong>的一个<strong>候选码</strong>，其不含函数依赖（候选码内部肯定没有函数依赖，否则违反最小性）。大家可以依靠这个表实现无损连接。</p>
<h5 id="达到bcnf且保持无损连接的分解算法">达到BCNF且保持无损连接的分解算法
</h5><p>该算法<strong>可能无法保证</strong>函数依赖。</p>
<ol>
<li>检查每个关系模式是不是BCNF。</li>
<li>如果存在某表不是BCNF，则是因为存在函数依赖X-&gt;A且X不是码。所以将该表U拆为XA与U-A。（这一步保证了无损连接）</li>
</ol>
<p>算法必能终止，因为只含两个属性的关系模式一定是BCNF。</p>
<blockquote>
<p>推荐的做法：</p>
<p>先用3NF的，针对3NF的结果再去做这个算法，更有可能保存函数依赖。</p>
</blockquote>
<h2 id="数据库设计">数据库设计
</h2><p>数据库设计的关键是<strong>构造合理的数据模型</strong>。</p>
<p>数据库设计的特点：</p>
<ul>
<li>
<p>数据库设计与<strong>硬件、软件</strong>等紧密相关。</p>
</li>
<li>
<p>数据库设计要把<strong>结构</strong>（数据）设计和<strong>行为</strong>（处理）设计密切结合起来。</p>
</li>
</ul>
<p>设计方法：手工试凑方法、规范化设计方法。</p>
<p>规范化设计的特点：<strong>分步进行</strong>、<strong>反复性</strong>、<strong>试探性</strong>。</p>
<h3 id="数据库的生命周期">数据库的生命周期
</h3><ul>
<li>
<p><strong>需求分析</strong></p>
</li>
<li>
<p><strong>概念结构设计</strong></p>
</li>
<li>
<p><strong>逻辑结构设计</strong></p>
</li>
<li>
<p><strong>物理结构设计</strong></p>
</li>
<li>
<p><strong>数据库的实施</strong></p>
</li>
<li>
<p><strong>数据库运行与维护</strong></p>
</li>
</ul>
<h4 id="需求分析">需求分析
</h4><p>需求分析的任务是通过详细调查现实世界要处理的对象（组织、部门、企业等），充分了解原系统（手工系统或计算机系统）的工作情况，明确用户的各种需求，并预测系统今后可能的扩充和改变，然后在此基础上确定新系统的功能。</p>
<p>调查的重点是<strong>数据</strong>和<strong>处理</strong> ，包括：</p>
<ul>
<li><strong>信息要求</strong>，指用户需要从数据库中获得的信息的内容与性质。从中可以导出数据要求。</li>
<li><strong>处理要求</strong>，指用户要完成什么处理功能，对处理的响应时间和处理方式的要求。</li>
<li><strong>安全性与完整性</strong>的要求</li>
</ul>
<p><strong>数据字典</strong>是系统中各类<strong>数据描述</strong>的集合，是进行详细的数据收集和数据分析所获得的主要成果。包括：数据项、数据结构、数据流、数据存储、处理过程。</p>
<h4 id="概念结构设计">概念结构设计
</h4><p>将需求分析得到的<strong>用户需求</strong>抽象成为<strong>信息结构</strong>即<strong>概念模型</strong>的过程就是概念结构设计。</p>
<p><strong>应用定义</strong>的目的是确定最终数据库<strong>支持哪些应用</strong>系统。应用领域的逻辑模型是应用定义的基础。</p>
<p><strong>信息定义</strong>的目的是确定最终数据库<strong>需要存储哪些</strong>信息。信息的定义也以应用领域的逻辑模型为基础。</p>
<p><strong>设计策略</strong>：</p>
<ul>
<li>自顶向下</li>
</ul>
<p>首先定义<strong>全局概念</strong>结构的框架，然后逐步细化。</p>
<ul>
<li>自底向上（常用）</li>
</ul>
<p>首先定义<strong>各局部应用</strong>的概念结构，然后将它们集成起来，得到全局概念结构。</p>
<ul>
<li>逐步扩张</li>
</ul>
<p>首先定义<strong>最重要的核心概念</strong>结构，然后向外扩充，以滚雪球的方式<strong>逐步生成</strong>其他概念结构，直至总体概念结构。</p>
<ul>
<li>混合策略</li>
</ul>
<p>将自顶向下和自底向上相结合，用<strong>自顶向下</strong>策略设计一个全局概念结构的框架，以它为骨架集成用<strong>自底向上</strong>策略设计的各局部概念结构。</p>
<p><strong>视图综合设计方法</strong>分为两步：</p>
<ol>
<li>
<p>设计局部概念结构</p>
</li>
<li>
<p>把局部概念结构合并为一个全局概念结构。</p>
</li>
</ol>
<h5 id="局部概念结构">局部概念结构
</h5><p><strong>局部视图设计步骤</strong></p>
<ol>
<li>
<p>选择局部应用</p>
</li>
<li>
<p>逐一设计分E-R图</p>
</li>
<li>
<p>确定局部实体</p>
</li>
<li>
<p>确定局部实体之间的联系</p>
</li>
<li>
<p>构造局部E-R图</p>
</li>
</ol>
<p>局部视图设计的关键在于<strong>实体和属性</strong>的正确划分。其主要手段为：<strong>分类</strong>、<strong>聚集</strong>、<strong>概括</strong>。</p>
<ul>
<li>
<p>属性不能再具有需要描述的性质。属性必须是不可分的数据项，<strong>不能包含其他属性</strong>。</p>
</li>
<li>
<p><strong>属性不能与其他实体</strong>具有联系，即E-R图中所表示的联系都是实体之间的联系。</p>
</li>
</ul>
<p>职称由<strong>属性</strong>升级为<strong>实体</strong>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260102224225495.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260102224225495"
	
	
></p>
<h5 id="全局概念模式合成">全局概念模式合成
</h5><p>E-R图之间的集成：</p>
<ul>
<li>一次集成</li>
<li>逐步集成（两两合并）</li>
</ul>
<p>集成的步骤：</p>
<ul>
<li>合并：<strong>解决冲突</strong>并合并</li>
<li>修改和重构：<strong>消除冗余</strong></li>
</ul>
<p>冲突的种类：</p>
<ul>
<li><strong>命名冲突</strong>
<ul>
<li>同名异义</li>
<li>异名同义</li>
</ul>
</li>
<li><strong>结构冲突</strong>。结构冲突是模式结构的冲突。
<ul>
<li>在一个局部ER图中被表示为一个<strong>实体</strong>，而在另一个局部ER中却被表示为一个<strong>属性或联系</strong>。</li>
<li>同一实体在不同的局部ER图中所包含的<strong>属性个数和属性的排列次序</strong>不完全相同。可以取全集来解决。</li>
</ul>
</li>
<li><strong>值域冲突</strong>。属性域冲突，即属性的<strong>类型</strong>、<strong>取值范围</strong>或<strong>取值集合</strong>不同。（如取值单位）</li>
<li><strong>约束冲突</strong>。两个局部模式在同一个概念上<strong>定义了不同的约束</strong>。</li>
</ul>
<p>消除冗余：</p>
<p>在<strong>初步ER图</strong>中，可能存在一些冗余的数据和实体间冗余的联系。</p>
<blockquote>
<p>冗余的数据是指可<strong>由基本数据导出</strong>的数据。</p>
<p>冗余的联系是指可<strong>由其他联系导出</strong>的联系。</p>
</blockquote>
<p>消除了冗余后的初步ER图称为<strong>基本ER图</strong>。</p>
<p>消除冗余主要采用<strong>分析</strong>方法，即以<strong>数据字典</strong>和<strong>数据流图</strong>为依据，根据数据项之间的逻辑关系来消除冗余。</p>
<h5 id="事务设计">事务设计
</h5><p>数据库设计的目的是<strong>支持各种事务的运行</strong>。</p>
<p>事务可以分为三类：<strong>数据查询型事务，数据更新型事务，混合型事务</strong>。</p>
<h4 id="逻辑结构设计">逻辑结构设计
</h4><p>任务：<strong>E-R图转关系模式</strong></p>
<blockquote>
<p>把概念结构设计阶段设计好的<strong>基本E-R图</strong>转换为与选用的DBMS所支持的数据模型相符合的<strong>逻辑结构</strong>。</p>
</blockquote>
<p>目标：</p>
<ul>
<li>
<p>满足用户的<strong>完整性和安全性</strong>要求。</p>
</li>
<li>
<p>动态关系至少满足<strong>第三范式</strong>，静态关系至少满足<strong>第一范式</strong>。</p>
<blockquote>
<p>动态：更新型，静态：查询型</p>
</blockquote>
</li>
<li>
<p>能够在<strong>逻辑级上高效率</strong>地支持各种数据库事务的运行。</p>
</li>
<li>
<p><strong>存储空间利用率</strong>高。</p>
</li>
</ul>
<p>设计步骤：</p>
<ul>
<li>形成初始关系数据库模式</li>
<li>关系模式规范化（3NF、1NF）</li>
<li>关系模式优化</li>
<li>定义关系上的完整性和安全性约束</li>
<li><strong>子模式</strong>定义（为每一类用户定义外模式）</li>
<li>性能估计</li>
</ul>
<h5 id="形成初始关系数据库模式">形成初始关系数据库模式
</h5><p>直接由概念结构设计的结果生成关系数据库模式。</p>
<p>直接把E-R图中的实体、实体间的联系等变换为关系模式。</p>
<h6 id="实体型的转换">实体型的转换
</h6><p>直接将一个实体型转化为一个关系模式。</p>
<p>实体的属性就是关系的属性，实体的码就是关系的码。</p>
<h6 id="实体间联系的转换">实体间联系的转换
</h6><p><strong>1：1联系</strong></p>
<ul>
<li>独立关系模式：属性为与该联系相连的各实体的码以及联系本身的属性。<strong>每个实体的码</strong>均是该关系的候选码。</li>
<li>合并进其中一个关系模式：该关系模式的属性中加入<strong>另一个关系模式的码</strong>和<strong>联系本身的属性</strong>。</li>
</ul>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105154614036.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105154614036"
	
	
></p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105154905987.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105154905987"
	
	
></p>
<p><strong>1：N联系</strong></p>
<ul>
<li>独立关系模式：属性为与该联系相连的各实体的码以及联系本身的属性。<strong>N端实体的码</strong>均是该关系的候选码。</li>
<li>合并进<strong>N端</strong>关系模式：N端关系模式的属性中加入<strong>1端关系模式的码</strong>和<strong>联系本身的属性</strong>。</li>
</ul>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105154955484.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105154955484"
	
	
></p>
<p><strong>M：N联系</strong></p>
<p>只能转换为<strong>一个独立的关系模式</strong>。</p>
<p>与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而<strong>关系的码为各实体码的组合</strong>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105155119241.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105155119241"
	
	
></p>
<p><strong>三个或三个以上实体</strong>间的一个多元联系</p>
<p>只能转换为<strong>一个独立的关系模式</strong>。</p>
<p>与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而<strong>关系的码为各实体码的组合</strong>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105155144215.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105155144215"
	
	
></p>
<h5 id="关系模式的规范化">关系模式的规范化
</h5><p>确定函数依赖。消除冗余联系。进行规范化处理。</p>
<p>分析这些关系模式对于这样的应用环境<strong>是否合适</strong>，是否要对某些模式进行<strong>合并或分解</strong>。</p>
<h5 id="关系模式的优化">关系模式的优化
</h5><p>在数据库设计中，<strong>并非关系的规范化程度越高越好</strong>。</p>
<p>规范化需要<strong>模式分解</strong>，查询时<strong>连接操作更多</strong>，影响<strong>系统效率</strong>。因此必须根据应用特点对数据库设计进行优化，对关系模式进行必要的分解，提高<strong>数据操作的效率</strong>和<strong>存储空间的利用率</strong>。</p>
<p>常用的两种分解方法是<strong>水平分解</strong>和<strong>垂直分解</strong>。</p>
<h6 id="水平分解-减少行数">水平分解 减少行数
</h6><p>是把<strong>关系的元组</strong>分为若干子集合，每个子集合定义为一个子关系。</p>
<ul>
<li>
<p>高频数据：根据<strong>80/20原则</strong>， 可以把经常使用的那一部分<strong>数据</strong>分解出来作为一个关系，其他数据作为另一个关系。</p>
</li>
<li>
<p>事务专用数据：如果关系R上具有n个<strong>存取数据不相交</strong>的事务，则R可以分解为少于或等于n个子关系。</p>
</li>
</ul>
<h6 id="垂直分解-减少列数">垂直分解 减少列数
</h6><p>是把关系模式<strong>R的属性</strong>分解为若干子集合，形成若干子关系模式。</p>
<p><strong>原则</strong>：<strong>经常在一起使用的属性</strong>从R中分解出来形成一个子关系模式。</p>
<blockquote>
<p>如学生表信息很多，可以把学号与姓名单独分出来。</p>
</blockquote>
<p>垂直分解必须确保<strong>无损连接性和保持函数依赖</strong>。</p>
<h6 id="逆规范化--合并关系">逆规范化  合并关系
</h6><p><strong>连接操作代价很高</strong>，是造成关系数据库<strong>低效的主要原因之一</strong>。</p>
<p>如果<strong>经常需要</strong>对多个关系进行连接操作，且<strong>大多数操作为查询操作，更新很少</strong>，则可以考虑将这些关系<strong>合并</strong>为一个关系。</p>
<h5 id="设计子模式">设计子模式
</h5><p>设计用户外模式。由于用户外模式与全局模式是<strong>相对独立</strong>的，因此定义用户外模式时可以注重考虑用户的习惯和方便。</p>
<h5 id="数据库物理设计">数据库物理设计
</h5><p>设计<strong>内模式</strong>。</p>
<p>数据库在<strong>物理设备上的存储结构和存取方法</strong>称为数据库的物理结构。</p>
<p>方法：</p>
<ul>
<li>了解应用的类型和特点</li>
<li>了解所用的RDBMS提供了哪些<strong>存取方法和存储结构</strong></li>
</ul>
<h6 id="数据库的存取方法">数据库的存取方法
</h6><p><strong>索引存取方法</strong></p>
<p>应为其建立索引：</p>
<ul>
<li>经常在<strong>查询条件</strong>中出现的属性</li>
<li>经常作为最大值和最小值等<strong>聚集函数参数</strong>的属性</li>
<li>经常在<strong>连接条件</strong>中出现的属性</li>
</ul>
<p><strong>聚簇存取方法</strong></p>
<p>聚簇存取方法将<strong>相关的数据存放在连续的物理块</strong>中。</p>
<p><strong>HASH存取方法</strong></p>
<p>如果一个关系的属性主要出现在<strong>相等比较条件</strong>中，且满足以下两个条件之一，则可以使用HASH存取方法：</p>
<ul>
<li>
<p>一个关系的<strong>大小可以预知</strong>，而且不变。</p>
</li>
<li>
<p>关系的大小动态改变，但数据库管理系统提供了<strong>动态HASH存取</strong>方法</p>
</li>
</ul>
<h6 id="数据库的存储结构">数据库的存储结构
</h6><ul>
<li>
<p>确定数据的存放位置</p>
<blockquote>
<p>根据应用情况将数据的<strong>易变部分与稳定部分</strong>、<strong>存取频率</strong>高与低的部分分开存放。</p>
</blockquote>
</li>
<li>
<p>确定系统配置</p>
</li>
</ul>
<h5 id="数据库的实施">数据库的实施
</h5><ul>
<li>
<p>数据的载入和应用程序的调试</p>
</li>
<li>
<p>数据库的试运行（功能和性能）</p>
</li>
</ul>
<h5 id="数据库的运行和维护">数据库的运行和维护
</h5><ul>
<li>
<p>数据库的转储和恢复</p>
</li>
<li>
<p>数据库的安全性、完整性控制</p>
</li>
<li>
<p>数据库的性能监督、分析和改造</p>
</li>
<li>
<p>数据库的重组织和重构造</p>
</li>
</ul>
<h2 id="查询优化">查询优化
</h2><p>本单元视角引向：作为<strong>DBMS的设计者</strong>，从数据库实现而非应用的角度，我们应该关注的内容。我们要实现关系操作的“非过程化”，本单元则对该过程进行简述。</p>
<ul>
<li>
<p>降低对用户的要求，方便了用户的使用</p>
</li>
<li>
<p>能够取得更好的优化效果</p>
<blockquote>
<p>DBMS掌握的信息更丰富，经验更丰富，优化更到位</p>
</blockquote>
</li>
</ul>
<p><strong>查询处理的基本步骤</strong></p>
<ul>
<li>语法分析与翻译</li>
<li>优化</li>
<li>执行查询语句</li>
</ul>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105162818751.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105162818751"
	
	
></p>
<p>查询树：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105163011343.png"
	
	
	
	loading="lazy"
	
		alt="查询树"
	
	
></p>
<p>执行计划：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105163101767.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105163101767"
	
	
></p>
<h3 id="基本运算的实现">基本运算的实现
</h3><p>每一基本的代数运算都有<strong>多种不同的实现算法</strong>。</p>
<p>适用于不同的情况，其执行代价不同。</p>
<h4 id="选取">选取
</h4><p><strong>全表扫描方法</strong>：依次访问表的每一个块，对于每一个元组，测试它是否满足选择条件。</p>
<blockquote>
<p>效率低，但对关系的存储方式<strong>没有要求，不需要索引</strong>。适用于任何选择条件。</p>
</blockquote>
<p><strong>折半扫描</strong>: 对于按某一属性排序的文件，且选择条件是该属性上的<strong>等值比较</strong>方法，可以使用折半的方法扫描文件。</p>
<blockquote>
<p>效率高，但<strong>需要有序文件。</strong></p>
</blockquote>
<p><strong>索引扫描</strong>：对于在选择条件的属性上建有索引的表，可以采用访问索引，根据索引项的指示去访问数据元组的方法。</p>
<ul>
<li>无序索引：访问满足<strong>等值条件</strong>的元组</li>
<li>有序索引：访问<strong>满足范围</strong>查找条件的一系列元组</li>
</ul>
<blockquote>
<p>效率高，<strong>必须建立对应索引</strong>。</p>
</blockquote>
<h4 id="连接">连接
</h4><ul>
<li>
<p><strong>嵌套循环方法</strong></p>
</li>
<li>
<p><strong>排序-合并方法</strong></p>
<blockquote>
<p>先排序再折半查找</p>
</blockquote>
</li>
<li>
<p><strong>索引连接方法</strong></p>
</li>
<li>
<p><strong>HASH join方法</strong></p>
</li>
</ul>
<h3 id="查询代价的度量">查询代价的度量
</h3><p>总代价=**I/O代价+**CPU代价+通信开销</p>
<p>I/O代价占绝大部分。</p>
<p>其度量方式为：I/O块数或者I/O的次数。</p>
<blockquote>
<p>不是时间：影响时间的相关因素太多了，不适合作为查询本身的代价度量。</p>
</blockquote>
<p>一个重要因素：主存中<strong>缓冲区的大小M</strong></p>
<ul>
<li>最好，所有的数据可以读入到缓冲区中</li>
<li>最坏，缓冲区只能容纳少量数据块，大约每个关系一块</li>
</ul>
<p>连续测试两次，第二次更快很有可能是缓冲区导致的！</p>
<h3 id="关系代数等价变换">关系代数等价变换
</h3><p>若产生的结果关系具有相同的属性集和元组集，则称<strong>两个表达式等价</strong>。</p>
<ol>
<li>连接、笛卡尔积的交换律</li>
<li>连接、笛卡尔积的结合律</li>
<li>投影的串接定律</li>
<li>选择的串接定律</li>
<li>选择与投影的交换律</li>
<li>选择与笛卡尔积的交换律</li>
<li>选择与并的分配律</li>
<li>选择与差的分配律</li>
<li>投影与笛卡尔积的分配律</li>
<li>投影与并的分配律</li>
</ol>
<h3 id="查询优化的一般准则">查询优化的一般准则
</h3><ul>
<li>
<p><strong>选择运算应尽可能先做</strong>。目的：减小<strong>中间关系</strong>。</p>
</li>
<li>
<p>在执行连接操作前对文件<strong>适当进行预处理</strong>。如排序、在连接属性上建立索引。</p>
</li>
<li>
<p><strong>投影运算和选择运算</strong>同时做。目的：避免<strong>重复扫描</strong>关系。</p>
</li>
<li>
<p>把<strong>投影运算与其前面或后面的双目运算</strong>结合起来。目的：减少扫描关系的遍数。</p>
</li>
<li>
<p>选择＋笛卡尔积-&gt;连接</p>
</li>
<li>
<p>找出<strong>公共子表达式</strong></p>
</li>
</ul>
<p>优化实操：</p>
<p>初始查询树</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105171622199.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105171622199"
	
	
></p>
<p>优先选取</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105171628744.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105171628744"
	
	
></p>
<p>连接替代笛卡尔积</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105171633763.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105171633763"
	
	
></p>
<p>优先执行小连接</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105171637096.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105171637096"
	
	
></p>
<p>投影去掉无关属性</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105171640897.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105171640897"
	
	
></p>
<h2 id="数据库恢复">数据库恢复
</h2><h3 id="事务">事务
</h3><p>事务是用户定义的一个数据库<strong>操作序列</strong>构成，这些操作<strong>要么全做，要么全不做</strong>，是一个<strong>不可分割</strong>的工作单位。</p>
<blockquote>
<p>事务与应用程序是两个概念，一般来说，一个应用程序可以包含多个事务，事务是更底层的概念。</p>
</blockquote>
<p>事务显式定义：事务的<strong>开始与结束可以由用户显式控制</strong>。</p>
<p>事务隐式定义：如果用户没有显式定义，则由DBMS<strong>自动划分事务</strong>。</p>
<h4 id="事务的基本流程">事务的基本流程
</h4><p>事务以<strong>Begin transaction开始</strong>，以 **Commit work 或 Rollback work **结束。</p>
<p>Commit work表示提交，<strong>事务正常结束</strong>。</p>
<p>Rollback work表示事务非正常结束，<strong>撤消事务已做的操作，回滚到事务开始时状态</strong>。</p>
<h4 id="事务的特性-acid">事务的特性 ACID
</h4><p><strong>原子性(Atomicity)</strong></p>
<p>事务是数据库的逻辑工作单位，事务中包括的诸操作<strong>要么全做，要么全不做</strong>。</p>
<p><strong>一致性(Consistency)</strong></p>
<p>事务执行的结果应当使数据库从一个<strong>一致性状态</strong>转变为另一个<strong>一致性状态</strong>。</p>
<p><strong>隔离性(Isolation)</strong></p>
<p>一个事务的执行<strong>不能被其它事务干扰</strong>。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，<strong>并发执行</strong>的各个事务之间不能相互干扰。</p>
<p><strong>持久性(Durability)</strong></p>
<p>一个事务一旦提交之后，它对数据库的影响<strong>必须是永久</strong>的。事务提交后，系统<strong>发生故障不能改变事务的持久性</strong>。也就是发生故障了必须恢复。</p>
<h3 id="数据库恢复子系统">数据库恢复子系统
</h3><p>数据库管理系统必须具有把数据库从<strong>错误状态</strong>恢复到<strong>某一已知</strong>正确状态的功能，这就是数据库的恢复。</p>
<p>数据库恢复是通过<strong>数据库恢复子系统</strong>完成的。</p>
<p>核心目标：</p>
<ol>
<li>保护事务的原子性。</li>
<li>发生故障后，数据库仍能恢复到正确状态。</li>
</ol>
<h3 id="数据库故障">数据库故障
</h3><p><strong>事务内部的故障</strong>包括可预期的和不可预期的。</p>
<ul>
<li>可预期的是指可以通过<strong>事务程序本身</strong>发现和处理的故障。</li>
<li>不可预期的错误是指那些不能由应用程序处理的<strong>事务故障</strong>，如死锁，运算溢出，违反完整性规则等。</li>
</ul>
<p><strong>系统故障</strong></p>
<p>系统故障是指造成<strong>系统停止运行</strong>的任何事情，使得系统要重新启动。如硬件错误，操作系统故障，停电等。</p>
<p>这类故障影响<strong>正在运行的所有事务</strong>，<strong>但不会破坏数据库</strong>。</p>
<p><strong>介质故障</strong></p>
<p>介质故障指<strong>外存</strong>故障，如磁盘损坏，瞬时强磁场干扰等。</p>
<p>这类故障将<strong>破坏全部或部分数据库</strong>，并<strong>影响正在存取这部分数据的所有事务</strong>。</p>
<p><strong>计算机病毒</strong></p>
<p>计算机病毒是一种<strong>人为的破坏或故障</strong>，已成为数据库系统的主要威胁之一。</p>
<h3 id="恢复技术">恢复技术
</h3><p><strong>数据库恢复的基本原理为冗余</strong>。冗余包括<strong>数据</strong>的冗余与<strong>操作</strong>的冗余。</p>
<p>如果数据库中任何一部分数据被破坏或处于不正确的状态，则可以通过存储在系统别处的冗余数据来重建。</p>
<h4 id="建立冗余">建立冗余
</h4><h5 id="数据转储数据冗余">数据转储——数据冗余
</h5><p>DBA定期地将整个数据库<strong>复制到磁带或其它存储设备上</strong>保存起来的过程。</p>
<p>这些备用的数据文本称为<strong>后备副本或后援副本</strong>。</p>
<p>转储状态分为<strong>静态转储</strong>和<strong>动态转储</strong>。</p>
<h6 id="静态转储冷备份">静态转储——冷备份
</h6><p>静态转储是在系统中<strong>无事务运行时进行</strong>的转储操作。</p>
<p>新的事务必须等待转储结束才能执行，降低了数据库的可用性。</p>
<h6 id="动态转储热备份">动态转储——热备份
</h6><p>动态转储是指<strong>转储期间允许</strong>对数据库进行存取或修改，即转储和用户事务可以<strong>并发执行</strong>。</p>
<p>必须把转储期间各事务<strong>对数据库的修改记录</strong>下来，这样才能保证把数据库恢复到某一时刻的一致状态。</p>
<p>转储方式又分为<strong>海量转储</strong>和<strong>增量转储</strong>。</p>
<ul>
<li>
<p>海量转储指每次转储<strong>全部数据库</strong>。</p>
<ul>
<li>慢，但是每次的数据都能直接用。</li>
</ul>
</li>
<li>
<p>增量转储指每次只转储上一次转储后更新过的数据。</p>
<ul>
<li>快，但是需要严格按次序恢复，不能直接保证正确性。</li>
</ul>
</li>
</ul>
<p>从而有：<strong>动态海量转储 静态海量转储 动态增量转储 静态增量转储</strong>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105181723346.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105181723346"
	
	
></p>
<h5 id="登记日志文件操作冗余">登记日志文件——操作冗余
</h5><p>日志文件是用来记录事务对数据库的<strong>更新</strong>操作的文件。</p>
<blockquote>
<p>不是记录所有操作！查询不会导致数据库变化。</p>
</blockquote>
<p>日志文件两种格式：以<strong>记录为单位</strong>和以<strong>数据块为单位</strong>。</p>
<p>以<strong>记录</strong>为单位：内容包括各个事务的<strong>所有更新操作</strong>、<strong>开始标记</strong>、<strong>结束标记</strong>。</p>
<ul>
<li>事务标识、操作的类型、操作对象、更新前数据的旧值、更新后数据的新值</li>
</ul>
<p>以<strong>数据块</strong>为单位：内容包括<strong>事务标识</strong>以及<strong>更新前和更新后的数据块</strong>。</p>
<blockquote>
<p>为什么不仅记录操作还要记录值？</p>
<p>只依赖逆操作可能有问题：可能操作做了，日志记录了，但值还没改就故障了。</p>
</blockquote>
<p><strong>事务故障和系统故障恢复必须使用日志文件。</strong></p>
<p><strong>在动态转储方式中必须建立日志文件</strong>。</p>
<p>在静态转储方式中，也<strong>可以建立</strong>日志文件。当数据库发生故障（<strong>介质故障</strong>）时，用后援副本恢复过去版本的数据，然后利用日志文件重做已完成的事务，把数据库恢复到正确状态。</p>
<p><strong>原则</strong>：</p>
<ul>
<li>登记的次序<strong>严格按并发事务执行</strong>的时间顺序。</li>
<li>必须<strong>先写日志文件，后写数据库</strong>。</li>
</ul>
<h4 id="恢复策略">恢复策略
</h4><h5 id="事务故障">事务故障
</h5><p>事务故障的恢复是由<strong>系统自动完成</strong>的。</p>
<p><strong>反向扫描</strong>日志文件，依次将日志记录中的**“更新前的值”<strong>写入数据库，直到读到该事务的</strong>开始标志**。</p>
<h5 id="系统故障">系统故障
</h5><p>未完成的事务对数据库的更新**可能（所以用值而非逆操作）**已经写入数据库。</p>
<p>已提交事务对数据库的更新**可能（所以用值而非操作）**还留在缓冲区还没来得及写入数据库。</p>
<p>要<strong>撤销未完成的事务，重做已完成的事务。</strong></p>
<ol>
<li>
<p><strong>正向扫描</strong>整个日志文件，故障前已完成的事务放入<strong>REDO</strong>，故障后已完成的事务放入<strong>UNDO</strong>。</p>
</li>
<li>
<p>反向执行UNDO，依次将日志记录中的**“更新前的值”**写入数据库。</p>
</li>
<li>
<p>正向执行REDO，依次将日志记录中的**“更新后的值”**写入数据库。</p>
</li>
</ol>
<h5 id="介质故障">介质故障
</h5><p>介质故障将全部或部分地<strong>破坏数据库甚至是日志文件</strong>。</p>
<ol>
<li>
<p>装入最新的数据库后备副本，将数据库恢复到一致状态。</p>
<blockquote>
<p>对于动态转储的副本，还需要装入转储开始时刻的日志文件副本。</p>
</blockquote>
</li>
<li>
<p>装入转储以后的日志文件副本，重做已经完成的事务。</p>
</li>
</ol>
<h3 id="具有检查点的恢复技术">具有检查点的恢复技术
</h3><p>事务太多了。常常REDO了大量已经写到数据库中的事务。所以已完成的事务无需管理。</p>
<p>在日志文件中增加一类新的记录：<strong>检查点记录</strong>，增加一个<strong>重新开始文件</strong>。</p>
<blockquote>
<p>检查点记录也是日志的一条。</p>
</blockquote>
<p>检查点记录的内容包括：</p>
<ul>
<li>建立检查点时刻所有<strong>正在执行的事务</strong>清单。</li>
<li>这些事务最近一个<strong>日志记录</strong>的地址。</li>
</ul>
<p>这两个信息表示了恢复时建议处理的<strong>事务</strong>和建议开始扫描的<strong>日志</strong>地址。</p>
<p>重新开始文件用来记录<strong>各个检查点</strong>记录本身在日志文件中的地址。</p>
<h4 id="检查点记录操作">检查点记录操作
</h4><p>将当前日志缓存中的所有<strong>日志记录写入磁盘</strong>的日志文件上。</p>
<p>在日志文件上<strong>写入一个检查点</strong>记录，其内容包括多个事务与一个日志地址。</p>
<p>将当前数据缓存的所有<strong>数据记录写入磁盘</strong>的数据库中。<strong>（保证数据已存入）</strong></p>
<p>把<strong>检查点记录在日志文件中地址</strong>写入一个重新开始文件。</p>
<blockquote>
<p>当事务T在一个检查点之前提交，T对数据库所做的修改一定已经写入数据库。</p>
<p>这样在进行恢复处理时，没有必要对事务T进行REDO操作。</p>
</blockquote>
<h4 id="恢复">恢复
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260105190154979.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260105190154979"
	
	
></p>
<ol>
<li>
<p>在<strong>重新开始文件</strong>中找到<strong>最后一个检查点记录</strong>在日志文件中的地址，由该地址找到最后一个检查点记录。</p>
</li>
<li>
<p>由该检查点记录得到<strong>检查点建立时刻所有正在运行的事务</strong>清单，放入UNDO-LIST</p>
</li>
<li>
<p>从<strong>检查点开始正向扫描</strong>日志文件</p>
<ul>
<li>如果有新开始的事务，放入UNDO-LIST</li>
<li>如果有提交的事务 ，<strong>从UNDO-LIST队列移入到REDO-LIST队列</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>废话一堆，其实就是还是已提交的REDO，未提交的UNDO。只不过从检查点开始。</p>
</blockquote>
<ol start="4">
<li>直到文件结束，然后对UNDO-LIST中的执行UNDO，对REDO-LIST中的执行REDO。</li>
</ol>
<h3 id="数据库镜像">数据库镜像
</h3><p>根据DBA要求，自动把整个数据库或其中的关键数据<strong>复制到另一个磁盘上</strong>。每当主数据库更新时，DBMS<strong>自动把更新后的数据复制过去</strong>，即DBMS自动保证镜像数据与主数据的一致性。</p>
<p>这样，一旦发生介质故障：</p>
<ul>
<li>可以<strong>继续由镜像磁盘提供服务。</strong></li>
<li>可以<strong>直接通过镜像磁盘进行数据库恢复</strong>。</li>
</ul>
<p>在没有故障时，镜像磁盘还可以<strong>提供一定的并行性</strong>。</p>
<h2 id="并发控制">并发控制
</h2><h3 id="优势">优势
</h3><ol>
<li>
<p>一个事务由不同的步骤组成，所涉及的<strong>系统资源</strong>也不同。这些步骤可以并发执行，以提高系统的吞吐量，改善系统的资源的利用率。</p>
</li>
<li>
<p>系统中存在着周期不等的各种事务，串行会导致难以预测的时延。采用并发会减少<strong>平均响应时间</strong>，特别是改善短事务的响应时间。</p>
</li>
</ol>
<h3 id="问题">问题
</h3><p>当多个事务并发执行的时候，有可能会<strong>相互影响</strong>，从而读取或者存储不正确的数据，破坏<strong>数据库的一致性</strong>。</p>
<p>造成并发执行事务问题的<strong>原因</strong>是：</p>
<ul>
<li>多个事务同时存取<strong>同一个数据集合</strong></li>
<li>并且其中至少有一个事务对该数据集合<strong>进行了更新</strong>操作</li>
</ul>
<h4 id="丢失修改">丢失修改
</h4><p>两个事务T1和T2读入同一数据并修改， T2提交的结果<strong>破坏了T1提交</strong>的结果，导致T1的修改被丢失。</p>
<blockquote>
<p>写后写，前一次写的结果被覆盖。</p>
</blockquote>
<h4 id="不可重复读">不可重复读
</h4><p>事务T1读取某一数据后，事务T2对其做了修改，当事务T1<strong>再次读取</strong>该数据时，得到与前一次不同的值。</p>
<p>破坏了事务的<strong>隔离性</strong>，一个事务进行过程中遭遇了其他事务的干扰。</p>
<blockquote>
<p>读后写，再读就不一样了。</p>
</blockquote>
<p><strong>不可重复读之幻影行</strong></p>
<p>事务T1按照一定条件从数据库中<strong>读取了某些数据记录</strong>后，</p>
<p>事务T2删除/增加了部分记录，</p>
<p>当T1再次按照<strong>相同条件</strong>读取数据时，发现某些记录神秘的消失/出现了。</p>
<h4 id="读脏数据">读“脏”数据
</h4><p>事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，</p>
<p><strong>T1由于某种原因被撤销</strong>，这时T1已修改过的数据恢复为原值，</p>
<p>T2读到的数据就与数据库中的不一致，为“脏”数据。</p>
<blockquote>
<p>写后读，写撤回导致读错误。</p>
</blockquote>
<h3 id="并发控制措施封锁">并发控制措施——封锁
</h3><p>事务T在对某个数据对象操作之前，先向系统<strong>发出请求，对其加锁</strong>，从而对该数据对象有了一定的控制，在事务T释放它的锁之前，其他事务不能更新此数据对象。</p>
<blockquote>
<p>不能更新的原因是其他事务加锁失败。这也就是一级封锁协议中<strong>读直接无锁</strong>导致<strong>读脏数据</strong>无法阻拦的原因。</p>
</blockquote>
<h4 id="封锁的类型">封锁的类型
</h4><p>排它锁（<strong>X锁</strong>，Exclusive lock）：事务T对数据对象A加上X锁，则<strong>只允许T读取和修改A</strong>，其它事务对A的任何<strong>封锁请求</strong>都不能成功（<strong>因而不能</strong>读取和修改R），直至T释放A上的X锁。</p>
<p>共享锁（<strong>S锁</strong>，Share lock）：事务T对数据对象A加上S锁，则<strong>事务T可以读取但不能修改A</strong>，其它事务<strong>只能对A加S锁</strong>（因而可以读取A），而<strong>不能对A的加X锁</strong>（因而不能修改A），直到T释放A上的S锁。</p>
<blockquote>
<p>注意封锁机制是靠<strong>锁</strong>实现的，锁只能阻拦锁！</p>
</blockquote>
<p>相容矩阵：（读读或者数据不同为True）</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106154533733.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106154533733"
	
	
></p>
<h4 id="封锁协议">封锁协议
</h4><h5 id="一级封锁协议read-uncommitted">一级封锁协议（Read Uncommitted）
</h5><p>事务T在修改数据R之前<strong>必须对其加X锁</strong>，直到<strong>事务结束</strong>才释放。</p>
<blockquote>
<p>事务结束包括正常结束(COMMIT)和非正常结束(ROLLBACK)。</p>
</blockquote>
<p>对<strong>更新</strong>提出了很严格的要求，但对于<strong>读取，根本没有锁</strong>。</p>
<p>可解决：丢失修改</p>
<p>不可解决：读脏数据、不可重复读</p>
<h5 id="二级封锁协议read-committed">二级封锁协议（Read Committed）
</h5><p>一级封锁协议 +</p>
<p>事务T在<strong>读取</strong>数据R之前必须先对其<strong>加S锁</strong>，<strong>读完后即可释放</strong>S锁。</p>
<blockquote>
<p>读完即可释放，而非事务结束！</p>
</blockquote>
<p>可解决：丢失修改、读脏数据（读有锁了，肯定写彻底结束后才能读）</p>
<p>不可解决：<strong>不可重复读</strong>（同一事务内，每次读取都单独上锁开锁，读取中间存在缝隙）</p>
<h5 id="三级封锁协议repeatable-read">三级封锁协议（Repeatable Read）
</h5><p><strong>一级</strong>封锁协议 +</p>
<p>事务T在读取R之前必须对其加S锁，直到<strong>事务结束才释放。</strong></p>
<p>可解决：丢失修改、读脏数据、不可重复读</p>
<p>不可解决：不可重复读之<strong>幻影行</strong>之insert，因为当前是针对于数据的上锁，insert的新的数据未能和读的数据产生冲突。</p>
<blockquote>
<p>四级封锁协议（Serializable 可串行化）解决了此问题</p>
</blockquote>
<h4 id="封锁的危害">封锁的危害
</h4><h5 id="封锁级别">封锁级别
</h5><p>封锁级别并非越高越好，极度封锁虽然安全，但会<strong>让并行趋于串行化</strong>，违背初衷。</p>
<p>此外，不安全的行为，尤其<strong>在读操作上</strong>，一定程度上是可允许的。</p>
<blockquote>
<p>人口统计数据一直在更新，每次数据都是不准的，也都是可接受的。</p>
</blockquote>
<h5 id="活锁与死锁">活锁与死锁
</h5><p>活锁是指<strong>某事务</strong>长时间无法申请到锁，从而长期阻塞的问题。<strong>解决方法</strong>：与等待时间相关的<strong>调度</strong>方案。</p>
<p>死锁：</p>
<p>在数据库运行期间，如果存在<strong>一个事务集合{T0，T1，…，Tn}</strong>，使得T0等待T1持有的数据项锁， …， Tn-1等待Tn持有的数据项锁，Tn等待T0持有的数据项锁，则称<strong>系统处于死锁状态</strong>， {T0，T1，…，Tn }称为<strong>死锁事务集合</strong>。</p>
<p>最经典的死锁：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106160405452.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106160405452"
	
	
></p>
<h3 id="死锁的解决">死锁的解决
</h3><h4 id="预防死锁">预防死锁
</h4><h5 id="一次封锁法">一次封锁法
</h5><p>一次封锁法要求每个事务<strong>必须一次</strong>将其所有要使用的数据<strong>全部加锁</strong>，<strong>否则就不能执行</strong>。</p>
<p>由于需要扩大加锁的范围，因此<strong>降低了系统的并发度</strong>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106160729807.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106160729807"
	
	
></p>
<h5 id="顺序封锁法">顺序封锁法
</h5><p>顺序封锁法是预先对数据对象<strong>规定一个封锁顺序</strong>，所有的事务都要按照这个顺序实行封锁。</p>
<p>由于数据库中数据的不断变化和事务封锁要求的动态提出，<strong>难度往往很大</strong>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106160744681.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106160744681"
	
	
></p>
<h4 id="死锁检测与恢复">死锁检测与恢复
</h4><h5 id="死锁检测">死锁检测
</h5><h6 id="超时法">超时法
</h6><p>如果一个事务的等待时间超过了规定的期限，就认为发生了死锁。</p>
<h6 id="等待图法">等待图法
</h6><p>事务等待图是一个有向回路G=(T, U)。T为结点的集合，每个结点表示正在运行的事务；U为边的集合，每条边表示事务等待的情况。<strong>若T1等待T2，则T1，T2之间画一条有向边，从T1指向T2</strong>。事务等待图动态地反映了所有事务的等待情况。</p>
<p>如果发现<strong>图中存在回路</strong>，则表示系统出现死锁。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106160949442.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106160949442"
	
	
></p>
<h5 id="死锁恢复">死锁恢复
</h5><p>选择一个<strong>处理死锁代价最小</strong>的事务，将其<strong>撤销</strong>，<strong>释放</strong>此事务持有的所有锁，使其他事务得以继续运行下去。</p>
<p>对于所撤销的事务已作的操作必须都加以撤销。死锁结束后再REDO。</p>
<h3 id="事务的调度与可串行性">事务的调度与可串行性
</h3><p><strong>串行调度</strong>，属于<strong>同一事务的指令紧挨</strong>在一起。对于有n个事务的事务组，可以有**n!**个有效调度。</p>
<p><strong>并行调度</strong>，来自不同事务的指令<strong>可以交叉执行</strong>，可以有大于**n!**个有效调度。</p>
<h4 id="调度的正确性">调度的正确性
</h4><p>T1:读B;A=B+1;写回A;</p>
<p>T2:读A;B=A+1;写回B;</p>
<p>对其进行串行调度：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106162004092.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106162004092"
	
	
></p>
<p>串行调度<strong>一定是正确</strong>的，尽管图中两个结果不同，我们也都称之为正确的。</p>
<p>并发执行是正确的，当且仅当<strong>其结果与按某一次序串行的执行它们时的结果相同</strong>。</p>
<p>这种调度策略称为<strong>可串行化调度</strong>。</p>
<p>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106162142832.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106162142832"
	
	
></p>
<p>图中的左侧调度就不是可串行化调度，不是正确的。而右侧调度则是正确调度、可串行化调度。</p>
<p>如何判断是否是可串行化调度？</p>
<h4 id="冲突可串行化调度">冲突可串行化调度
</h4><p>这是一个很硬核的方法：</p>
<blockquote>
<p>有这样一些指令(组)的<strong>相邻</strong>交换操作，可以不影响运行的结果，并把该调度转为某个串行调度，那么该调度可串行化。</p>
</blockquote>
<p>哪些指令的交换操作不影响运行的结果？</p>
<ul>
<li>对<strong>不同</strong>数据对象进行的操作</li>
<li>对同一数据对象的<strong>读操作之间</strong></li>
</ul>
<p>交换操作可能影响运行的结果的操作叫做<strong>冲突操作</strong>。</p>
<p>冲突操作包括不同事务对<strong>同一数据</strong>的<strong>读写操作和写写操作</strong>。</p>
<ul>
<li>Ri（x）与  Wj（x）</li>
<li>Wi（x）与 Wj（x）</li>
</ul>
<p>例子：R1(A) W1(A) <strong>R2(A) W2(A)</strong> <code>R1(B) W1(B)</code> R2(B) W2(B)</p>
<p>&mdash;&mdash;&gt; R1(A) W1(A) <code>R1(B) W1(B)</code> <strong>R2(A) W2(A)</strong> R2(B) W2(B)  变为了串行调度。</p>
<p>这个方法只是一个充分条件。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106163731193.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106163731193"
	
	
></p>
<p>上图的例子就是一个典例。当前语境下W1(X)和W2(X)其实可交换，但是属于冲突操作。</p>
<h4 id="两段锁协议">两段锁协议
</h4><ol>
<li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。</li>
<li>在释放一个封锁之后，事务不再获得任何其它封锁。</li>
</ol>
<p>也就是两个阶段，加锁阶段与解锁阶段，不存在解锁后再加锁。</p>
<p>第一阶段是获得封锁，也称<strong>扩展阶段</strong>。事务不能释放任何锁。</p>
<p>第二阶段是释放阶段，也称<strong>收缩阶段</strong>。事务不能申请任何锁。</p>
<p><strong>定理：若所有事务均遵从两段锁协议，则这些事务的所有并行调度都是可串行化的。</strong></p>
<p>这个方法也只是一个充分条件，但是他要更加直观简单。</p>
<blockquote>
<p>串行调度并不满足两段锁协议，本身就是一个反例。</p>
</blockquote>
<p>不过我们至少知道：一个调度如果是错误的，那他一定不满足两段锁协议。</p>
<p>比如之前的例子，就显然没有遵循两段锁协议：</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106164703362.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106164703362"
	
	
></p>
<p>两段锁协议<strong>不能用于预防死锁</strong>。</p>
<p>因为只是在加锁阶段就可以直接死锁。</p>
<h4 id="多粒度封锁">多粒度封锁
</h4><p>封锁对象的大小称为<strong>封锁粒度</strong>。</p>
<p>封锁对象包括<strong>逻辑单元</strong>（属性值、元组、关系……）和<strong>物理单元</strong>（物理页、块）。</p>
<p>封锁粒度大，则<strong>并发度低</strong>，封锁机构简单，<strong>开销小</strong>。</p>
<p>多粒度封锁：在一个系统中同时<strong>支持多种封锁粒度</strong>供不同的事务选择。</p>
<p>选择封锁粒度时应同时考虑<strong>封锁开销和并发度</strong>两个因素，适当选择封锁粒度以达到最优效果。</p>
<h5 id="多粒度树">多粒度树
</h5><p>多粒度树的<strong>根结点</strong>是<strong>整个数据库</strong>，表示最大的粒度。<strong>叶结点</strong>表示最小的粒度。</p>
<p>多粒度树中的每个结点可被独立地加锁，此外：</p>
<p>对一个结点加锁意味着<strong>这个结点的所有后裔结点</strong>也被加以同样类型的锁。</p>
<blockquote>
<ul>
<li>
<p>显式封锁是应事务的要求直接加到数据对象上的封锁。</p>
</li>
<li>
<p>隐式封锁是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁。</p>
</li>
</ul>
</blockquote>
<h5 id="意向锁">意向锁
</h5><p>一般的，对某个数据对象加锁，系统要</p>
<ol>
<li>检查该数据对象上<strong>有无显式封锁与之冲突</strong>；</li>
<li>还要检查其所有上级结点的显式封锁，也是否有<strong>隐式封锁</strong>与之冲突</li>
<li>还要检查其所有<strong>下级结点的显式封锁</strong>是否与本次加锁产生的隐式封锁冲突。</li>
</ol>
<p>这样效率<strong>效率很低</strong>，因此引入了意向锁。</p>
<p>如果对一个结点加意向锁，则说明<strong>该结点的下层结点正在被加锁</strong>。</p>
<p>因为对任一结点加锁时，必须<strong>先对它的上层结点加意向锁</strong>。</p>
<p><strong>意向共享</strong>锁（Intent Share Lock，简称IS锁）</p>
<p>表示它的后裔结点拟（意向）加S锁。</p>
<p><strong>意向排它</strong>锁（Intent Exclusive Lock ，简称IX锁）</p>
<p>表示它的后裔结点拟（意向）加X锁。</p>
<p><strong>意向共享排它</strong>锁（ Share Intent Exclusive Lock ，简称SIX锁）</p>
<p>表示对它加S锁，再加IX锁，即SIX=S+IX。</p>
<p><strong>相容矩阵</strong></p>
<p>S 只和 S IS 相容。</p>
<p>X一定不相容。</p>
<p>IS 只和 X 不相容。</p>
<p>IX 只和 IS IX 相容。</p>
<p>SIX 只和 IS 相容。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106170727938.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106170727938"
	
	
></p>
<h2 id="数据库存储">数据库存储
</h2><h3 id="存储介质">存储介质
</h3><p>CPU寄存器&mdash;&ndash;高速缓存 L1/L2/L3&mdash;&ndash;主存储器&mdash;&ndash;闪存&mdash;&ndash;磁盘&mdash;&ndash;光盘&mdash;&ndash;磁带</p>
<p>在此着重讲解磁盘。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106171602811.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106171602811"
	
	
></p>
<p><strong>磁道</strong>：盘片的表面被逻辑地划分为磁道。</p>
<p><strong>扇区</strong>：磁道又被逻辑地划分为扇区；扇区是从<strong>磁盘读出和写入数据的最小单位</strong>，通常大小为512字节。</p>
<blockquote>
<p>磁头可同时移动扫过多个跨磁道扇区构成扇面。</p>
</blockquote>
<p><strong>物理块</strong>：一个盘片的一条磁道内<strong>几个连续的扇区</strong>构成的序列称为物理块，一般也简称块；</p>
<blockquote>
<p>数据在磁盘和主存储器之间<strong>以块为单位传输</strong>。</p>
</blockquote>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106171934914.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106171934914"
	
	
></p>
<h4 id="raid">RAID
</h4><p>磁盘可以构成<strong>磁盘阵列</strong>。</p>
<p>RAID即独立磁盘冗余阵列。将多个单独的物理硬盘<strong>以不同的方式组合成一个逻辑硬盘</strong>，从而提高了硬盘的读写性能和数据安全性。</p>
<p><strong>提升容量、提升性能、提升可靠性</strong></p>
<p>根据不同的组合方式可以分为不同的RAID级别。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106172250298.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106172250298"
	
	
></p>
<p>RAID0：至少两个盘。提升了性能，没有任何安全性防护。</p>
<p>RAID1：至少两个盘。空间利用率低，读写性能无提升。</p>
<p>RAID2：第1个、第2个、第4个……第2的n次幂个硬盘都是校验盘。</p>
<p>RAID3：专门的校验盘。</p>
<p>RAID5：至少三个盘，校验信息分散在不同磁盘。</p>
<p>RAID6：允许两个硬盘同时失效。</p>
<p>常用 RAID0，RAID1，RAID5，及其组合：</p>
<ul>
<li>
<p>RAID 0+1：先做RAID 0，后做RAID 1，同时提供数据条带化和镜像</p>
</li>
<li>
<p>RAID 10：类似于RAID 0+1，区别在于先做RAID 1，后做RAID 0</p>
</li>
<li>
<p>RAID 50：先做RAID 5，后做RAID 0，能有效提高RAID 5的性能</p>
</li>
</ul>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260106173216061.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260106173216061"
	
	
></p>
<h3 id="缓冲区调度">缓冲区调度
</h3><p>OS常用<strong>最近未使用</strong> LRU，但是 LRU 对某些<strong>涉及重复扫描数据</strong>的存取模式来说是<strong>很差</strong>的策略！</p>
<p>对于DB，要根据不同情况选择方案。一般地，如果需要替换，则最好替换<strong>最近使用的块</strong>。</p>
<ul>
<li>
<p>支持<strong>钉住</strong>不允许写回磁盘的内存块。如循环连接中的<strong>外层循环</strong>中的数据块。</p>
</li>
<li>
<p>支持<strong>立即替换</strong>策略。完成某任务后直接替换所有相关块。</p>
</li>
<li>
<p>支持<strong>最近使用</strong>策略。如循环连接中的内层循环数据块，只会用到一次，用完直接替换。</p>
</li>
<li>
<p>支持<strong>某些数据</strong>优先存放到缓冲区中，如尽可能将<strong>数据字典块</strong>保存在缓冲区中。</p>
</li>
</ul>
<h3 id="数据库文件结构">数据库文件结构
</h3><p>数据文件：数据库数据的物理存储。</p>
<h4 id="记录文件">记录文件
</h4><p>定长记录文件：记录的长度是固定的。</p>
<ul>
<li>
<p>优势：记录存取简单。</p>
</li>
<li>
<p>删除记录困难：不应把被删除的记录的后面的记录都往上移，而是应该用链表把被删除的记录串起来。</p>
</li>
</ul>
<p>变长记录文件：文件中能够容纳不同长度的、不同类型的记录。</p>
<ul>
<li>支持变长数据类型：如varchar</li>
<li>支持多种记录类型</li>
<li>记录存取灵活，空间利用率高</li>
<li><strong>Slotted Page结构</strong>：<img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260107001436455.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260107001436455"
	
	
></li>
<li><strong>定长表示法</strong>：使用一个或多个定长记录表示一个变长记录
<ul>
<li>预留空间法：利用具有<strong>已知最大长度</strong>的定长记录</li>
<li>指针法：<strong>若干定长</strong>记录通过指针链在一起</li>
</ul>
</li>
</ul>
<h4 id="记录文件的组织">记录文件的组织
</h4><ul>
<li>
<p>堆：记录可置于文件中的<strong>任何有空间</strong>的地方</p>
</li>
<li>
<p>顺序：记录<strong>按顺序存储</strong>，基于每条记录在搜索码上的值</p>
</li>
<li>
<p>散列（hash）：对记录的某属性计算hash函数，计算结果决定该记录应该置于文件的哪个块中</p>
</li>
</ul>
<p>每个关系的记录可存储在单独的文件中。</p>
<p>但在<strong>聚簇文件组织</strong>下, 单个和多个关系的记录<strong>都可存储于同一文件</strong>中。</p>
<blockquote>
<p>语义关联密切的记录存储在同一块中<strong>可减少磁盘 I/O</strong></p>
</blockquote>
<p>因为物理顺序只能有一个，聚簇应该用在最需要的位置。</p>
<h5 id="顺序文件组织">顺序文件组织
</h5><p>适用于需要顺序地高效处理<strong>按照某个搜索码排列</strong>的整个文件的记录。</p>
<p>通过<strong>指针</strong>，同时尽可能保证<strong>逻辑次序和物理次序</strong>保持一致，减少可能的磁盘操作。</p>
<p><strong>维护记录的物理顺序</strong>代价高：虽然用指针维护顺序，但还是需要时常<strong>重组文件</strong>以恢复物理存储顺序。</p>
<h4 id="关系数据库的文件选择">关系数据库的文件选择
</h4><p><strong>存储关系到一个文件</strong></p>
<ul>
<li>
<p><strong>充分利用OS</strong>所提供的功能，减少DMBS的处理代价</p>
</li>
<li>
<p>DBMS不支持某些优化策略</p>
</li>
</ul>
<p><strong>存储多个关系到一个文件</strong></p>
<ul>
<li>
<p>DBMS支持某些优化策略，可以在文件中设计复杂的结构</p>
</li>
<li>
<p>数据库的<strong>大小和复杂性</strong>增大</p>
</li>
</ul>
<h4 id="数据字典">数据字典
</h4><p>数据字典，也称为系统目录，保存元数据，即<strong>关于数据的数据</strong>，也是需要存储的。</p>
<p>内容包括<strong>关系</strong>的信息、<strong>用户及账号</strong>信息与口令、<strong>统计与描述</strong>数据、<strong>物理文件组织</strong>信息、<strong>索引</strong>信息。</p>
<h2 id="索引">索引
</h2><h3 id="基本概念">基本概念
</h3><p>索引机制用于<strong>加速对所需数据的存取</strong>。</p>
<p>更新文件时，该文件上的<strong>每个索引都必须更新</strong>，有一定开销。</p>
<p><strong>搜索码</strong>：用来在文件中查找记录的<strong>属性或属性集合</strong>。</p>
<p>索引文件一般比原始文件小的多。</p>
<p><strong>两种基本索引</strong></p>
<ul>
<li>有序索引：搜索码<strong>按顺序</strong>存储</li>
<li>散列索引：搜索码<strong>被散列函数分配</strong>到若干桶中.</li>
<li>new：位图索引。实现高效的<strong>多键查询</strong>。将数据转储为二进制01串，利用交并补运算实现查询。</li>
</ul>
<p><strong>评价手段</strong>：</p>
<ul>
<li>
<p>有效支持的存取类型：<strong>Point Query</strong>（属性值为某值的记录）、<strong>Range Query</strong>（属性值位于某范围的记录）</p>
</li>
<li>
<p>存取时间、插入时间、删除时间</p>
</li>
<li>
<p>空间开销</p>
</li>
</ul>
<p>索引分为<strong>主索引</strong>与<strong>辅助索引</strong>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260107004203436.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260107004203436"
	
	
></p>
<h4 id="主索引">主索引
</h4><p><strong>主索引</strong>：顺序文件的<strong>记录顺序</strong>正是索引<strong>搜索码的顺序</strong>，也称为<strong>聚簇索引</strong>。</p>
<ul>
<li>一个关系只能有一个主索引。</li>
<li>主索引的搜索码通常是主码, 但并非必要。</li>
<li>索引顺序文件：带有主索引的顺序文件。</li>
</ul>
<h5 id="多级索引">多级索引
</h5><p>如果主索引不能一次放入内存，存取代价就会很大。</p>
<p>将主索引视为<strong>存储在磁盘上的顺序文件</strong>并为它<strong>建立一个稀疏索引</strong>。</p>
<ul>
<li>外索引：主索引的稀疏索引</li>
<li>内索引：主索引文件</li>
</ul>
<p>如果外索引仍太大而不能放入内存，还可再为它创建另一层索引。</p>
<blockquote>
<p>当插入或删除文件记录时，<strong>各层索引</strong>都必须更新。</p>
</blockquote>
<h4 id="辅助索引">辅助索引
</h4><p><strong>辅助索引</strong>：索引<strong>搜索码的顺序与文件的记录</strong>顺序不同，也称为非聚簇索引。</p>
<ul>
<li>对每个搜索码值都可有一辅助索引记录。</li>
<li><strong>辅助索引必须是稠密的</strong>。</li>
</ul>
<p>利用<strong>主索引做顺序扫描</strong>很高效，但利用辅助索引做顺序扫描则代价昂贵，因为按照辅助索引搜索码进行扫描，其对应的<strong>物理位置并不紧密连接</strong>，对每个记录的存取都可能导致存取一个新的磁盘块。</p>
<h3 id="有序索引">有序索引
</h3><h4 id="稠密索引文件">稠密索引文件
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260107004725162.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260107004725162"
	
	
></p>
<p>文件中的<strong>每个搜索码值都有索引</strong>记录。</p>
<p>稠密索引的数据可以不按照索引数据物理存放。</p>
<h4 id="稀疏索引文件">稀疏索引文件
</h4><p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260107004709512.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260107004709512"
	
	
></p>
<p><strong>只对某些搜索码值有索引记录</strong>。</p>
<p>文件记录必须<strong>按搜索码排序</strong>才可用，原因是：定位具有搜索码值K的记录时，需要</p>
<ul>
<li>找到具有<strong>比K小</strong>的<strong>最大</strong>搜索码值的索引记录，从该索引记录指向的文件记录<strong>开始顺序搜索</strong>文件。</li>
</ul>
<p>特点：好建不好用。</p>
<ul>
<li>
<p>插入和删除需要<strong>较少空间与维护开销</strong>.。</p>
</li>
<li>
<p>查找记录<strong>一般比稠密索引慢</strong>。</p>
</li>
</ul>
<h3 id="b树索引文件">B+树索引文件
</h3><p>索引顺序文件如果采用指针维护，需要定期重建（删除所有索引并重新创建），开销很大。</p>
<p>B+树索引结构是<strong>使用最广泛</strong>的在数据<strong>插入和删除</strong>情况下能够<strong>保持执行效率</strong>的索引结构之一。</p>
<p><strong>优点</strong>：插入与删除时仅以<strong>较少的局部的变化</strong>来自动重组，不需要整个文件重组来维持性能。</p>
<p><strong>缺点</strong>：额外的<strong>插入与删除开销</strong>，<strong>空间开销</strong>。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260107010708108.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260107010708108"
	
	
></p>
<p>从树根到叶节点的<strong>路径长度相同</strong>，所有叶节点都在同一层，也就是访问不同数据<strong>所花费的时间是相对稳定</strong>的。</p>
<p><img src="C:%5cUsers%5cT14%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20260107012307063.png"
	
	
	
	loading="lazy"
	
		alt="你看不到的图片-20260107012307063"
	
	
></p>
<h3 id="hash数据索引">Hash数据索引
</h3><p>一个桶是一个存储单元，包含一个或者多个记录 (桶的大小一般是磁盘块大小)</p>
<p>我们根据搜索码的值，利用Hash函数<strong>直接得到搜索码所在的桶</strong>，需要<strong>顺序扫描</strong>该桶来定位到一个记录。</p>
<p>Hash索引通常是<strong>辅助索引</strong>。</p>
<p>尽管桶溢出的可能性会减少，但是绝不可能完全消除，通过溢出桶来解决.。</p>
<blockquote>
<p>溢出桶：一个桶的溢出桶集合通过链连接起来</p>
</blockquote>
<ul>
<li>静态索引技术。可能需要周期性重组。</li>
<li>动态Hash表，使用可扩展hash函数，通过桶的分解或合并来适应数据库大小的变化</li>
</ul>
<h3 id="总结">总结
</h3><p>给定数值进行确定性查询：hash</p>
<p>range查询：有序索引</p>
<p>B+树索引对于给定<strong>数值的查询</strong>和<strong>范围查询</strong>都是比较有效的，但在数据的<strong>插入、删除</strong>时动态调整代价高。</p>
<p>多属性索引中，第二关键字意义远弱于第一关键字。</p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script><footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2024 - 
        
        2026 Demiurge
    </section>
    
    <section class="powerby">
        
            Easy Life and Easy Learning <br/>
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.27.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>

<div class="busuanzi-footer">
  <span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span id="busuanzi_container_site_uv">
    本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>
</div></footer>

    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<div id="aplayer"></div>
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>

<script>
    const home = "https://demiurge-zby.github.io/";
    console .log(home);
    const ap = new APlayer({
        container: document.getElementById('aplayer'),
        audio: [{
            name: 'Sense of Wonder',
            artist: 'Yu_Asahina',
            url: home + 'music/Sense of wonder/sense of wonder.mp3',
            cover: home + 'music/Sense of wonder/cover.jpg'
        },
        {
            name: 'Demiurge',
            artist: 'Rabpit',
            url: home + 'music/demiurge/demiurge.mp3',
            cover: home + 'music/demiurge/cover.jpg'
        },
        {
            name: 'Designant.',
            artist: 'Designant',
            url: home + 'music/Designant/shejimayi.mp3',
            cover: home + 'music/Designant/cover.jpg'
        },
        {
            name: 'Xaleid◆scopiX',
            artist: 'xi',
            url: home + 'music/Xaleid◆scopiX/xx.mp3',
            cover: home + 'music/Xaleid◆scopiX/cover.jpg'
        },
        {
            name: 'Lament Rain',
            artist: 'Ashrount vs. 打打だいず',
            url: home + 'music/Lament Rain/lamian.mp3',
            cover: home + 'music/Lament Rain/cover.jpg'
        },
        {
            name: 'Breach of Faith',
            artist: 'Supire feat.eili',
            url: home + 'music/Breach of Faith/song.mp3',
            cover: home + 'music/Breach of Faith/cover.jpg'
        },
        {
            name: 'WORLDCALL',
            artist: 'Blacklolita',
            url: home + 'music/WORLDCALL/WORLDCALL.mp3',
            cover: home + 'music/WORLDCALL/cover.jpg'
        },
        {
            name: 'Meteorite Lotus',
            artist: 'wa.',
            url: home + 'music/Meteorite Lotus/shilian.mp3',
            cover: home + 'music/Meteorite Lotus/cover.jpg'
        },
        {
            name: 'И00.',
            artist: 'Se-U-Ra',
            url: home + 'music/И00/N00.mp3',
            cover: home + 'music/И00/cover.jpg'
        },
        {
            name: 'Observatory',
            artist: 'かめりあ',
            url: home + 'music/Observatory/observatory.mp3',
            cover: home + 'music/Observatory/cover.jpg'
        },
        {
            name: '白噪音',
            artist: '- -',
            url: home + 'music/白噪音/whitenoise.mp3',
            cover: home + 'music/白噪音/cover.jpg'
        }],
        fixed: true
    });
    window.onbeforeunload = () => {
        
        const playInfo = {
            index: ap.list.index,
            currentTime: ap.audio.currentTime,
            paused: ap.paused
        };
        localStorage.setItem("playInfo", JSON.stringify(playInfo));
    };

    

    window.onload = () => {
        
        const playInfo = JSON.parse(localStorage.getItem("playInfo"));
        if (!playInfo) {
            return;
        }
        
        ap.list.switch(playInfo.index);
        
        setTimeout(() => {
            
            ap.seek(playInfo.currentTime);
            
            if (!playInfo.paused) {
                ap.play()
            }
        }, 500);
    };
</script>
<script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script>

    
    <script src=https://demiurge-zby.github.io/js/topbar.min.js></script>

<script>
    var pjax = new Pjax({
  selectors: [".main-container",".js-Pjax"]
})
pjax._handleResponse = pjax.handleResponse;

pjax.handleResponse = function(responseText, request, href, options) {
  if (request.responseText.match("<html")) {
    
    let newDom = new DOMParser().parseFromString(responseText, 'text/html');
            
            let bodyClass = newDom.body.className;
            document.body.setAttribute("class", bodyClass)
    setTimeout(() =>{
        pjax._handleResponse(responseText, request, href, options);
    }, 500)
  } else {
    
  }
}
document.addEventListener('pjax:send', () => {
    topbar.show();
})
document.addEventListener('pjax:complete', () => {
    window.Stack.init();
    topbar.hide();
})

topbar.config({
        barColors: {
            '0': 'rgba(0, 210, 255,  1)' ,
            '1.0': 'rgba(0, 255, 100, 1)',
        }
    })

</script>

<div class="js-Pjax"></div>
    <script>
        
        (function() {
            let script = document.createElement('script');
            
             script.setAttribute('key', 'value');
            ...
            
            document.querySelector('xxx').appendchild(script)
        })(document)
    </script>
<div>
    </body>
</html>
